[
  {
    "question": "What is the current building key, building street address, city, state, and postal code of the history department?",
    "db_id": "dw",
    "sql": "SELECT DISTINCT d.FCLT_BUILDING_KEY, e.BUILDING_STREET_ADDRESS, d.CITY, d.STATE, d.POSTAL_CODE FROM FCLT_BUILDING_ADDRESS d JOIN FCLT_ROOMS a ON a.FCLT_BUILDING_KEY = d.FCLT_BUILDING_KEY JOIN FCLT_ORG_DLC_KEY b ON a.FCLT_ORGANIZATION_KEY = b.FCLT_ORGANIZATION_KEY JOIN MASTER_DEPT_HIERARCHY c ON b.DLC_KEY = c.DLC_KEY JOIN BUILDINGS e ON e.BUILDING_KEY = d.FCLT_BUILDING_KEY WHERE lower(c.DLC_NAME) = lower('History') AND d.ADDRESS_PURPOSE = 'STREET';",
    "oracle_sql": "SELECT DISTINCT d.FCLT_BUILDING_KEY, e.BUILDING_STREET_ADDRESS, d.CITY, d.STATE, d.POSTAL_CODE FROM FCLT_BUILDING_ADDRESS d JOIN FCLT_ROOMS a ON a.FCLT_BUILDING_KEY = d.FCLT_BUILDING_KEY JOIN FCLT_ORG_DLC_KEY b ON a.FCLT_ORGANIZATION_KEY = b.FCLT_ORGANIZATION_KEY JOIN MASTER_DEPT_HIERARCHY c ON b.DLC_KEY = c.DLC_KEY JOIN BUILDINGS e ON e.BUILDING_KEY = d.FCLT_BUILDING_KEY WHERE lower(c.DLC_NAME) = lower('History') AND d.ADDRESS_PURPOSE = 'STREET';",
    "gold_tables": [
      "dw#sep#FCLT_BUILDING_ADDRESS",
      "dw#sep#FCLT_ROOMS",
      "dw#sep#FCLT_ORG_DLC_KEY",
      "dw#sep#MASTER_DEPT_HIERARCHY",
      "dw#sep#BUILDINGS"
    ],
    "mapping": {
      "building key": [
        "FCLT_BUILDING_ADDRESS.FCLT_BUILDING_KEY"
      ],
      "building street address": [
        "BUILDINGS.BUILDING_STREET_ADDRESS",
        "FCLT_BUILDING_ADDRESS.ADDRESS_PURPOSE"
      ],
      "city": [
        "FCLT_BUILDING_ADDRESS.CITY"
      ],
      "state": [
        "FCLT_BUILDING_ADDRESS.STATE"
      ],
      "postal code": [
        "FCLT_BUILDING_ADDRESS.POSTAL_CODE"
      ],
      "history department": [
        "MASTER_DEPT_HIERARCHY.DLC_NAME"
      ]
    },
    "join_keys": [
      [
        "FCLT_BUILDING_ADDRESS.FCLT_BUILDING_KEY",
        "FCLT_ROOMS.FCLT_BUILDING_KEY"
      ],
      [
        "FCLT_ROOMS.FCLT_ORGANIZATION_KEY",
        "FCLT_ORG_DLC_KEY.FCLT_ORGANIZATION_KEY"
      ],
      [
        "FCLT_ORG_DLC_KEY.DLC_KEY",
        "MASTER_DEPT_HIERARCHY.DLC_KEY"
      ],
      [
        "FCLT_BUILDING_ADDRESS.FCLT_BUILDING_KEY",
        "BUILDINGS.BUILDING_KEY"
      ]
    ]
  },
  {
    "question": "Show the unique activity titles, locations, term start date, and supervisor name for all independent activities, sorted by the ascending order of start date.",
    "db_id": "dw",
    "sql": "SELECT DISTINCT a.activity_title, d.session_location, c.term_start_date, b.person_name AS Leader FROM iap_subject_detail a JOIN iap_subject_person b ON a.iap_subject_person_key = b.iap_subject_person_key JOIN academic_terms_all c ON c.term_code = a.term_code JOIN iap_subject_session d ON a.iap_subject_session_key = d.iap_subject_session_key WHERE b.person_role = 'Activity leader' ORDER BY term_start_date ASC;",
    "oracle_sql": "SELECT DISTINCT a.activity_title, d.session_location, c.term_start_date, b.person_name AS Leader FROM iap_subject_detail a JOIN iap_subject_person b ON a.iap_subject_person_key = b.iap_subject_person_key JOIN academic_terms_all c ON c.term_code = a.term_code JOIN iap_subject_session d ON a.iap_subject_session_key = d.iap_subject_session_key WHERE b.person_role = 'Activity leader' ORDER BY term_start_date ASC;",
    "gold_tables": [
      "dw#sep#IAP_SUBJECT_DETAIL",
      "dw#sep#IAP_SUBJECT_PERSON",
      "dw#sep#ACADEMIC_TERMS_ALL",
      "dw#sep#IAP_SUBJECT_SESSION"
    ],
    "mapping": {
      "activity titles": [
        "IAP_SUBJECT_DETAIL.ACTIVITY_TITLE"
      ],
      "locations": [
        "IAP_SUBJECT_SESSION.SESSION_LOCATION"
      ],
      "term start date": [
        "ACADEMIC_TERMS_ALL.TERM_START_DATE"
      ],
      "supervisor name": [
        "IAP_SUBJECT_PERSON.PERSON_NAME",
        "IAP_SUBJECT_PERSON.PERSON_ROLE"
      ]
    },
    "join_keys": [
      [
        "IAP_SUBJECT_PERSON.IAP_SUBJECT_PERSON_KEY",
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_PERSON_KEY"
      ],
      [
        "ACADEMIC_TERMS_ALL.TERM_CODE",
        "IAP_SUBJECT_DETAIL.TERM_CODE"
      ],
      [
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_SESSION_KEY",
        "IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY"
      ]
    ]
  },
  {
    "question": "List the unique course instructor names, course titles, and the amount of material for each course instructor key and the key of subject offered.",
    "db_id": "dw",
    "sql": "SELECT DISTINCT LIBRARY_COURSE_INSTRUCTOR.instructor_name, LIBRARY_SUBJECT_OFFERED.subject_title, COUNT(LIBRARY_RESERVE_CATALOG.catalog_isbn) OVER (PARTITION BY LIBRARY_COURSE_INSTRUCTOR.LIBRARY_COURSE_INSTRUCTOR_KEY, LIBRARY_SUBJECT_OFFERED.LIBRARY_SUBJECT_OFFERED_KEY) FROM LIBRARY_COURSE_INSTRUCTOR JOIN LIBRARY_RESERVE_MATRL_DETAIL ON LIBRARY_COURSE_INSTRUCTOR.LIBRARY_COURSE_INSTRUCTOR_KEY = LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_COURSE_INSTRUCTOR_KEY JOIN LIBRARY_SUBJECT_OFFERED ON LIBRARY_SUBJECT_OFFERED.LIBRARY_SUBJECT_OFFERED_KEY = LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_SUBJECT_OFFERED_KEY JOIN LIBRARY_RESERVE_CATALOG ON LIBRARY_RESERVE_CATALOG.LIBRARY_RESERVE_CATALOG_KEY = LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_RESERVE_CATALOG_KEY;",
    "oracle_sql": "SELECT DISTINCT LIBRARY_COURSE_INSTRUCTOR.instructor_name, LIBRARY_SUBJECT_OFFERED.subject_title, COUNT(LIBRARY_RESERVE_CATALOG.catalog_isbn) OVER (PARTITION BY LIBRARY_COURSE_INSTRUCTOR.LIBRARY_COURSE_INSTRUCTOR_KEY, LIBRARY_SUBJECT_OFFERED.LIBRARY_SUBJECT_OFFERED_KEY) FROM LIBRARY_COURSE_INSTRUCTOR JOIN LIBRARY_RESERVE_MATRL_DETAIL ON LIBRARY_COURSE_INSTRUCTOR.LIBRARY_COURSE_INSTRUCTOR_KEY = LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_COURSE_INSTRUCTOR_KEY JOIN LIBRARY_SUBJECT_OFFERED ON LIBRARY_SUBJECT_OFFERED.LIBRARY_SUBJECT_OFFERED_KEY = LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_SUBJECT_OFFERED_KEY JOIN LIBRARY_RESERVE_CATALOG ON LIBRARY_RESERVE_CATALOG.LIBRARY_RESERVE_CATALOG_KEY = LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_RESERVE_CATALOG_KEY;",
    "gold_tables": [
      "dw#sep#LIBRARY_COURSE_INSTRUCTOR",
      "dw#sep#LIBRARY_RESERVE_MATRL_DETAIL",
      "dw#sep#LIBRARY_SUBJECT_OFFERED",
      "dw#sep#LIBRARY_RESERVE_CATALOG"
    ],
    "mapping": {
      "course instructor names": [
        "LIBRARY_COURSE_INSTRUCTOR.INSTRUCTOR_NAME"
      ],
      "course titles": [
        "LIBRARY_SUBJECT_OFFERED.SUBJECT_TITLE"
      ],
      "amount of material": [
        "LIBRARY_RESERVE_CATALOG.CATALOG_ISBN"
      ],
      "course instructor key": [
        "LIBRARY_COURSE_INSTRUCTOR.LIBRARY_COURSE_INSTRUCTOR_KEY"
      ],
      "key of subject offered": [
        "LIBRARY_SUBJECT_OFFERED.LIBRARY_SUBJECT_OFFERED_KEY"
      ]
    },
    "join_keys": [
      [
        "LIBRARY_COURSE_INSTRUCTOR.LIBRARY_COURSE_INSTRUCTOR_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_COURSE_INSTRUCTOR_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_SUBJECT_OFFERED_KEY",
        "LIBRARY_SUBJECT_OFFERED.LIBRARY_SUBJECT_OFFERED_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_RESERVE_CATALOG_KEY",
        "LIBRARY_RESERVE_CATALOG.LIBRARY_RESERVE_CATALOG_KEY"
      ]
    ]
  },
  {
    "question": "What is the room, floor, building key, building street address, city, state, and postal code of Professor Summer Haynes's office?",
    "db_id": "dw",
    "sql": "SELECT DISTINCT fac_rooms.Room, fac_rooms.floor, fac_building_address.BUILDING_KEY, BUILDINGS.BUILDING_STREET_ADDRESS, fac_building_address.CITY, fac_building_address.STATE, fac_building_address.POSTAL_CODE FROM (SELECT office_location FROM employee_directory WHERE full_name = 'Haynes, Summer') AS emp_office JOIN fac_rooms ON emp_office.office_location = fac_rooms.fac_room_key JOIN fac_building_address ON fac_rooms.building_key = fac_building_address.BUILDING_KEY JOIN BUILDINGS ON BUILDINGS.BUILDING_KEY = fac_building_address.BUILDING_KEY WHERE fac_building_address.ADDRESS_PURPOSE = 'STREET';",
    "oracle_sql": "SELECT fac_rooms.Room, fac_rooms.floor, fac_building_address.BUILDING_KEY, BUILDINGS.BUILDING_STREET_ADDRESS, fac_building_address.CITY, fac_building_address.STATE, fac_building_address.POSTAL_CODE FROM (SELECT office_location FROM employee_directory WHERE full_name = 'Haynes, Summer') JOIN fac_rooms on office_location = fac_room_key JOIN fac_building_address on fac_rooms.building_key = fac_building_address.BUILDING_KEY JOIN BUILDINGS ON BUILDINGS.BUILDING_KEY = fac_building_address.BUILDING_KEY where fac_building_address.ADDRESS_PURPOSE = 'STREET';",
    "gold_tables": [
      "dw#sep#EMPLOYEE_DIRECTORY",
      "dw#sep#FAC_ROOMS",
      "dw#sep#FAC_BUILDING_ADDRESS",
      "dw#sep#BUILDINGS"
    ],
    "mapping": {
      "room": [
        "FAC_ROOMS.ROOM"
      ],
      "floor": [
        "FAC_ROOMS.FLOOR"
      ],
      "building key": [
        "FAC_BUILDING_ADDRESS.BUILDING_KEY"
      ],
      "building street address": [
        "BUILDINGS.BUILDING_STREET_ADDRESS",
        "FAC_BUILDING_ADDRESS.ADDRESS_PURPOSE"
      ],
      "city": [
        "FAC_BUILDING_ADDRESS.CITY"
      ],
      "state": [
        "FAC_BUILDING_ADDRESS.STATE"
      ],
      "postal code": [
        "FAC_BUILDING_ADDRESS.POSTAL_CODE"
      ],
      "Professor Summer Haynes": [
        "EMPLOYEE_DIRECTORY.FULL_NAME"
      ],
      "office": [
        "EMPLOYEE_DIRECTORY.OFFICE_LOCATION"
      ]
    },
    "join_keys": [
      [
        "EMPLOYEE_DIRECTORY.OFFICE_LOCATION",
        "FAC_ROOMS.FAC_ROOM_KEY"
      ],
      [
        "FAC_BUILDING_ADDRESS.BUILDING_KEY",
        "FAC_ROOMS.BUILDING_KEY"
      ],
      [
        "BUILDINGS.BUILDING_KEY",
        "FAC_BUILDING_ADDRESS.BUILDING_KEY"
      ]
    ]
  },
  {
    "question": "List the unique full room names, their corresponding building names, street addresses, cities, states, postal codes, and building heights for rooms associated with subjects that Computer Science students can enroll in.",
    "db_id": "dw",
    "sql": "SELECT DISTINCT fr.ROOM_FULL_NAME, b.BUILDING_NAME, b.BUILDING_STREET_ADDRESS, fba.CITY, fba.STATE, fba.POSTAL_CODE, fb.BUILDING_HEIGHT FROM COURSE_CATALOG_SUBJECT_OFFERED JOIN FCLT_ROOMS fr ON MEET_PLACE = FCLT_ROOM_KEY JOIN FCLT_BUILDING_ADDRESS fba ON fba.FCLT_BUILDING_KEY = fr.FCLT_BUILDING_KEY JOIN FCLT_BUILDING fb ON fb.FCLT_BUILDING_KEY = fr.FCLT_BUILDING_KEY JOIN BUILDINGS b ON b.BUILDING_KEY = fr.FCLT_BUILDING_KEY WHERE DEPARTMENT_NAME = 'Electrical Eng & Computer Sci' AND fba.ADDRESS_PURPOSE = 'STREET';",
    "oracle_sql": "SELECT DISTINCT fr.ROOM_FULL_NAME, b.BUILDING_NAME, b.BUILDING_STREET_ADDRESS, fba.CITY, fba.STATE, fba.POSTAL_CODE, fb.BUILDING_HEIGHT FROM COURSE_CATALOG_SUBJECT_OFFERED JOIN FCLT_ROOMS fr ON MEET_PLACE = FCLT_ROOM_KEY JOIN FCLT_BUILDING_ADDRESS fba ON fba.FCLT_BUILDING_KEY = fr.FCLT_BUILDING_KEY JOIN FCLT_BUILDING fb ON fb.FCLT_BUILDING_KEY = fr.FCLT_BUILDING_KEY JOIN BUILDINGS b ON b.BUILDING_KEY = fr.FCLT_BUILDING_KEY WHERE DEPARTMENT_NAME = 'Electrical Eng & Computer Sci' AND fba.ADDRESS_PURPOSE = 'STREET';",
    "gold_tables": [
      "dw#sep#COURSE_CATALOG_SUBJECT_OFFERED",
      "dw#sep#FCLT_ROOMS",
      "dw#sep#FCLT_BUILDING_ADDRESS",
      "dw#sep#FCLT_BUILDING",
      "dw#sep#BUILDINGS"
    ],
    "mapping": {
      "full room names": [
        "FCLT_ROOMS.ROOM_FULL_NAME"
      ],
      "building names": [
        "BUILDINGS.BUILDING_NAME"
      ],
      "street addresses": [
        "BUILDINGS.BUILDING_STREET_ADDRESS",
        "FCLT_BUILDING_ADDRESS.ADDRESS_PURPOSE"
      ],
      "cities": [
        "FCLT_BUILDING_ADDRESS.CITY"
      ],
      "states": [
        "FCLT_BUILDING_ADDRESS.STATE"
      ],
      "postal codes": [
        "FCLT_BUILDING_ADDRESS.POSTAL_CODE"
      ],
      "building heights": [
        "FCLT_BUILDING.BUILDING_HEIGHT"
      ],
      "Computer Science": [
        "COURSE_CATALOG_SUBJECT_OFFERED.DEPARTMENT_NAME"
      ]
    },
    "join_keys": [
      [
        "COURSE_CATALOG_SUBJECT_OFFERED.MEET_PLACE",
        "FCLT_ROOMS.FCLT_ROOM_KEY"
      ],
      [
        "FCLT_BUILDING_ADDRESS.FCLT_BUILDING_KEY",
        "FCLT_ROOMS.FCLT_BUILDING_KEY"
      ],
      [
        "FCLT_BUILDING.FCLT_BUILDING_KEY",
        "FCLT_ROOMS.FCLT_BUILDING_KEY"
      ],
      [
        "BUILDINGS.BUILDING_KEY",
        "FCLT_ROOMS.FCLT_BUILDING_KEY"
      ]
    ]
  },
  {
    "question": "List the unique term code, subject title, room, floor, building key, building street address, city, state, and postal code, formats, and number of enrolled students for all courses with more than 300 attendees.",
    "db_id": "dw",
    "sql": "SELECT DISTINCT s.TERM_CODE, s.subject_title, fr.room, fr.floor, b.BUILDING_KEY, b.BUILDING_STREET_ADDRESS, fba.CITY, fba.STATE, fba.POSTAL_CODE, s.form_type, s.num_enrolled_students FROM subject_offered s JOIN FCLT_ROOMS fr ON MEET_PLACE = FCLT_ROOM_KEY JOIN FCLT_BUILDING_ADDRESS fba ON fba.FCLT_BUILDING_KEY = fr.FCLT_BUILDING_KEY JOIN BUILDINGS b ON fr.FCLT_BUILDING_KEY = b.BUILDING_KEY WHERE s.num_enrolled_students > 300 AND fba.ADDRESS_PURPOSE = 'STREET';",
    "oracle_sql": "SELECT DISTINCT s.TERM_CODE, s.subject_title, fr.room, fr.floor, b.BUILDING_KEY, b.BUILDING_STREET_ADDRESS, fba.CITY, fba.STATE, fba.POSTAL_CODE, s.form_type, s.num_enrolled_students FROM subject_offered s JOIN FCLT_ROOMS fr ON MEET_PLACE = FCLT_ROOM_KEY JOIN FCLT_BUILDING_ADDRESS fba ON fba.FCLT_BUILDING_KEY = fr.FCLT_BUILDING_KEY JOIN BUILDINGS b ON fr.FCLT_BUILDING_KEY = b.BUILDING_KEY WHERE s.num_enrolled_students > 300 AND fba.ADDRESS_PURPOSE = 'STREET';",
    "gold_tables": [
      "dw#sep#SUBJECT_OFFERED",
      "dw#sep#FCLT_ROOMS",
      "dw#sep#FCLT_BUILDING_ADDRESS",
      "dw#sep#BUILDINGS"
    ],
    "mapping": {
      "term code": [
        "SUBJECT_OFFERED.TERM_CODE"
      ],
      "subject title": [
        "SUBJECT_OFFERED.SUBJECT_TITLE"
      ],
      "room": [
        "FCLT_ROOMS.ROOM"
      ],
      "floor": [
        "FCLT_ROOMS.FLOOR"
      ],
      "building key": [
        "BUILDINGS.BUILDING_KEY"
      ],
      "building street address": [
        "BUILDINGS.BUILDING_STREET_ADDRESS",
        "FCLT_BUILDING_ADDRESS.ADDRESS_PURPOSE"
      ],
      "city": [
        "FCLT_BUILDING_ADDRESS.CITY"
      ],
      "state": [
        "FCLT_BUILDING_ADDRESS.STATE"
      ],
      "postal code": [
        "FCLT_BUILDING_ADDRESS.POSTAL_CODE"
      ],
      "formats": [
        "SUBJECT_OFFERED.FORM_TYPE"
      ],
      "number of enrolled students": [
        "SUBJECT_OFFERED.NUM_ENROLLED_STUDENTS"
      ],
      "attendees": [
        "SUBJECT_OFFERED.NUM_ENROLLED_STUDENTS"
      ]
    },
    "join_keys": [
      [
        "FCLT_ROOMS.FCLT_ROOM_KEY",
        "SUBJECT_OFFERED.MEET_PLACE"
      ],
      [
        "FCLT_BUILDING_ADDRESS.FCLT_BUILDING_KEY",
        "FCLT_ROOMS.FCLT_BUILDING_KEY"
      ],
      [
        "FCLT_ROOMS.FCLT_BUILDING_KEY",
        "BUILDINGS.BUILDING_KEY"
      ]
    ]
  },
  {
    "question": "What are the subject titles, their material titles, ISBN numbers, new shelf prices, and total costs of new materials for each subject title, sorted by individual item prices in ascending order?",
    "db_id": "dw",
    "sql": "SELECT DISTINCT tso.SUBJECT_TITLE, tm.title, tm.isbn, tm.new_shelf_price, SUM(tm.new_shelf_price) OVER(PARTITION BY tso.SUBJECT_TITLE) FROM tip_material tm JOIN TIP_DETAIL td ON tm.TIP_MATERIAL_KEY = td.TIP_MATERIAL_KEY JOIN TIP_SUBJECT_OFFERED tso ON tso.SUBJECT_ID = td.SUBJECT_ID ORDER BY tm.new_shelf_price ASC;",
    "oracle_sql": "SELECT DISTINCT tso.SUBJECT_TITLE, tm.title, tm.isbn, tm.new_shelf_price, SUM(tm.new_shelf_price) OVER(PARTITION BY tso.SUBJECT_TITLE) FROM tip_material tm JOIN TIP_DETAIL td ON tm.TIP_MATERIAL_KEY = td.TIP_MATERIAL_KEY JOIN TIP_SUBJECT_OFFERED tso ON tso.SUBJECT_ID = td.SUBJECT_ID ORDER BY tm.new_shelf_price ASC;",
    "gold_tables": [
      "dw#sep#TIP_MATERIAL",
      "dw#sep#TIP_DETAIL",
      "dw#sep#TIP_SUBJECT_OFFERED"
    ],
    "mapping": {
      "subject titles": [
        "TIP_SUBJECT_OFFERED.SUBJECT_TITLE"
      ],
      "material titles": [
        "TIP_MATERIAL.TITLE"
      ],
      "ISBN numbers": [
        "TIP_MATERIAL.ISBN"
      ],
      "new shelf prices": [
        "TIP_MATERIAL.NEW_SHELF_PRICE"
      ],
      "cost of new materials": [
        "TIP_MATERIAL.NEW_SHELF_PRICE"
      ]
    },
    "join_keys": [
      [
        "TIP_MATERIAL.TIP_MATERIAL_KEY",
        "TIP_DETAIL.TIP_MATERIAL_KEY"
      ],
      [
        "TIP_SUBJECT_OFFERED.SUBJECT_ID",
        "TIP_DETAIL.SUBJECT_ID"
      ]
    ]
  },
  {
    "question": "List the long names of buildings constructed before 1950 that have more than 100 employees, the built year of the building, and number of employees.",
    "db_id": "dw",
    "sql": "SELECT * FROM (SELECT DISTINCT a.BUILDING_NAME_LONG, a.year_built, COUNT(employee_directory.MIT_ID) OVER (PARTITION BY a.BUILDING_NAME_LONG, a.year_built) AS num_employees FROM (SELECT * FROM (SELECT DISTINCT FCLT_BUILDING_KEY, BUILDING_NAME_LONG, EXTRACT(YEAR FROM STR_TO_DATE(date_built, '%m/%d/%Y')) AS year_built FROM fclt_building_hist) AS sub1 WHERE year_built < 1950) AS a JOIN fclt_rooms ON fclt_rooms.FCLT_BUILDING_KEY = a.FCLT_BUILDING_KEY JOIN (SELECT DISTINCT MIT_ID, OFFICE_LOCATION FROM employee_directory) AS employee_directory ON employee_directory.OFFICE_LOCATION = fclt_rooms.BUILDING_ROOM) AS sub2 WHERE num_employees > 100;",
    "oracle_sql": "SELECT * FROM (SELECT DISTINCT a.BUILDING_NAME_LONG, a.year_built, COUNT(distinct employee_directory.MIT_ID) OVER (PARTITION BY a.BUILDING_NAME_LONG, a.year_built) as num_employees FROM (SELECT * FROM (SELECT DISTINCT FCLT_BUILDING_KEY, BUILDING_NAME_LONG, extract(year FROM TO_DATE(date_built, 'MM/DD/YYYY')) as year_built FROM fclt_building_hist) WHERE year_built < 1950) a JOIN fclt_rooms ON fclt_rooms.FCLT_BUILDING_KEY = a.FCLT_BUILDING_KEY JOIN employee_directory ON employee_directory.OFFICE_LOCATION = fclt_rooms.BUILDING_ROOM ) WHERE num_employees > 100;",
    "gold_tables": [
      "dw#sep#FCLT_BUILDING_HIST",
      "dw#sep#FCLT_ROOMS",
      "dw#sep#EMPLOYEE_DIRECTORY"
    ],
    "mapping": {
      "long names of buildings": [
        "FCLT_BUILDING_HIST.BUILDING_NAME_LONG"
      ],
      "built year": [
        "FCLT_BUILDING_HIST.DATE_BUILT"
      ],
      "employees": [
        "EMPLOYEE_DIRECTORY.MIT_ID"
      ]
    },
    "join_keys": [
      [
        "EMPLOYEE_DIRECTORY.OFFICE_LOCATION",
        "FCLT_ROOMS.BUILDING_ROOM"
      ]
    ]
  },
  {
    "question": "For each building key, what is the building name and the number of courses offered by the Center for International Studies?",
    "db_id": "dw",
    "sql": "SELECT fb.BUILDING_NAME, COUNT(DISTINCT ccc.subject_id) FROM cis_course_catalog ccc JOIN COURSE_CATALOG_SUBJECT_OFFERED ccso ON ccc.SUBJECT_ID = ccso.SUBJECT_ID JOIN FCLT_ROOMS fr ON ccso.MEET_PLACE = fr.FCLT_ROOM_KEY JOIN FCLT_BUILDING fb ON fb.FCLT_BUILDING_KEY = fr.FCLT_BUILDING_KEY GROUP BY fb.FCLT_BUILDING_KEY, fb.BUILDING_NAME;",
    "oracle_sql": "SELECT fb.BUILDING_NAME, COUNT(DISTINCT ccc.subject_id) FROM cis_course_catalog ccc JOIN COURSE_CATALOG_SUBJECT_OFFERED ccso ON ccc.SUBJECT_ID = ccso.SUBJECT_ID JOIN FCLT_ROOMS fr ON ccso.MEET_PLACE = fr.FCLT_ROOM_KEY JOIN FCLT_BUILDING fb ON fb.FCLT_BUILDING_KEY = fr.FCLT_BUILDING_KEY GROUP BY fb.FCLT_BUILDING_KEY, fb.BUILDING_NAME;",
    "gold_tables": [
      "dw#sep#CIS_COURSE_CATALOG",
      "dw#sep#COURSE_CATALOG_SUBJECT_OFFERED",
      "dw#sep#FCLT_ROOMS",
      "dw#sep#FCLT_BUILDING"
    ],
    "mapping": {
      "building key": [
        "FCLT_BUILDING.FCLT_BUILDING_KEY"
      ],
      "building name": [
        "FCLT_BUILDING.BUILDING_NAME"
      ],
      "courses offered by the Center for International Studies": [
        "CIS_COURSE_CATALOG.SUBJECT_ID"
      ]
    },
    "join_keys": [
      [
        "CIS_COURSE_CATALOG.SUBJECT_ID",
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID"
      ],
      [
        "COURSE_CATALOG_SUBJECT_OFFERED.MEET_PLACE",
        "FCLT_ROOMS.FCLT_ROOM_KEY"
      ],
      [
        "FCLT_ROOMS.FCLT_BUILDING_KEY",
        "FCLT_BUILDING.FCLT_BUILDING_KEY"
      ]
    ]
  },
  {
    "question": "What is the name of the building that accomodates the most students, and how many students does it accomodate?",
    "db_id": "dw",
    "sql": "SELECT DISTINCT building_name, num_students FROM (SELECT fclt_building_key, COUNT(DISTINCT full_name) AS num_students FROM fclt_rooms JOIN mit_student_directory ON office_location = BUILDING_ROOM GROUP BY fclt_building_key) AS a JOIN fclt_building ON a.fclt_building_key = fclt_building.fclt_building_key JOIN (SELECT MAX(num_students) AS max_num_students FROM (SELECT fclt_building_key, COUNT(DISTINCT full_name) AS num_students FROM fclt_rooms JOIN mit_student_directory ON office_location = BUILDING_ROOM GROUP BY fclt_building_key) AS subquery1) AS b ON a.num_students = b.max_num_students;",
    "oracle_sql": "SELECT DISTINCT building_name, num_students FROM (SELECT fclt_building_key, COUNT(distinct full_name) as num_students FROM fclt_rooms JOIN mit_student_directory ON office_location=BUILDING_ROOM GROUP BY fclt_building_key) a JOIN fclt_building ON a.fclt_building_key = fclt_building.fclt_building_key JOIN (SELECT MAX(num_students) as max_num_students FROM (SELECT fclt_building_key, COUNT(distinct full_name) as num_students FROM fclt_rooms JOIN mit_student_directory ON office_location=BUILDING_ROOM GROUP BY fclt_building_key)) b ON a.num_students = b.max_num_students;",
    "gold_tables": [
      "dw#sep#FCLT_ROOMS",
      "dw#sep#MIT_STUDENT_DIRECTORY",
      "dw#sep#FCLT_BUILDING"
    ],
    "mapping": {
      "name of the building": [
        "FCLT_BUILDING.BUILDING_NAME"
      ],
      "students": [
        "MIT_STUDENT_DIRECTORY.FULL_NAME"
      ]
    },
    "join_keys": [
      [
        "FCLT_ROOMS.BUILDING_ROOM",
        "MIT_STUDENT_DIRECTORY.OFFICE_LOCATION"
      ],
      [
        "FCLT_ROOMS.BUILDING_ROOM",
        "MIT_STUDENT_DIRECTORY.OFFICE_LOCATION"
      ]
    ]
  },
  {
    "question": "List the name and floor of the building with the largest floor number.",
    "db_id": "dw",
    "sql": "SELECT DISTINCT B.BUILDING_NAME, A.FLOOR FROM FAC_FLOOR A JOIN FAC_BUILDING B ON A.BUILDING_KEY = B.FAC_BUILDING_KEY JOIN (SELECT MAX(f) AS highest_floor FROM (SELECT CASE WHEN FLOOR REGEXP '^[0-9]+$' THEN CAST(FLOOR AS UNSIGNED) ELSE NULL END AS f FROM FAC_FLOOR) AS subquery1) AS subquery2 ON (CASE WHEN A.FLOOR REGEXP '^[0-9]+$' THEN CAST(A.FLOOR AS UNSIGNED) ELSE NULL END) = subquery2.highest_floor;",
    "oracle_sql": "SELECT DISTINCT B.BUILDING_NAME, A.FLOOR FROM FAC_FLOOR A JOIN FAC_BUILDING B ON A.BUILDING_KEY = B.FAC_BUILDING_KEY JOIN (SELECT max(f) as highest_floor FROM (SELECT CASE WHEN REGEXP_LIKE(FLOOR, '^\\d+$') THEN TO_NUMBER(FLOOR) ELSE NULL END AS f FROM fac_floor)) ON (CASE WHEN REGEXP_LIKE(A.FLOOR, '^\\d+$') THEN TO_NUMBER(FLOOR) ELSE NULL END) = highest_floor;",
    "gold_tables": [
      "dw#sep#FAC_FLOOR",
      "dw#sep#FAC_BUILDING"
    ],
    "mapping": {
      "name": [
        "FAC_BUILDING.BUILDING_NAME"
      ],
      "floor": [
        "FAC_FLOOR.FLOOR"
      ]
    },
    "join_keys": [
      [
        "FAC_BUILDING.FAC_BUILDING_KEY",
        "FAC_FLOOR.BUILDING_KEY"
      ]
    ]
  },
  {
    "question": "For each IAP category and academic year, list the category name, academic year, total fee collected, total number of IAP subjects, and the minimum and maximum enrollment.",
    "db_id": "dw",
    "sql": "SELECT isc.IAP_CATEGORY_NAME, td.ACADEMIC_YEAR, SUM(isd.FEE) AS Total_Fee, COUNT(distinct isd.ACTIVITY_TITLE) AS Total_Subjects, MIN(isd.MAX_ENROLLMENT) AS Min_Attendance, MAX(isd.MAX_ENROLLMENT) AS Max_Attendance FROM IAP_SUBJECT_DETAIL isd JOIN IAP_SUBJECT_CATEGORY isc ON isd.IAP_SUBJECT_CATEGORY_KEY = isc.IAP_SUBJECT_CATEGORY_KEY JOIN TIME_DAY td ON isd.TERM_CODE = td.ACADEMIC_TERM_CODE GROUP BY isc.IAP_CATEGORY_NAME, td.ACADEMIC_YEAR;",
    "oracle_sql": "SELECT isc.IAP_CATEGORY_NAME, td.ACADEMIC_YEAR, SUM(isd.FEE) AS Total_Fee, COUNT(distinct isd.ACTIVITY_TITLE) AS Total_Subjects, MIN(isd.MAX_ENROLLMENT) AS Min_Attendance, MAX(isd.MAX_ENROLLMENT) AS Max_Attendance FROM IAP_SUBJECT_DETAIL isd JOIN IAP_SUBJECT_CATEGORY isc ON isd.IAP_SUBJECT_CATEGORY_KEY = isc.IAP_SUBJECT_CATEGORY_KEY JOIN TIME_DAY td ON isd.TERM_CODE = td.ACADEMIC_TERM_CODE GROUP BY isc.IAP_CATEGORY_NAME, td.ACADEMIC_YEAR;",
    "gold_tables": [
      "dw#sep#IAP_SUBJECT_DETAIL",
      "dw#sep#IAP_SUBJECT_CATEGORY",
      "dw#sep#TIME_DAY"
    ],
    "mapping": {
      "category name": [
        "IAP_SUBJECT_CATEGORY.IAP_CATEGORY_NAME"
      ],
      "academic year": [
        "TIME_DAY.ACADEMIC_YEAR"
      ],
      "fee collected": [
        "IAP_SUBJECT_DETAIL.FEE"
      ],
      "IAP subjects": [
        "IAP_SUBJECT_DETAIL.ACTIVITY_TITLE"
      ],
      "enrollment": [
        "IAP_SUBJECT_DETAIL.MAX_ENROLLMENT"
      ]
    },
    "join_keys": [
      [
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_CATEGORY_KEY",
        "IAP_SUBJECT_CATEGORY.IAP_SUBJECT_CATEGORY_KEY"
      ],
      [
        "TIME_DAY.ACADEMIC_TERM_CODE",
        "IAP_SUBJECT_DETAIL.TERM_CODE"
      ]
    ]
  },
  {
    "question": "For each sponsor of the independent activity periods, list the sponsor name, number of sessions held, the total number of enrollment, the minimum and maximum fee, the number of sessions with info, and the number of sessions without info.",
    "db_id": "dw",
    "sql": "SELECT issr.SPONSOR_NAME, COUNT(DISTINCT iss.IAP_SUBJECT_SESSION_KEY) AS Total_Sessions, SUM(isd.MAX_ENROLLMENT), MIN(isd.FEE) AS Min_Fee, MAX(isd.FEE) AS Max_Fee, SUM(CASE WHEN iss.HAS_SESSION_INFO = 'Y' THEN 1 ELSE 0 END) AS Num_Sessions_With_Info, SUM(CASE WHEN iss.HAS_SESSION_INFO = 'N' THEN 1 ELSE 0 END) AS Num_Sessions_Without_Info FROM IAP_SUBJECT_SESSION iss JOIN IAP_SUBJECT_DETAIL isd ON iss.IAP_SUBJECT_SESSION_KEY = isd.IAP_SUBJECT_SESSION_KEY JOIN IAP_SUBJECT_SPONSOR issr ON isd.IAP_SUBJECT_SPONSOR_KEY = issr.IAP_SUBJECT_SPONSOR_KEY GROUP BY issr.SPONSOR_NAME;",
    "oracle_sql": "SELECT issr.SPONSOR_NAME, COUNT(DISTINCT iss.IAP_SUBJECT_SESSION_KEY) AS Total_Sessions, SUM(isd.MAX_ENROLLMENT), MIN(isd.FEE) AS Min_Fee, MAX(isd.FEE) AS Max_Fee, SUM(CASE WHEN iss.HAS_SESSION_INFO = 'Y' THEN 1 ELSE 0 END) AS Num_Sessions_With_Info, SUM(CASE WHEN iss.HAS_SESSION_INFO = 'N' THEN 1 ELSE 0 END) AS Num_Sessions_Without_Info FROM IAP_SUBJECT_SESSION iss JOIN IAP_SUBJECT_DETAIL isd ON iss.IAP_SUBJECT_SESSION_KEY = isd.IAP_SUBJECT_SESSION_KEY JOIN IAP_SUBJECT_SPONSOR issr ON isd.IAP_SUBJECT_SPONSOR_KEY = issr.IAP_SUBJECT_SPONSOR_KEY GROUP BY issr.SPONSOR_NAME;",
    "gold_tables": [
      "dw#sep#IAP_SUBJECT_SESSION",
      "dw#sep#IAP_SUBJECT_DETAIL",
      "dw#sep#IAP_SUBJECT_SPONSOR"
    ],
    "mapping": {
      "sponsor name": [
        "IAP_SUBJECT_SPONSOR.SPONSOR_NAME"
      ],
      "sessions": [
        "IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY"
      ],
      "enrollment": [
        "IAP_SUBJECT_DETAIL.MAX_ENROLLMENT"
      ],
      "fee": [
        "IAP_SUBJECT_DETAIL.FEE"
      ],
      "info": [
        "IAP_SUBJECT_SESSION.HAS_SESSION_INFO"
      ]
    },
    "join_keys": [
      [
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_SESSION_KEY",
        "IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY"
      ],
      [
        "IAP_SUBJECT_SPONSOR.IAP_SUBJECT_SPONSOR_KEY",
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_SPONSOR_KEY"
      ]
    ]
  },
  {
    "question": "What are the individual's email and name, academic year, total number of IAP subjects, the minimum and maximum fees, and the total course enrollment for each individual and academic year?",
    "db_id": "dw",
    "sql": "SELECT isp.PERSON_EMAIL, isp.PERSON_NAME, td.ACADEMIC_YEAR, COUNT(distinct isd.ACTIVITY_TITLE) AS Total_Subjects, MIN(isd.FEE) AS Min_Fee, MAX(isd.FEE) AS Max_Fee, SUM(isd.MAX_ENROLLMENT) FROM IAP_SUBJECT_PERSON isp JOIN IAP_SUBJECT_DETAIL isd ON isp.IAP_SUBJECT_PERSON_KEY = isd.IAP_SUBJECT_PERSON_KEY JOIN TIME_DAY td ON isd.TERM_CODE = td.ACADEMIC_TERM_CODE GROUP BY isp.PERSON_EMAIL, isp.PERSON_NAME, td.ACADEMIC_YEAR;",
    "oracle_sql": "SELECT isp.PERSON_EMAIL, isp.PERSON_NAME, td.ACADEMIC_YEAR, COUNT(distinct isd.ACTIVITY_TITLE) AS Total_Subjects, MIN(isd.FEE) AS Min_Fee, MAX(isd.FEE) AS Max_Fee, SUM(isd.MAX_ENROLLMENT) FROM IAP_SUBJECT_PERSON isp JOIN IAP_SUBJECT_DETAIL isd ON isp.IAP_SUBJECT_PERSON_KEY = isd.IAP_SUBJECT_PERSON_KEY JOIN TIME_DAY td ON isd.TERM_CODE = td.ACADEMIC_TERM_CODE GROUP BY isp.PERSON_EMAIL, isp.PERSON_NAME, td.ACADEMIC_YEAR;",
    "gold_tables": [
      "dw#sep#IAP_SUBJECT_PERSON",
      "dw#sep#IAP_SUBJECT_DETAIL",
      "dw#sep#TIME_DAY"
    ],
    "mapping": {
      "email": [
        "IAP_SUBJECT_PERSON.PERSON_EMAIL"
      ],
      "name": [
        "IAP_SUBJECT_PERSON.PERSON_NAME"
      ],
      "academic year": [
        "TIME_DAY.ACADEMIC_YEAR"
      ],
      "IAP subjects": [
        "IAP_SUBJECT_DETAIL.ACTIVITY_TITLE"
      ],
      "fees": [
        "IAP_SUBJECT_DETAIL.FEE"
      ],
      "course enrollment": [
        "IAP_SUBJECT_DETAIL.MAX_ENROLLMENT"
      ]
    },
    "join_keys": [
      [
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_PERSON_KEY",
        "IAP_SUBJECT_PERSON.IAP_SUBJECT_PERSON_KEY"
      ],
      [
        "TIME_DAY.ACADEMIC_TERM_CODE",
        "IAP_SUBJECT_DETAIL.TERM_CODE"
      ]
    ]
  },
  {
    "question": "What is the term code, term description, total number of IAP sessions, total fee collected, and minimum and maximum enrollment for each term code?",
    "db_id": "dw",
    "sql": "SELECT isd.TERM_CODE, ata.TERM_DESCRIPTION, COUNT(distinct iss.IAP_SUBJECT_SESSION_KEY) AS Total_Sessions, SUM(isd.FEE) AS Total_Fee, MIN(isd.MAX_ENROLLMENT) AS Min_Enrollment, MAX(isd.MAX_ENROLLMENT) AS Max_Enrollment FROM IAP_SUBJECT_SESSION iss JOIN IAP_SUBJECT_DETAIL isd ON iss.IAP_SUBJECT_SESSION_KEY = isd.IAP_SUBJECT_SESSION_KEY JOIN ACADEMIC_TERMS_ALL ata ON isd.TERM_CODE = ata.TERM_CODE GROUP BY isd.TERM_CODE, ata.TERM_DESCRIPTION;",
    "oracle_sql": "SELECT isd.TERM_CODE, ata.TERM_DESCRIPTION, COUNT(distinct iss.IAP_SUBJECT_SESSION_KEY) AS Total_Sessions, SUM(isd.FEE) AS Total_Fee, MIN(isd.MAX_ENROLLMENT) AS Min_Enrollment, MAX(isd.MAX_ENROLLMENT) AS Max_Enrollment FROM IAP_SUBJECT_SESSION iss JOIN IAP_SUBJECT_DETAIL isd ON iss.IAP_SUBJECT_SESSION_KEY = isd.IAP_SUBJECT_SESSION_KEY JOIN ACADEMIC_TERMS_ALL ata ON isd.TERM_CODE = ata.TERM_CODE GROUP BY isd.TERM_CODE, ata.TERM_DESCRIPTION;",
    "gold_tables": [
      "dw#sep#IAP_SUBJECT_SESSION",
      "dw#sep#IAP_SUBJECT_DETAIL",
      "dw#sep#ACADEMIC_TERMS_ALL"
    ],
    "mapping": {
      "term code": [
        "IAP_SUBJECT_DETAIL.TERM_CODE"
      ],
      "term description": [
        "ACADEMIC_TERMS_ALL.TERM_DESCRIPTION"
      ],
      "IAP sessions": [
        "IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY"
      ],
      "fee": [
        "IAP_SUBJECT_DETAIL.FEE"
      ],
      "enrollment": [
        "IAP_SUBJECT_DETAIL.MAX_ENROLLMENT"
      ]
    },
    "join_keys": [
      [
        "IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY",
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_SESSION_KEY"
      ],
      [
        "ACADEMIC_TERMS_ALL.TERM_CODE",
        "IAP_SUBJECT_DETAIL.TERM_CODE"
      ]
    ]
  },
  {
    "question": "What is the name of the building, total number of subjects, total fee, and shortest and longest sessions for each physical IAP session location?",
    "db_id": "dw",
    "sql": "SELECT b.BUILDING_NAME, COUNT(DISTINCT isd.ACTIVITY_TITLE) AS Total_Subjects, SUM(isd.FEE) AS Total_Fee, MIN(TIMESTAMPDIFF(MINUTE, STR_TO_DATE(iss.SESSION_START_TIME, '%h%i%p'), CASE WHEN STR_TO_DATE(iss.SESSION_START_TIME, '%h%i%p') > STR_TO_DATE(iss.SESSION_END_TIME, '%h%i%p') THEN STR_TO_DATE('1200PM', '%h%i%p') ELSE STR_TO_DATE(iss.SESSION_END_TIME, '%h%i%p') END)) AS Min_Sessions, MAX(TIMESTAMPDIFF(MINUTE, STR_TO_DATE(iss.SESSION_START_TIME, '%h%i%p'), CASE WHEN STR_TO_DATE(iss.SESSION_START_TIME, '%h%i%p') > STR_TO_DATE(iss.SESSION_END_TIME, '%h%i%p') THEN STR_TO_DATE('1200PM', '%h%i%p') ELSE STR_TO_DATE(iss.SESSION_END_TIME, '%h%i%p') END)) AS Max_Sessions FROM IAP_SUBJECT_SESSION iss JOIN IAP_SUBJECT_DETAIL isd ON iss.IAP_SUBJECT_SESSION_KEY = isd.IAP_SUBJECT_SESSION_KEY JOIN BUILDINGS b ON b.BUILDING_NUMBER = iss.SESSION_LOCATION GROUP BY b.BUILDING_NAME;",
    "oracle_sql": "SELECT b.BUILDING_NAME, COUNT(Distinct isd.ACTIVITY_TITLE) AS Total_Subjects, SUM(isd.FEE) AS Total_Fee, MIN((CASE WHEN TO_DATE(iss.SESSION_START_TIME, 'HH12:MIAM') > TO_DATE(iss.SESSION_END_TIME, 'HH12:MIAM') THEN TO_DATE('12:00PM', 'HH12:MIAM') ELSE TO_DATE(iss.SESSION_END_TIME, 'HH12:MIAM')END) - TO_DATE(iss.SESSION_START_TIME, 'HH12:MIAM') ) * 24 * 60 AS Min_Sessions, MAX((CASE WHEN TO_DATE(iss.SESSION_START_TIME, 'HH12:MIAM') > TO_DATE(iss.SESSION_END_TIME, 'HH12:MIAM') THEN TO_DATE('12:00PM', 'HH12:MIAM') ELSE TO_DATE(iss.SESSION_END_TIME, 'HH12:MIAM')END) - TO_DATE(iss.SESSION_START_TIME, 'HH12:MIAM') ) * 24 * 60 AS Max_Sessions FROM IAP_SUBJECT_SESSION iss JOIN IAP_SUBJECT_DETAIL isd ON iss.IAP_SUBJECT_SESSION_KEY = isd.IAP_SUBJECT_SESSION_KEY JOIN BUILDINGS b on b.BUILDING_NUMBER = iss.SESSION_LOCATION GROUP BY b.BUILDING_NAME;",
    "gold_tables": [
      "dw#sep#IAP_SUBJECT_SESSION",
      "dw#sep#IAP_SUBJECT_DETAIL",
      "dw#sep#BUILDINGS"
    ],
    "mapping": {
      "name of the building": [
        "BUILDINGS.BUILDING_NAME"
      ],
      "subjects": [
        "IAP_SUBJECT_DETAIL.ACTIVITY_TITLE"
      ],
      "fee": [
        "IAP_SUBJECT_DETAIL.FEE"
      ],
      "sessions": [
        "IAP_SUBJECT_SESSION.SESSION_END_TIME",
        "IAP_SUBJECT_SESSION.SESSION_START_TIME"
      ]
    },
    "join_keys": [
      [
        "IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY",
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_SESSION_KEY"
      ],
      [
        "IAP_SUBJECT_SESSION.SESSION_LOCATION",
        "BUILDINGS.BUILDING_NUMBER"
      ]
    ]
  },
  {
    "question": "What is total number of subjects, the total fee, and the shortest and longest sessions, for all virtual IAP sessions?",
    "db_id": "dw",
    "sql": "SELECT COUNT(DISTINCT isd.ACTIVITY_TITLE) AS Total_Subjects, SUM(isd.FEE) AS Total_Fee, MIN(TIMESTAMPDIFF(MINUTE, STR_TO_DATE(iss.SESSION_START_TIME, '%h%i%p'), CASE WHEN STR_TO_DATE(iss.SESSION_START_TIME, '%h%i%p') > STR_TO_DATE(iss.SESSION_END_TIME, '%h%i%p') THEN STR_TO_DATE('1200PM', '%h%i%p') ELSE STR_TO_DATE(iss.SESSION_END_TIME, '%h%i%p') END)) AS Min_Sessions, MAX(TIMESTAMPDIFF(MINUTE, STR_TO_DATE(iss.SESSION_START_TIME, '%h%i%p'), CASE WHEN STR_TO_DATE(iss.SESSION_START_TIME, '%h%i%p') > STR_TO_DATE(iss.SESSION_END_TIME, '%h%i%p') THEN STR_TO_DATE('1200PM', '%h%i%p') ELSE STR_TO_DATE(iss.SESSION_END_TIME, '%h%i%p') END)) AS Max_Sessions FROM IAP_SUBJECT_SESSION iss JOIN IAP_SUBJECT_DETAIL isd ON iss.IAP_SUBJECT_SESSION_KEY = isd.IAP_SUBJECT_SESSION_KEY JOIN BUILDINGS b ON b.BUILDING_NUMBER != iss.SESSION_LOCATION;",
    "oracle_sql": "SELECT COUNT(DISTINCT isd.ACTIVITY_TITLE) AS Total_Subjects, SUM(isd.FEE) AS Total_Fee, MIN((CASE WHEN TO_DATE(iss.SESSION_START_TIME, 'HH12:MIAM') > TO_DATE(iss.SESSION_END_TIME, 'HH12:MIAM') THEN TO_DATE('12:00PM', 'HH12:MIAM') ELSE TO_DATE(iss.SESSION_END_TIME, 'HH12:MIAM')END) - TO_DATE(iss.SESSION_START_TIME, 'HH12:MIAM') ) * 24 * 60 AS Min_Sessions, MAX((CASE WHEN TO_DATE(iss.SESSION_START_TIME, 'HH12:MIAM') > TO_DATE(iss.SESSION_END_TIME, 'HH12:MIAM') THEN TO_DATE('12:00PM', 'HH12:MIAM') ELSE TO_DATE(iss.SESSION_END_TIME, 'HH12:MIAM')END) - TO_DATE(iss.SESSION_START_TIME, 'HH12:MIAM') ) * 24 * 60 AS Max_Sessions FROM IAP_SUBJECT_SESSION iss JOIN IAP_SUBJECT_DETAIL isd ON iss.IAP_SUBJECT_SESSION_KEY = isd.IAP_SUBJECT_SESSION_KEY JOIN BUILDINGS b on b.BUILDING_NUMBER != iss.SESSION_LOCATION;",
    "gold_tables": [
      "dw#sep#IAP_SUBJECT_SESSION",
      "dw#sep#IAP_SUBJECT_DETAIL",
      "dw#sep#BUILDINGS"
    ],
    "mapping": {
      "subjects": [
        "IAP_SUBJECT_DETAIL.ACTIVITY_TITLE"
      ],
      "fee": [
        "IAP_SUBJECT_DETAIL.FEE"
      ],
      "sessions": [
        "IAP_SUBJECT_SESSION.SESSION_END_TIME",
        "IAP_SUBJECT_SESSION.SESSION_START_TIME"
      ]
    },
    "join_keys": [
      [
        "IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY",
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_SESSION_KEY"
      ],
      [
        "IAP_SUBJECT_SESSION.SESSION_LOCATION",
        "BUILDINGS.BUILDING_NUMBER"
      ]
    ]
  },
  {
    "question": "What is the school code, school name, full name of the department, course level, total number of courses, and total number of degree-granting courses for each school code, department, and course level?",
    "db_id": "dw",
    "sql": "SELECT ssc.SCHOOL_CODE, ssc.SCHOOL_NAME, sd.DEPARTMENT_FULL_NAME, scd.COURSE_LEVEL, COUNT(DISTINCT scd.COURSE) AS Total_Courses, SUM(CASE WHEN scd.IS_DEGREE_GRANTING = 'Y' THEN 1 ELSE 0 END) AS Total_Degree_Granting_Courses FROM SIS_COURSE_DESCRIPTION scd JOIN SIS_DEPARTMENT sd ON scd.DEPARTMENT = sd.DEPARTMENT_CODE JOIN SIS_SUBJECT_CODE ssc ON scd.COURSE = ssc.SUBJECT_CODE GROUP BY ssc.SCHOOL_CODE, ssc.SCHOOL_NAME, scd.DEPARTMENT, sd.DEPARTMENT_FULL_NAME, scd.COURSE_LEVEL;",
    "oracle_sql": "SELECT ssc.SCHOOL_CODE, ssc.SCHOOL_NAME, sd.DEPARTMENT_FULL_NAME, scd.COURSE_LEVEL, COUNT(DISTINCT scd.COURSE) AS Total_Courses, SUM(CASE WHEN scd.IS_DEGREE_GRANTING = 'Y' THEN 1 ELSE 0 END) AS Total_Degree_Granting_Courses FROM SIS_COURSE_DESCRIPTION scd JOIN SIS_DEPARTMENT sd ON scd.DEPARTMENT = sd.DEPARTMENT_CODE JOIN SIS_SUBJECT_CODE ssc ON scd.COURSE = ssc.SUBJECT_CODE GROUP BY ssc.SCHOOL_CODE, ssc.SCHOOL_NAME, scd.DEPARTMENT, sd.DEPARTMENT_FULL_NAME, scd.COURSE_LEVEL;",
    "gold_tables": [
      "dw#sep#SIS_COURSE_DESCRIPTION",
      "dw#sep#SIS_DEPARTMENT",
      "dw#sep#SIS_SUBJECT_CODE"
    ],
    "mapping": {
      "school code": [
        "SIS_SUBJECT_CODE.SCHOOL_CODE"
      ],
      "school name": [
        "SIS_SUBJECT_CODE.SCHOOL_NAME"
      ],
      "full name of the department": [
        "SIS_DEPARTMENT.DEPARTMENT_FULL_NAME"
      ],
      "course level": [
        "SIS_COURSE_DESCRIPTION.COURSE_LEVEL"
      ],
      "courses": [
        "SIS_COURSE_DESCRIPTION.COURSE"
      ],
      "degree-granting courses": [
        "SIS_COURSE_DESCRIPTION.IS_DEGREE_GRANTING"
      ]
    },
    "join_keys": [
      [
        "SIS_DEPARTMENT.DEPARTMENT_CODE",
        "SIS_COURSE_DESCRIPTION.DEPARTMENT"
      ],
      [
        "SIS_COURSE_DESCRIPTION.COURSE",
        "SIS_SUBJECT_CODE.SUBJECT_CODE"
      ]
    ]
  },
  {
    "question": "What are the different schools and departments that offer SIS courses? List their school code, school name, department code, department name, the total number of phone numbers, and the most common course level.",
    "db_id": "dw",
    "sql": "SELECT ssc.SCHOOL_CODE, ssc.SCHOOL_NAME, sd.DEPARTMENT_CODE, sad.SIS_ADMIN_DEPARTMENT_NAME, COUNT(DISTINCT sad.DEPARTMENT_PHONE_NUMBER) AS Total_Phone_Numbers, CASE WHEN SUM(CASE WHEN scd.COURSE_LEVEL = 'U' THEN 1 ELSE 0 END) >= SUM(CASE WHEN scd.COURSE_LEVEL = 'G' THEN 1 ELSE 0 END) THEN 'U' ELSE 'G' END AS Most_Common_Course_Level FROM SIS_ADMIN_DEPARTMENT sad JOIN SIS_DEPARTMENT sd ON sad.SIS_ADMIN_DEPARTMENT_CODE = sd.DEPARTMENT_CODE JOIN SIS_COURSE_DESCRIPTION scd ON sd.DEPARTMENT_CODE = scd.DEPARTMENT JOIN SIS_SUBJECT_CODE ssc ON scd.COURSE = ssc.SUBJECT_CODE GROUP BY ssc.SCHOOL_CODE, ssc.SCHOOL_NAME, sd.DEPARTMENT_CODE, sad.SIS_ADMIN_DEPARTMENT_NAME;",
    "oracle_sql": "SELECT ssc.SCHOOL_CODE, ssc.SCHOOL_NAME, sd.DEPARTMENT_CODE, sad.SIS_ADMIN_DEPARTMENT_NAME, COUNT(DISTINCT sad.DEPARTMENT_PHONE_NUMBER) AS Total_Phone_Numbers, CASE WHEN SUM(CASE WHEN scd.COURSE_LEVEL = 'U' THEN 1 ELSE 0 END) >= SUM(CASE WHEN scd.COURSE_LEVEL = 'G' THEN 1 ELSE 0 END) THEN 'U' ELSE 'G' END AS Most_Common_Course_Level FROM SIS_ADMIN_DEPARTMENT sad JOIN SIS_DEPARTMENT sd ON sad.SIS_ADMIN_DEPARTMENT_CODE = sd.DEPARTMENT_CODE JOIN SIS_COURSE_DESCRIPTION scd ON sd.DEPARTMENT_CODE = scd.DEPARTMENT JOIN SIS_SUBJECT_CODE ssc ON scd.COURSE = ssc.SUBJECT_CODE GROUP BY ssc.SCHOOL_CODE, ssc.SCHOOL_NAME, sd.DEPARTMENT_CODE, sad.SIS_ADMIN_DEPARTMENT_NAME;",
    "gold_tables": [
      "dw#sep#SIS_ADMIN_DEPARTMENT",
      "dw#sep#SIS_DEPARTMENT",
      "dw#sep#SIS_COURSE_DESCRIPTION",
      "dw#sep#SIS_SUBJECT_CODE"
    ],
    "mapping": {
      "school code": [
        "SIS_SUBJECT_CODE.SCHOOL_CODE"
      ],
      "school name": [
        "SIS_SUBJECT_CODE.SCHOOL_NAME"
      ],
      "department code": [
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ],
      "department name": [
        "SIS_ADMIN_DEPARTMENT.SIS_ADMIN_DEPARTMENT_NAME"
      ],
      "phone numbers": [
        "SIS_ADMIN_DEPARTMENT.DEPARTMENT_PHONE_NUMBER"
      ],
      "course level": [
        "SIS_COURSE_DESCRIPTION.COURSE_LEVEL"
      ]
    },
    "join_keys": [
      [
        "SIS_ADMIN_DEPARTMENT.SIS_ADMIN_DEPARTMENT_CODE",
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ],
      [
        "SIS_DEPARTMENT.DEPARTMENT_CODE",
        "SIS_COURSE_DESCRIPTION.DEPARTMENT"
      ],
      [
        "SIS_SUBJECT_CODE.SUBJECT_CODE",
        "SIS_COURSE_DESCRIPTION.COURSE"
      ]
    ]
  },
  {
    "question": "What is the school code, school name, DLC key, the graduate level, total number of SIS subjects, the minimum and maximum course numbers, and the total number of departments offering subjects for each school?",
    "db_id": "dw",
    "sql": "SELECT ssc.SCHOOL_CODE, ssc.SCHOOL_NAME, sd.DLC_KEY, GRADUATE_LEVEL, COUNT(DISTINCT ssc.SUBJECT_CODE) AS Total_Subjects, MIN(ssc.COURSE_NUMBER) AS Min_Course_Number, MAX(ssc.COURSE_NUMBER) AS Max_Course_Number, COUNT(DISTINCT sd.DEPARTMENT_CODE) AS Total_Departments FROM SIS_SUBJECT_CODE ssc JOIN SIS_COURSE_DESCRIPTION scd ON ssc.SUBJECT_CODE = scd.COURSE JOIN SIS_DEPARTMENT sd ON scd.DEPARTMENT = sd.DEPARTMENT_CODE GROUP BY ssc.SCHOOL_CODE, ssc.SCHOOL_NAME, sd.DLC_KEY,GRADUATE_LEVEL;",
    "oracle_sql": "SELECT ssc.SCHOOL_CODE, ssc.SCHOOL_NAME, sd.DLC_KEY, GRADUATE_LEVEL, COUNT(DISTINCT ssc.SUBJECT_CODE) AS Total_Subjects, MIN(ssc.COURSE_NUMBER) AS Min_Course_Number, MAX(ssc.COURSE_NUMBER) AS Max_Course_Number, COUNT(DISTINCT sd.DEPARTMENT_CODE) AS Total_Departments FROM SIS_SUBJECT_CODE ssc JOIN SIS_COURSE_DESCRIPTION scd ON ssc.SUBJECT_CODE = scd.COURSE JOIN SIS_DEPARTMENT sd ON scd.DEPARTMENT = sd.DEPARTMENT_CODE GROUP BY ssc.SCHOOL_CODE, ssc.SCHOOL_NAME, sd.DLC_KEY,GRADUATE_LEVEL;",
    "gold_tables": [
      "dw#sep#SIS_SUBJECT_CODE",
      "dw#sep#SIS_COURSE_DESCRIPTION",
      "dw#sep#SIS_DEPARTMENT"
    ],
    "mapping": {
      "school code": [
        "SIS_SUBJECT_CODE.SCHOOL_CODE"
      ],
      "school name": [
        "SIS_SUBJECT_CODE.SCHOOL_NAME"
      ],
      "DLC key": [
        "SIS_DEPARTMENT.DLC_KEY"
      ],
      "graduate level": [
        "SIS_COURSE_DESCRIPTION.GRADUATE_LEVEL"
      ],
      "SIS subjects": [
        "SIS_SUBJECT_CODE.SUBJECT_CODE"
      ],
      "course numbers": [
        "SIS_SUBJECT_CODE.COURSE_NUMBER"
      ],
      "departments": [
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ]
    },
    "join_keys": [
      [
        "SIS_SUBJECT_CODE.SUBJECT_CODE",
        "SIS_COURSE_DESCRIPTION.COURSE"
      ],
      [
        "SIS_COURSE_DESCRIPTION.DEPARTMENT",
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ]
    ]
  },
  {
    "question": "What is the building component, name of the building, square footage for all rooms, total number of floors, total number of rooms, total number of facility organizations, total number of supervisors, and total number of supervisees for each building component?",
    "db_id": "dw",
    "sql": "SELECT sd.BUILDING_COMPONENT, b.BUILDING_NAME, sd.Total_Square_Footage, COUNT(DISTINCT SF.FLOOR) AS Total_Number_Of_Floors, COUNT(DISTINCT sd.BUILDING_ROOM) AS Total_Rooms, COUNT(DISTINCT su.FCLT_ORGANIZATION_KEY) as Total_Number_FCLT, COUNT(DISTINCT ssu.MIT_ID) AS Total_Supervisors, SUM(ssu.NUM_OF_SUPERVISEES) AS Total_Supervisees FROM (SELECT SPACE_DETAIL.*, SUM(ROOM_SQUARE_FOOTAGE) OVER (PARTITION BY BUILDING_COMPONENT) AS Total_Square_Footage FROM SPACE_DETAIL) sd JOIN BUILDINGS b ON b.BUILDING_KEY = sd.BUILDING_KEY JOIN SPACE_FLOOR sf ON sd.FLOOR_KEY = sf.FLOOR_KEY JOIN SPACE_UNIT su ON sd.SPACE_UNIT_KEY = su.SPACE_UNIT_KEY JOIN SPACE_SUPERVISOR_USAGE ssu ON su.DLC_KEY = ssu.DEPT_NAMES GROUP BY sd.BUILDING_COMPONENT, b.BUILDING_NAME, sd.Total_Square_Footage;",
    "oracle_sql": "SELECT sd.BUILDING_COMPONENT, b.BUILDING_NAME, sd.Total_Square_Footage, COUNT(DISTINCT SF.FLOOR) AS Total_Number_Of_Floors, COUNT(DISTINCT sd.BUILDING_ROOM) AS Total_Rooms, COUNT(DISTINCT su.FCLT_ORGANIZATION_KEY) as Total_Number_FCLT, COUNT(DISTINCT ssu.MIT_ID) AS Total_Supervisors, SUM(ssu.NUM_OF_SUPERVISEES) AS Total_Supervisees FROM (SELECT SPACE_DETAIL.*, SUM(ROOM_SQUARE_FOOTAGE) OVER (PARTITION BY BUILDING_COMPONENT) AS Total_Square_Footage FROM SPACE_DETAIL) sd JOIN BUILDINGS b ON b.BUILDING_KEY = sd.BUILDING_KEY JOIN SPACE_FLOOR sf ON sd.FLOOR_KEY = sf.FLOOR_KEY JOIN SPACE_UNIT su ON sd.SPACE_UNIT_KEY = su.SPACE_UNIT_KEY JOIN SPACE_SUPERVISOR_USAGE ssu ON su.DLC_KEY = ssu.DEPT_NAMES GROUP BY sd.BUILDING_COMPONENT, b.BUILDING_NAME, sd.Total_Square_Footage;",
    "gold_tables": [
      "dw#sep#SPACE_DETAIL",
      "dw#sep#BUILDINGS",
      "dw#sep#SPACE_FLOOR",
      "dw#sep#SPACE_UNIT",
      "dw#sep#SPACE_SUPERVISOR_USAGE"
    ],
    "mapping": {
      "building component": [
        "SPACE_DETAIL.BUILDING_COMPONENT"
      ],
      "name of the building": [
        "BUILDINGS.BUILDING_NAME"
      ],
      "square footage": [
        "SPACE_DETAIL.ROOM_SQUARE_FOOTAGE"
      ],
      "rooms": [
        "SPACE_DETAIL.BUILDING_ROOM"
      ],
      "floors": [
        "SPACE_FLOOR.FLOOR"
      ],
      "facility organizations": [
        "SPACE_UNIT.FCLT_ORGANIZATION_KEY"
      ],
      "supervisors": [
        "SPACE_SUPERVISOR_USAGE.MIT_ID"
      ],
      "supervisees": [
        "SPACE_SUPERVISOR_USAGE.NUM_OF_SUPERVISEES"
      ]
    },
    "join_keys": [
      [
        "SPACE_SUPERVISOR_USAGE.DEPT_NAMES",
        "SPACE_UNIT.DLC_KEY"
      ]
    ]
  },
  {
    "question": "What is the DLC key, name of the DLC, total number of floors, total square footage, total number of facility organizations, total number of supervisors, total number of supervisees, and total building heights for each DLC?",
    "db_id": "dw",
    "sql": "SELECT su.DLC_KEY, fo.DLC_NAME, COUNT(DISTINCT sf.FLOOR) AS Total_Number_Of_Floors, sd.Total_Square_Footage, COUNT(DISTINCT su.FCLT_ORGANIZATION_KEY) AS Total_Number_Facility, COUNT(DISTINCT ssu.MIT_ID) AS Total_Supervisors, SUM(ssu.NUM_OF_SUPERVISEES) AS Total_Supervisees, SUM(fb.BUILDING_HEIGHT) AS Cumulative_Building_Height FROM (SELECT SPACE_DETAIL.*, SUM(ROOM_SQUARE_FOOTAGE) OVER (PARTITION BY BUILDING_COMPONENT) AS Total_Square_Footage FROM SPACE_DETAIL) sd JOIN FCLT_BUILDING fb ON fb.FCLT_BUILDING_KEY = sd.BUILDING_KEY JOIN SPACE_FLOOR sf ON sd.FLOOR_KEY = sf.FLOOR_KEY JOIN SPACE_UNIT su ON sd.SPACE_UNIT_KEY = su.SPACE_UNIT_KEY JOIN SPACE_SUPERVISOR_USAGE ssu ON su.DLC_KEY = ssu.DEPT_NAMES JOIN (SELECT DISTINCT DLC_KEY, DLC_NAME FROM FCLT_ORGANIZATION) fo ON fo.DLC_KEY = su.DLC_KEY GROUP BY su.DLC_KEY, fo.DLC_NAME, sd.Total_Square_Footage;",
    "oracle_sql": "SELECT su.DLC_KEY, fo.DLC_NAME, COUNT(DISTINCT sf.FLOOR) AS Total_Number_Of_Floors, sd.Total_Square_Footage, COUNT(DISTINCT su.FCLT_ORGANIZATION_KEY) AS Total_Number_Facility, COUNT(DISTINCT ssu.MIT_ID) AS Total_Supervisors, SUM(ssu.NUM_OF_SUPERVISEES) AS Total_Supervisees, SUM(fb.BUILDING_HEIGHT) AS Cumulative_Building_Height FROM (SELECT SPACE_DETAIL.*, SUM(ROOM_SQUARE_FOOTAGE) OVER (PARTITION BY BUILDING_COMPONENT) AS Total_Square_Footage FROM SPACE_DETAIL) sd JOIN FCLT_BUILDING fb ON fb.FCLT_BUILDING_KEY = sd.BUILDING_KEY JOIN SPACE_FLOOR sf ON sd.FLOOR_KEY = sf.FLOOR_KEY JOIN SPACE_UNIT su ON sd.SPACE_UNIT_KEY = su.SPACE_UNIT_KEY JOIN SPACE_SUPERVISOR_USAGE ssu ON su.DLC_KEY = ssu.DEPT_NAMES JOIN (SELECT DISTINCT DLC_KEY, DLC_NAME FROM FCLT_ORGANIZATION) fo ON fo.DLC_KEY = su.DLC_KEY GROUP BY su.DLC_KEY, fo.DLC_NAME, sd.Total_Square_Footage;",
    "gold_tables": [
      "dw#sep#SPACE_DETAIL",
      "dw#sep#FCLT_BUILDING",
      "dw#sep#SPACE_FLOOR",
      "dw#sep#SPACE_UNIT",
      "dw#sep#SPACE_SUPERVISOR_USAGE",
      "dw#sep#FCLT_ORGANIZATION"
    ],
    "mapping": {
      "DLC key": [
        "SPACE_UNIT.DLC_KEY"
      ],
      "name of the DLC": [
        "FCLT_ORGANIZATION.DLC_NAME"
      ],
      "floors": [
        "SPACE_FLOOR.FLOOR"
      ],
      "square footage": [
        "SPACE_DETAIL.ROOM_SQUARE_FOOTAGE"
      ],
      "facility organizations": [
        "SPACE_UNIT.FCLT_ORGANIZATION_KEY"
      ],
      "supervisors": [
        "SPACE_SUPERVISOR_USAGE.MIT_ID"
      ],
      "supervisees": [
        "SPACE_SUPERVISOR_USAGE.NUM_OF_SUPERVISEES"
      ],
      "building heights": [
        "FCLT_BUILDING.BUILDING_HEIGHT"
      ]
    },
    "join_keys": [
      [
        "SPACE_UNIT.DLC_KEY",
        "SPACE_SUPERVISOR_USAGE.DEPT_NAMES"
      ]
    ]
  },
  {
    "question": "What is the department name, total number of types of TIP subjects, total number of enrolled students, the minimum and maximum rental new price for each department?",
    "db_id": "dw",
    "sql": "SELECT tso.OFFER_DEPT_NAME, COUNT(distinct tso.SUBJECT_ID) AS Total_Subjects, SUM(tso.NUM_ENROLLED_STUDENTS) AS Total_Enrolled_Students, MIN(tm.RENTAL_NEW_PRICE) AS Min_Rental_New_Price, MAX(tm.RENTAL_NEW_PRICE) AS Max_Rental_New_Price FROM TIP_SUBJECT_OFFERED tso JOIN TIP_DETAIL td ON tso.TIP_SUBJECT_OFFERED_KEY = td.TIP_SUBJECT_OFFERED_KEY JOIN TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY GROUP BY tso.OFFER_DEPT_NAME;",
    "oracle_sql": "SELECT tso.OFFER_DEPT_NAME, COUNT(distinct tso.SUBJECT_ID) AS Total_Subjects, SUM(tso.NUM_ENROLLED_STUDENTS) AS Total_Enrolled_Students, MIN(tm.RENTAL_NEW_PRICE) AS Min_Rental_New_Price, MAX(tm.RENTAL_NEW_PRICE) AS Max_Rental_New_Price FROM TIP_SUBJECT_OFFERED tso JOIN TIP_DETAIL td ON tso.TIP_SUBJECT_OFFERED_KEY = td.TIP_SUBJECT_OFFERED_KEY JOIN TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY GROUP BY tso.OFFER_DEPT_NAME;",
    "gold_tables": [
      "dw#sep#TIP_SUBJECT_OFFERED",
      "dw#sep#TIP_DETAIL",
      "dw#sep#TIP_MATERIAL"
    ],
    "mapping": {
      "department name": [
        "TIP_SUBJECT_OFFERED.OFFER_DEPT_NAME"
      ],
      "TIP subjects": [
        "TIP_SUBJECT_OFFERED.SUBJECT_ID"
      ],
      "enrolled students": [
        "TIP_SUBJECT_OFFERED.NUM_ENROLLED_STUDENTS"
      ],
      "rental new price": [
        "TIP_MATERIAL.RENTAL_NEW_PRICE"
      ]
    },
    "join_keys": [
      [
        "TIP_SUBJECT_OFFERED.TIP_SUBJECT_OFFERED_KEY",
        "TIP_DETAIL.TIP_SUBJECT_OFFERED_KEY"
      ],
      [
        "TIP_MATERIAL.TIP_MATERIAL_KEY",
        "TIP_DETAIL.TIP_MATERIAL_KEY"
      ]
    ]
  },
  {
    "question": "What are the details of courses offered in the current academic term, including the academic year, term code, hgn code, the total number of types of courses, the average number of units, the department name, the name and email address of the person in charge?",
    "db_id": "dw",
    "sql": "SELECT CC.ACADEMIC_YEAR, CC.TERM_CODE, SO.HGN_CODE, COUNT(DISTINCT CC.SUBJECT_ID) AS TOTAL_COURSES, AVG(CC.TOTAL_UNITS) AS AVERAGE_UNITS, CC.DEPARTMENT_NAME, ED.FULL_NAME AS RESPONSIBLE_FACULTY_NAME, ED.EMAIL_ADDRESS AS RESPONSIBLE_FACULTY_EMAIL FROM COURSE_CATALOG_SUBJECT_OFFERED CC JOIN SUBJECT_OFFERED SO ON CC.SUBJECT_ID = SO.SUBJECT_ID JOIN ACADEMIC_TERMS AT ON CC.TERM_CODE = AT.TERM_CODE JOIN EMPLOYEE_DIRECTORY ED ON SO.RESPONSIBLE_FACULTY_MIT_ID = ED.MIT_ID WHERE AT.IS_CURRENT_TERM = 'Y' GROUP BY CC.ACADEMIC_YEAR, CC.TERM_CODE, SO.HGN_CODE, CC.DEPARTMENT_NAME, ED.FULL_NAME, ED.EMAIL_ADDRESS;",
    "oracle_sql": "SELECT CC.ACADEMIC_YEAR, CC.TERM_CODE, SO.HGN_CODE, COUNT(DISTINCT CC.SUBJECT_ID) AS TOTAL_COURSES, AVG(CC.TOTAL_UNITS) AS AVERAGE_UNITS, CC.DEPARTMENT_NAME, ED.FULL_NAME AS RESPONSIBLE_FACULTY_NAME, ED.EMAIL_ADDRESS AS RESPONSIBLE_FACULTY_EMAIL FROM COURSE_CATALOG_SUBJECT_OFFERED CC JOIN SUBJECT_OFFERED SO ON CC.SUBJECT_ID = SO.SUBJECT_ID JOIN ACADEMIC_TERMS AT ON CC.TERM_CODE = AT.TERM_CODE JOIN EMPLOYEE_DIRECTORY ED ON SO.RESPONSIBLE_FACULTY_MIT_ID = ED.MIT_ID WHERE AT.IS_CURRENT_TERM = 'Y' GROUP BY CC.ACADEMIC_YEAR, CC.TERM_CODE, SO.HGN_CODE, CC.DEPARTMENT_NAME, ED.FULL_NAME, ED.EMAIL_ADDRESS;",
    "gold_tables": [
      "dw#sep#COURSE_CATALOG_SUBJECT_OFFERED",
      "dw#sep#SUBJECT_OFFERED",
      "dw#sep#ACADEMIC_TERMS",
      "dw#sep#EMPLOYEE_DIRECTORY"
    ],
    "mapping": {
      "current academic term": [
        "ACADEMIC_TERMS.IS_CURRENT_TERM"
      ],
      "academic year": [
        "COURSE_CATALOG_SUBJECT_OFFERED.ACADEMIC_YEAR"
      ],
      "term code": [
        "COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE"
      ],
      "hgn code": [
        "SUBJECT_OFFERED.HGN_CODE"
      ],
      "courses": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID"
      ],
      "number of units": [
        "COURSE_CATALOG_SUBJECT_OFFERED.TOTAL_UNITS"
      ],
      "department name": [
        "COURSE_CATALOG_SUBJECT_OFFERED.DEPARTMENT_NAME"
      ],
      "name": [
        "EMPLOYEE_DIRECTORY.FULL_NAME"
      ],
      "email address": [
        "EMPLOYEE_DIRECTORY.EMAIL_ADDRESS"
      ]
    },
    "join_keys": [
      [
        "SUBJECT_OFFERED.SUBJECT_ID",
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID"
      ],
      [
        "COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE",
        "ACADEMIC_TERMS.TERM_CODE"
      ],
      [
        "EMPLOYEE_DIRECTORY.MIT_ID",
        "SUBJECT_OFFERED.RESPONSIBLE_FACULTY_MIT_ID"
      ]
    ]
  },
  {
    "question": "Retrieve information about the IAP subjects, including their titles, categories, session titles, session start time, session end time, sponsor names, and total number of sessions.",
    "db_id": "dw",
    "sql": "SELECT isd.ACTIVITY_TITLE, isc.IAP_CATEGORY_NAME, iss.SESSION_TITLE, iss.SESSION_START_TIME, iss.SESSION_END_TIME, isp.SPONSOR_NAME, COUNT(distinct iss.IAP_SUBJECT_SESSION_KEY) AS Total_Sessions FROM IAP_SUBJECT_DETAIL isd JOIN IAP_SUBJECT_CATEGORY isc ON isd.IAP_SUBJECT_CATEGORY_KEY = isc.IAP_SUBJECT_CATEGORY_KEY JOIN IAP_SUBJECT_SESSION iss ON isd.IAP_SUBJECT_SESSION_KEY = iss.IAP_SUBJECT_SESSION_KEY JOIN IAP_SUBJECT_SPONSOR isp ON isd.IAP_SUBJECT_SPONSOR_KEY = isp.IAP_SUBJECT_SPONSOR_KEY GROUP BY isd.ACTIVITY_TITLE, isc.IAP_CATEGORY_NAME, iss.SESSION_TITLE, iss.SESSION_START_TIME, iss.SESSION_END_TIME, isp.SPONSOR_NAME;",
    "oracle_sql": "SELECT isd.ACTIVITY_TITLE, isc.IAP_CATEGORY_NAME, iss.SESSION_TITLE, iss.SESSION_START_TIME, iss.SESSION_END_TIME, isp.SPONSOR_NAME, COUNT(distinct iss.IAP_SUBJECT_SESSION_KEY) AS Total_Sessions FROM IAP_SUBJECT_DETAIL isd JOIN IAP_SUBJECT_CATEGORY isc ON isd.IAP_SUBJECT_CATEGORY_KEY = isc.IAP_SUBJECT_CATEGORY_KEY JOIN IAP_SUBJECT_SESSION iss ON isd.IAP_SUBJECT_SESSION_KEY = iss.IAP_SUBJECT_SESSION_KEY JOIN IAP_SUBJECT_SPONSOR isp ON isd.IAP_SUBJECT_SPONSOR_KEY = isp.IAP_SUBJECT_SPONSOR_KEY GROUP BY isd.ACTIVITY_TITLE, isc.IAP_CATEGORY_NAME, iss.SESSION_TITLE, iss.SESSION_START_TIME, iss.SESSION_END_TIME, isp.SPONSOR_NAME;",
    "gold_tables": [
      "dw#sep#IAP_SUBJECT_DETAIL",
      "dw#sep#IAP_SUBJECT_CATEGORY",
      "dw#sep#IAP_SUBJECT_SESSION",
      "dw#sep#IAP_SUBJECT_SPONSOR"
    ],
    "mapping": {
      "titles": [
        "IAP_SUBJECT_DETAIL.ACTIVITY_TITLE"
      ],
      "categories": [
        "IAP_SUBJECT_CATEGORY.IAP_CATEGORY_NAME"
      ],
      "session titles": [
        "IAP_SUBJECT_SESSION.SESSION_TITLE"
      ],
      "session start time": [
        "IAP_SUBJECT_SESSION.SESSION_START_TIME"
      ],
      "session end time": [
        "IAP_SUBJECT_SESSION.SESSION_END_TIME"
      ],
      "sponsor names": [
        "IAP_SUBJECT_SPONSOR.SPONSOR_NAME"
      ],
      "sessions": [
        "IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY"
      ]
    },
    "join_keys": [
      [
        "IAP_SUBJECT_CATEGORY.IAP_SUBJECT_CATEGORY_KEY",
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_CATEGORY_KEY"
      ],
      [
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_SESSION_KEY",
        "IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY"
      ],
      [
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_SPONSOR_KEY",
        "IAP_SUBJECT_SPONSOR.IAP_SUBJECT_SPONSOR_KEY"
      ]
    ]
  },
  {
    "question": "Show the department names, the corresponding SIS subject code, subject code descriptions, graduate level, and the total number of courses per department.",
    "db_id": "dw",
    "sql": "SELECT sd.DEPARTMENT_NAME, sc.SUBJECT_CODE, sc.SUBJECT_CODE_DESC, scd.GRADUATE_LEVEL, Total_Courses.Total_Courses FROM SIS_DEPARTMENT sd JOIN SIS_COURSE_DESCRIPTION scd ON sd.DEPARTMENT_CODE = scd.DEPARTMENT JOIN SIS_SUBJECT_CODE sc ON scd.COURSE = sc.COURSE_NUMBER JOIN (SELECT sd.DEPARTMENT_NAME, COUNT(DISTINCT COURSE_NUMBER) AS Total_Courses FROM SIS_DEPARTMENT sd JOIN SIS_COURSE_DESCRIPTION scd ON sd.DEPARTMENT_CODE = scd.DEPARTMENT JOIN SIS_SUBJECT_CODE sc ON scd.COURSE = sc.COURSE_NUMBER GROUP BY DEPARTMENT_NAME) AS Total_Courses ON sd.DEPARTMENT_NAME = Total_Courses.DEPARTMENT_NAME;",
    "oracle_sql": "SELECT sd.DEPARTMENT_NAME, sc.SUBJECT_CODE, sc.SUBJECT_CODE_DESC, scd.GRADUATE_LEVEL, COUNT(DISTINCT sc.COURSE_NUMBER) OVER (PARTITION BY sd.DEPARTMENT_NAME) AS Total_Courses FROM SIS_DEPARTMENT sd JOIN SIS_COURSE_DESCRIPTION scd ON sd.DEPARTMENT_CODE = scd.DEPARTMENT JOIN SIS_SUBJECT_CODE sc ON scd.COURSE = sc.COURSE_NUMBER;",
    "gold_tables": [
      "dw#sep#SIS_DEPARTMENT",
      "dw#sep#SIS_COURSE_DESCRIPTION",
      "dw#sep#SIS_SUBJECT_CODE"
    ],
    "mapping": {
      "department names": [
        "SIS_DEPARTMENT.DEPARTMENT_NAME"
      ],
      "SIS subject code": [
        "SIS_SUBJECT_CODE.SUBJECT_CODE"
      ],
      "subject code descriptions": [
        "SIS_SUBJECT_CODE.SUBJECT_CODE_DESC"
      ],
      "graduate level": [
        "SIS_COURSE_DESCRIPTION.GRADUATE_LEVEL"
      ],
      "courses": [
        "SIS_SUBJECT_CODE.COURSE_NUMBER"
      ]
    },
    "join_keys": [
      [
        "SIS_COURSE_DESCRIPTION.DEPARTMENT",
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ],
      [
        "SIS_SUBJECT_CODE.COURSE_NUMBER",
        "SIS_COURSE_DESCRIPTION.COURSE"
      ]
    ]
  },
  {
    "question": "For each term, list the term code, the term description, whether the term is current or not, and the total number of types of CIS courses.",
    "db_id": "dw",
    "sql": "SELECT at.TERM_CODE, at.TERM_DESCRIPTION, at.IS_CURRENT_TERM2, COUNT(DISTINCT at.SUBJECT_ID) AS Total_SUBJECTS FROM (SELECT at.*, SUBJECT_ID, CASE WHEN at.ACADEMIC_YEAR = YEAR(CURDATE()) AND atp.IS_CURRENT_TERM = 'Y' THEN 'Y' ELSE 'N' END AS IS_CURRENT_TERM2 FROM (SELECT ACADEMIC_TERMS_ALL.*, CASE WHEN TERM_CODE LIKE '%FA' THEN 'Y' END AS A, CASE WHEN TERM_CODE LIKE '%JA' THEN 'Y' END AS B, CASE WHEN TERM_CODE LIKE '%SP' THEN 'Y' END AS C, CASE WHEN TERM_CODE LIKE '%SU' THEN 'Y' END AS D FROM ACADEMIC_TERMS_ALL) at LEFT OUTER JOIN ACADEMIC_TERM_PARAMETER atp ON at.TERM_CODE = atp.TERM_CODE LEFT OUTER JOIN CIS_COURSE_CATALOG ccc ON ccc.ACADEMIC_YEAR = at.ACADEMIC_YEAR AND (IS_OFFERED_FALL_TERM = at.A OR IS_OFFERED_IAP = at.B OR IS_OFFERED_SPRING_TERM = at.C OR IS_OFFERED_SUMMER_TERM = at.D)) at GROUP BY at.TERM_CODE, at.TERM_DESCRIPTION, at.IS_CURRENT_TERM2;",
    "oracle_sql": "SELECT at.TERM_CODE, at.TERM_DESCRIPTION, at.IS_CURRENT_TERM2, COUNT(distinct at.SUBJECT_ID) AS Total_SUBJECTS FROM (SELECT at.*, SUBJECT_ID, CASE WHEN at.ACADEMIC_YEAR = EXTRACT(YEAR FROM SYSDATE) AND atp.IS_CURRENT_TERM = 'Y' THEN 'Y' ELSE 'N' END as IS_CURRENT_TERM2 FROM (SELECT ACADEMIC_TERMS_ALL.*, CASE WHEN TERM_CODE LIKE '%FA' THEN 'Y' END AS A ,CASE WHEN TERM_CODE LIKE '%JA' THEN 'Y' END AS B,CASE WHEN TERM_CODE LIKE '%SP' THEN 'Y' END AS C,CASE WHEN TERM_CODE LIKE '%SU' THEN 'Y' END AS D FROM ACADEMIC_TERMS_ALL) at LEFT OUTER JOIN ACADEMIC_TERM_PARAMETER atp ON at.TERM_CODE = atp.TERM_CODE LEFT OUTER JOIN CIS_COURSE_CATALOG ccc ON ccc.ACADEMIC_YEAR = at.ACADEMIC_YEAR AND (IS_OFFERED_FALL_TERM = at.A OR IS_OFFERED_IAP = at.B OR IS_OFFERED_SPRING_TERM = at.C OR IS_OFFERED_SPRING_TERM = at.C OR IS_OFFERED_SUMMER_TERM = at.D)) at GROUP BY at.TERM_CODE, at.TERM_DESCRIPTION, at.IS_CURRENT_TERM2;",
    "gold_tables": [
      "dw#sep#ACADEMIC_TERMS_ALL",
      "dw#sep#ACADEMIC_TERM_PARAMETER",
      "dw#sep#CIS_COURSE_CATALOG"
    ],
    "mapping": {
      "term code": [
        "ACADEMIC_TERMS_ALL.TERM_CODE"
      ],
      "term description": [
        "ACADEMIC_TERMS_ALL.TERM_DESCRIPTION"
      ],
      "term is current or not": [
        "ACADEMIC_TERM_PARAMETER.IS_CURRENT_TERM"
      ],
      "CIS courses": [
        "CIS_COURSE_CATALOG.SUBJECT_ID"
      ]
    },
    "join_keys": []
  },
  {
    "question": "What is the author, school name, material status, total record counts, and total number of types of courses for each author and school?",
    "db_id": "dw",
    "sql": "SELECT tm.AUTHOR, sd.SCHOOL_NAME, tms.TIP_MATERIAL_STATUS, SUM(td.RECORD_COUNT) AS Total_Record_Count , COUNT(distinct td.SUBJECT_ID) AS Total_Subject FROM TIP_DETAIL td JOIN (select TIP_MATERIAL_KEY, CASE WHEN INSTR(AUTHOR, ';') > 0 THEN SUBSTR(AUTHOR, 1, INSTR(AUTHOR, ';') - 1) ELSE AUTHOR END AS AUTHOR FROM TIP_MATERIAL) tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY JOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY JOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY JOIN STUDENT_DEPARTMENT sd ON tso.OFFER_DEPT_CODE = sd.DEPARTMENT_CODE GROUP BY tm.AUTHOR, tms.TIP_MATERIAL_STATUS, sd.SCHOOL_NAME;",
    "oracle_sql": "SELECT tm.AUTHOR, sd.SCHOOL_NAME, tms.TIP_MATERIAL_STATUS, SUM(td.RECORD_COUNT) AS Total_Record_Count , COUNT(distinct td.SUBJECT_ID) AS Total_Subject FROM TIP_DETAIL td JOIN (select TIP_MATERIAL_KEY, CASE WHEN INSTR(AUTHOR, ';') > 0 THEN SUBSTR(AUTHOR, 1, INSTR(AUTHOR, ';') - 1) ELSE AUTHOR END AS AUTHOR FROM TIP_MATERIAL) tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY JOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY JOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY JOIN STUDENT_DEPARTMENT sd ON tso.OFFER_DEPT_CODE = sd.DEPARTMENT_CODE GROUP BY tm.AUTHOR, tms.TIP_MATERIAL_STATUS, sd.SCHOOL_NAME;",
    "gold_tables": [
      "dw#sep#TIP_DETAIL",
      "dw#sep#TIP_MATERIAL",
      "dw#sep#TIP_MATERIAL_STATUS",
      "dw#sep#TIP_SUBJECT_OFFERED",
      "dw#sep#STUDENT_DEPARTMENT"
    ],
    "mapping": {
      "author": [
        "TIP_MATERIAL.AUTHOR"
      ],
      "school name": [
        "STUDENT_DEPARTMENT.SCHOOL_NAME"
      ],
      "material status": [
        "TIP_MATERIAL_STATUS.TIP_MATERIAL_STATUS"
      ],
      "record counts": [
        "TIP_DETAIL.RECORD_COUNT"
      ],
      "courses": [
        "TIP_DETAIL.SUBJECT_ID"
      ]
    },
    "join_keys": [
      [
        "TIP_MATERIAL_STATUS.TIP_MATERIAL_STATUS_KEY",
        "TIP_DETAIL.TIP_MATERIAL_STATUS_KEY"
      ],
      [
        "TIP_SUBJECT_OFFERED.TIP_SUBJECT_OFFERED_KEY",
        "TIP_DETAIL.TIP_SUBJECT_OFFERED_KEY"
      ],
      [
        "STUDENT_DEPARTMENT.DEPARTMENT_CODE",
        "TIP_SUBJECT_OFFERED.OFFER_DEPT_CODE"
      ]
    ]
  },
  {
    "question": "What is the course number, subject title, material status, the total, min, and max new shelf price, the total, min, and max used shelf price, total number of schools and the total number of materials for each TIP subject and material status?",
    "db_id": "dw",
    "sql": "SELECT tso.COURSE_NUMBER, tso.SUBJECT_TITLE, tms.TIP_MATERIAL_STATUS, SUM(tm.NEW_SHELF_PRICE) as Total_New_Price, Min(tm.NEW_SHELF_PRICE) as Min_New_Price, Max(tm.NEW_SHELF_PRICE) as Max_New_Price, SUM(tm.USED_SHELF_PRICE) as Total_Used_Price, Min(tm.USED_SHELF_PRICE) as Min_Used_Price, Max(tm.USED_SHELF_PRICE) as Max_Used_Price, COUNT(DISTINCT OFFER_SCHOOL_NAME) AS Total_Num_Schools, COUNT(distinct td.TIP_MATERIAL_KEY) AS Total_Num_Materials FROM TIP_DETAIL td JOIN TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY JOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY JOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY GROUP BY tso.COURSE_NUMBER, tso.SUBJECT_TITLE, tms.TIP_MATERIAL_STATUS;",
    "oracle_sql": "SELECT tso.COURSE_NUMBER, tso.SUBJECT_TITLE, tms.TIP_MATERIAL_STATUS, SUM(tm.NEW_SHELF_PRICE) as Total_New_Price, Min(tm.NEW_SHELF_PRICE) as Min_New_Price, Max(tm.NEW_SHELF_PRICE) as Max_New_Price, SUM(tm.USED_SHELF_PRICE) as Total_Used_Price, Min(tm.USED_SHELF_PRICE) as Min_Used_Price, Max(tm.USED_SHELF_PRICE) as Max_Used_Price, COUNT(DISTINCT OFFER_SCHOOL_NAME) AS Total_Num_Schools, COUNT(distinct td.TIP_MATERIAL_KEY) AS Total_Num_Materials FROM TIP_DETAIL td JOIN TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY JOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY JOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY GROUP BY tso.COURSE_NUMBER, tso.SUBJECT_TITLE, tms.TIP_MATERIAL_STATUS;",
    "gold_tables": [
      "dw#sep#TIP_DETAIL",
      "dw#sep#TIP_MATERIAL",
      "dw#sep#TIP_MATERIAL_STATUS",
      "dw#sep#TIP_SUBJECT_OFFERED"
    ],
    "mapping": {
      "course number": [
        "TIP_SUBJECT_OFFERED.COURSE_NUMBER"
      ],
      "subject title": [
        "TIP_SUBJECT_OFFERED.SUBJECT_TITLE"
      ],
      "material status": [
        "TIP_MATERIAL_STATUS.TIP_MATERIAL_STATUS"
      ],
      "new shelf price": [
        "TIP_MATERIAL.NEW_SHELF_PRICE"
      ],
      "used shelf price": [
        "TIP_MATERIAL.USED_SHELF_PRICE"
      ],
      "schools": [
        "TIP_SUBJECT_OFFERED.OFFER_SCHOOL_NAME"
      ],
      "materials": [
        "TIP_DETAIL.TIP_MATERIAL_KEY"
      ],
      "TIP subject": [
        "TIP_SUBJECT_OFFERED.SUBJECT_TITLE"
      ]
    },
    "join_keys": [
      [
        "TIP_DETAIL.TIP_MATERIAL_KEY",
        "TIP_MATERIAL.TIP_MATERIAL_KEY"
      ],
      [
        "TIP_DETAIL.TIP_MATERIAL_STATUS_KEY",
        "TIP_MATERIAL_STATUS.TIP_MATERIAL_STATUS_KEY"
      ],
      [
        "TIP_DETAIL.TIP_SUBJECT_OFFERED_KEY",
        "TIP_SUBJECT_OFFERED.TIP_SUBJECT_OFFERED_KEY"
      ]
    ]
  },
  {
    "question": "What is material status, the total number of materials, the total number of subjects, the total number of schools, and the most recent publication year for each material status?",
    "db_id": "dw",
    "sql": "SELECT tms.TIP_MATERIAL_STATUS, COUNT(DISTINCT td.TIP_MATERIAL_KEY) AS Total_Materials, COUNT(DISTINCT td.SUBJECT_ID) AS Total_Subjects, COUNT(DISTINCT sd.SCHOOL_NAME) AS Total_Num_Schools, MAX(tm.YEAR) AS Most_Recent_Year FROM TIP_DETAIL td JOIN TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY JOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY JOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY JOIN STUDENT_DEPARTMENT sd ON tso.OFFER_DEPT_CODE = sd.DEPARTMENT_CODE GROUP BY tms.TIP_MATERIAL_STATUS;",
    "oracle_sql": "SELECT tms.TIP_MATERIAL_STATUS, COUNT(DISTINCT td.TIP_MATERIAL_KEY) AS Total_Materials, COUNT(DISTINCT td.SUBJECT_ID) AS Total_Subjects, COUNT(DISTINCT sd.SCHOOL_NAME) AS Total_Num_Schools, MAX(tm.YEAR) AS Most_Recent_Year FROM TIP_DETAIL td JOIN TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY JOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY JOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY JOIN STUDENT_DEPARTMENT sd ON tso.OFFER_DEPT_CODE = sd.DEPARTMENT_CODE GROUP BY tms.TIP_MATERIAL_STATUS;",
    "gold_tables": [
      "dw#sep#TIP_DETAIL",
      "dw#sep#TIP_MATERIAL",
      "dw#sep#TIP_MATERIAL_STATUS",
      "dw#sep#TIP_SUBJECT_OFFERED",
      "dw#sep#STUDENT_DEPARTMENT"
    ],
    "mapping": {
      "material status": [
        "TIP_MATERIAL_STATUS.TIP_MATERIAL_STATUS"
      ],
      "materials": [
        "TIP_DETAIL.TIP_MATERIAL_KEY"
      ],
      "subjects": [
        "TIP_DETAIL.SUBJECT_ID"
      ],
      "schools": [
        "STUDENT_DEPARTMENT.SCHOOL_NAME"
      ],
      "publication year": [
        "TIP_MATERIAL.YEAR"
      ]
    },
    "join_keys": [
      [
        "TIP_MATERIAL.TIP_MATERIAL_KEY",
        "TIP_DETAIL.TIP_MATERIAL_KEY"
      ],
      [
        "TIP_MATERIAL_STATUS.TIP_MATERIAL_STATUS_KEY",
        "TIP_DETAIL.TIP_MATERIAL_STATUS_KEY"
      ],
      [
        "TIP_DETAIL.TIP_SUBJECT_OFFERED_KEY",
        "TIP_SUBJECT_OFFERED.TIP_SUBJECT_OFFERED_KEY"
      ],
      [
        "STUDENT_DEPARTMENT.DEPARTMENT_CODE",
        "TIP_SUBJECT_OFFERED.OFFER_DEPT_CODE"
      ]
    ]
  },
  {
    "question": "What is the term description, whether the term is current or not, total number of types of TIP subjects offered and materials needed, the minimum and maximum number of enrolled students, the total number of schools offering subjects, and the total number of records for each term code?",
    "db_id": "dw",
    "sql": "SELECT at.TERM_DESCRIPTION, at.IS_CURRENT_TERM, COUNT(DISTINCT tso.COURSE_NUMBER) AS Total_Courses, COUNT(DISTINCT tm.ISBN) AS Total_Materials, MIN(tso.NUM_ENROLLED_STUDENTS) AS Min_Enrolled_Students, MAX(tso.NUM_ENROLLED_STUDENTS) AS Max_Enrolled_Students, COUNT(DISTINCT OFFER_SCHOOL_NAME) AS Total_Num_Schools, SUM(td.RECORD_COUNT) AS Total_Records FROM ACADEMIC_TERMS_ALL at LEFT OUTER JOIN TIP_SUBJECT_OFFERED tso ON at.TERM_CODE = tso.TERM_CODE JOIN TIP_DETAIL td ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY JOIN TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY JOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY GROUP BY at.TERM_CODE, at.TERM_DESCRIPTION, at.IS_CURRENT_TERM;",
    "oracle_sql": "SELECT at.TERM_DESCRIPTION, at.IS_CURRENT_TERM, COUNT(DISTINCT tso.COURSE_NUMBER) AS Total_Courses, COUNT(DISTINCT tm.ISBN) AS Total_Materials, MIN(tso.NUM_ENROLLED_STUDENTS) AS Min_Enrolled_Students, MAX(tso.NUM_ENROLLED_STUDENTS) AS Max_Enrolled_Students, COUNT(DISTINCT OFFER_SCHOOL_NAME) AS Total_Num_Schools, SUM(td.RECORD_COUNT) AS Total_Records FROM ACADEMIC_TERMS_ALL at LEFT OUTER JOIN TIP_SUBJECT_OFFERED tso ON at.TERM_CODE = tso.TERM_CODE JOIN TIP_DETAIL td ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY JOIN TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY JOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY GROUP BY at.TERM_CODE, at.TERM_DESCRIPTION, at.IS_CURRENT_TERM;",
    "gold_tables": [
      "dw#sep#ACADEMIC_TERMS_ALL",
      "dw#sep#TIP_SUBJECT_OFFERED",
      "dw#sep#TIP_DETAIL",
      "dw#sep#TIP_MATERIAL",
      "dw#sep#TIP_MATERIAL_STATUS"
    ],
    "mapping": {
      "term description": [
        "ACADEMIC_TERMS_ALL.TERM_DESCRIPTION"
      ],
      "term is current or not": [
        "ACADEMIC_TERMS_ALL.IS_CURRENT_TERM"
      ],
      "TIP subjects": [
        "TIP_SUBJECT_OFFERED.COURSE_NUMBER"
      ],
      "materials": [
        "TIP_MATERIAL.ISBN"
      ],
      "enrolled students": [
        "TIP_SUBJECT_OFFERED.NUM_ENROLLED_STUDENTS"
      ],
      "schools": [
        "TIP_SUBJECT_OFFERED.OFFER_SCHOOL_NAME"
      ],
      "number of records": [
        "TIP_DETAIL.RECORD_COUNT"
      ],
      "term code": [
        "ACADEMIC_TERMS_ALL.TERM_CODE"
      ]
    },
    "join_keys": [
      [
        "ACADEMIC_TERMS_ALL.TERM_CODE",
        "TIP_SUBJECT_OFFERED.TERM_CODE"
      ],
      [
        "TIP_SUBJECT_OFFERED.TIP_SUBJECT_OFFERED_KEY",
        "TIP_DETAIL.TIP_SUBJECT_OFFERED_KEY"
      ],
      [
        "TIP_DETAIL.TIP_MATERIAL_KEY",
        "TIP_MATERIAL.TIP_MATERIAL_KEY"
      ],
      [
        "TIP_DETAIL.TIP_MATERIAL_STATUS_KEY",
        "TIP_MATERIAL_STATUS.TIP_MATERIAL_STATUS_KEY"
      ]
    ]
  },
  {
    "question": "List all buildings with their names, building numbers, building height, street address, city, state, HR department name, assignable square footage, total and average square footage, ordered in descending order of assignable, total, and average square footage.",
    "db_id": "dw",
    "sql": "SELECT DISTINCT new.BUILDING_NAME, new.BUILDING_NUMBER, fb.BUILDING_HEIGHT, new.BUILDING_STREET_ADDRESS, fba.CITY, fba.STATE, new.HR_DEPARTMENT_NAME, new.BLDG_ASSIGNABLE_SQUARE_FOOTAGE, new.Total_Square_Footage, new.Avg_Square_Footage_Per_Room FROM (SELECT b.BUILDING_NAME, b.BUILDING_NUMBER, b.BUILDING_STREET_ADDRESS, fb.FAC_BUILDING_KEY, fo.HR_DEPARTMENT_NAME, b.BLDG_ASSIGNABLE_SQUARE_FOOTAGE, SUM(fr.AREA) AS Total_Square_Footage, AVG(fr.AREA) AS Avg_Square_Footage_Per_Room FROM BUILDINGS b JOIN FAC_BUILDING fb ON b.BUILDING_KEY = fb.FAC_BUILDING_KEY JOIN FAC_ROOMS fr ON fb.FAC_BUILDING_KEY = fr.BUILDING_KEY JOIN FAC_ORGANIZATION fo ON fr.ORGANIZATION_KEY = fo.ORGANIZATION_KEY GROUP BY b.BUILDING_NAME, b.BUILDING_NUMBER, b.BUILDING_STREET_ADDRESS, fb.FAC_BUILDING_KEY, fo.HR_DEPARTMENT_NAME, b.BLDG_ASSIGNABLE_SQUARE_FOOTAGE) new JOIN FAC_BUILDING_ADDRESS fba ON new.FAC_BUILDING_KEY = fba.BUILDING_KEY JOIN FAC_BUILDING fb ON new.FAC_BUILDING_KEY = fb.FAC_BUILDING_KEY WHERE fba.ADDRESS_PURPOSE = 'STREET' ORDER BY new.BLDG_ASSIGNABLE_SQUARE_FOOTAGE DESC, new.Total_Square_Footage DESC, new.Avg_Square_Footage_Per_Room DESC;",
    "oracle_sql": "SELECT DISTINCT new.BUILDING_NAME, new.BUILDING_NUMBER, fb.BUILDING_HEIGHT, new.BUILDING_STREET_ADDRESS, fba.CITY, fba.STATE, new.HR_DEPARTMENT_NAME, new.BLDG_ASSIGNABLE_SQUARE_FOOTAGE, new.Total_Square_Footage, new.Avg_Square_Footage_Per_Room FROM (SELECT b.BUILDING_NAME, b.BUILDING_NUMBER, b.BUILDING_STREET_ADDRESS, fb.FAC_BUILDING_KEY, fo.HR_DEPARTMENT_NAME, b.BLDG_ASSIGNABLE_SQUARE_FOOTAGE, SUM(fr.AREA) AS Total_Square_Footage, AVG(fr.AREA) AS Avg_Square_Footage_Per_Room FROM BUILDINGS b JOIN FAC_BUILDING fb ON b.BUILDING_KEY = fb.FAC_BUILDING_KEY JOIN FAC_ROOMS fr ON fb.FAC_BUILDING_KEY = fr.BUILDING_KEY JOIN FAC_ORGANIZATION fo ON fr.ORGANIZATION_KEY = fo.ORGANIZATION_KEY GROUP BY b.BUILDING_NAME, b.BUILDING_NUMBER, b.BUILDING_STREET_ADDRESS, fb.FAC_BUILDING_KEY, fo.HR_DEPARTMENT_NAME, b.BLDG_ASSIGNABLE_SQUARE_FOOTAGE) new JOIN FAC_BUILDING_ADDRESS fba ON new.FAC_BUILDING_KEY = fba.BUILDING_KEY JOIN FAC_BUILDING fb ON new.FAC_BUILDING_KEY = fb.FAC_BUILDING_KEY WHERE fba.ADDRESS_PURPOSE = 'STREET' ORDER BY new.BLDG_ASSIGNABLE_SQUARE_FOOTAGE DESC, new.Total_Square_Footage DESC, new.Avg_Square_Footage_Per_Room DESC;",
    "gold_tables": [
      "dw#sep#BUILDINGS",
      "dw#sep#FAC_BUILDING",
      "dw#sep#FAC_ROOMS",
      "dw#sep#FAC_ORGANIZATION",
      "dw#sep#FAC_BUILDING_ADDRESS"
    ],
    "mapping": {
      "names": [
        "BUILDINGS.BUILDING_NAME"
      ],
      "building numbers": [
        "BUILDINGS.BUILDING_NUMBER"
      ],
      "building height": [
        "FAC_BUILDING.BUILDING_HEIGHT"
      ],
      "street address": [
        "BUILDINGS.BUILDING_STREET_ADDRESS"
      ],
      "city": [
        "FAC_BUILDING_ADDRESS.CITY"
      ],
      "state": [
        "FAC_BUILDING_ADDRESS.STATE"
      ],
      "HR department name": [
        "FAC_ORGANIZATION.HR_DEPARTMENT_NAME"
      ],
      "assignable square footage": [
        "BUILDINGS.BLDG_ASSIGNABLE_SQUARE_FOOTAGE"
      ],
      "square footage": [
        "FAC_ROOMS.AREA"
      ]
    },
    "join_keys": [
      [
        "FAC_BUILDING.FAC_BUILDING_KEY",
        "BUILDINGS.BUILDING_KEY"
      ],
      [
        "FAC_BUILDING.FAC_BUILDING_KEY",
        "FAC_ROOMS.BUILDING_KEY"
      ],
      [
        "FAC_ROOMS.ORGANIZATION_KEY",
        "FAC_ORGANIZATION.ORGANIZATION_KEY"
      ]
    ]
  },
  {
    "question": "For the 2023 Fall term, what are the unique term descriptions, subject titles along with their prerequisites, total number of types of subjects per term code, instructor of this course, and the number of types of courses ever taught by the instructor?",
    "db_id": "dw",
    "sql": "WITH SubjectCounts AS (SELECT TERM_CODE, FALL_INSTRUCTORS, SUBJECT_ID, COUNT(*) OVER (PARTITION BY TERM_CODE) AS Total_Subjects, COUNT(*) OVER (PARTITION BY FALL_INSTRUCTORS) AS Experience FROM COURSE_CATALOG_SUBJECT_OFFERED WHERE TERM_CODE = '2023FA') SELECT DISTINCT at.TERM_DESCRIPTION, ccso.SUBJECT_TITLE, ccso.PREREQUISITES, sc.Total_Subjects, ccso.FALL_INSTRUCTORS, sc.Experience FROM COURSE_CATALOG_SUBJECT_OFFERED ccso JOIN ACADEMIC_TERMS at ON ccso.TERM_CODE = at.TERM_CODE JOIN SubjectCounts sc ON ccso.TERM_CODE = sc.TERM_CODE AND ccso.SUBJECT_ID = sc.SUBJECT_ID WHERE ccso.TERM_CODE = '2023FA';",
    "oracle_sql": "SELECT DISTINCT at.TERM_DESCRIPTION, ccso.SUBJECT_TITLE, ccso.PREREQUISITES, COUNT(distinct ccso.SUBJECT_ID) OVER (PARTITION BY at.TERM_CODE) AS Total_Subjects, ccso.FALL_INSTRUCTORS, COUNT(distinct ccso.SUBJECT_ID) OVER (PARTITION BY ccso.FALL_INSTRUCTORS) AS Experience FROM COURSE_CATALOG_SUBJECT_OFFERED ccso JOIN ACADEMIC_TERMS at ON ccso.TERM_CODE = at.TERM_CODE WHERE ccso.TERM_CODE = '2023FA';",
    "gold_tables": [
      "dw#sep#COURSE_CATALOG_SUBJECT_OFFERED",
      "dw#sep#ACADEMIC_TERMS"
    ],
    "mapping": {
      "2023 Fall term": [
        "COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE"
      ],
      "term descriptions": [
        "ACADEMIC_TERMS.TERM_DESCRIPTION"
      ],
      "subject titles": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_TITLE"
      ],
      "prerequisites": [
        "COURSE_CATALOG_SUBJECT_OFFERED.PREREQUISITES"
      ],
      "subjects": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID"
      ],
      "term code": [
        "COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE"
      ],
      "instructor": [
        "COURSE_CATALOG_SUBJECT_OFFERED.FALL_INSTRUCTORS"
      ],
      "courses": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID"
      ]
    },
    "join_keys": [
      [
        "COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE",
        "ACADEMIC_TERMS.TERM_CODE"
      ]
    ]
  },
  {
    "question": "Show the details of rooms including the full name of the rooms, the building names, floor numbers, the organizations occupying them, name of the departments occupying them, and the percentage of the room area over the assignable floor area and building.",
    "db_id": "dw",
    "sql": "SELECT fr.ROOM_FULL_NAME, fb.BUILDING_NAME, ff.FLOOR, fo.ORGANIZATION_NAME, fo.HR_DEPARTMENT_NAME, CASE WHEN ff.ASSIGNABLE_AREA = 0 THEN 0 ELSE fr.AREA/ff.ASSIGNABLE_AREA END AS PERC_OF_ASG_FLOOR, CASE WHEN fb.ASSIGNABLE_AREA = 0 THEN 0 ELSE fr.AREA/fb.ASSIGNABLE_AREA END AS PERC_OF_ASG_BUILDING FROM FAC_ROOMS fr JOIN FAC_BUILDING fb ON fr.BUILDING_KEY = fb.FAC_BUILDING_KEY JOIN FAC_FLOOR ff ON fr.FLOOR_KEY = ff.FLOOR_KEY JOIN FAC_ORGANIZATION fo ON fr.ORGANIZATION_KEY = fo.ORGANIZATION_KEY;",
    "oracle_sql": "SELECT fr.ROOM_FULL_NAME, fb.BUILDING_NAME, ff.FLOOR, fo.ORGANIZATION_NAME, fo.HR_DEPARTMENT_NAME, CASE WHEN ff.ASSIGNABLE_AREA = 0 THEN 0 ELSE fr.AREA/ff.ASSIGNABLE_AREA END AS PERC_OF_ASG_FLOOR, CASE WHEN fb.ASSIGNABLE_AREA = 0 THEN 0 ELSE fr.AREA/fb.ASSIGNABLE_AREA END AS PERC_OF_ASG_BUILDING FROM FAC_ROOMS fr JOIN FAC_BUILDING fb ON fr.BUILDING_KEY = fb.FAC_BUILDING_KEY JOIN FAC_FLOOR ff ON fr.FLOOR_KEY = ff.FLOOR_KEY JOIN FAC_ORGANIZATION fo ON fr.ORGANIZATION_KEY = fo.ORGANIZATION_KEY;",
    "gold_tables": [
      "dw#sep#FAC_ROOMS",
      "dw#sep#FAC_BUILDING",
      "dw#sep#FAC_FLOOR",
      "dw#sep#FAC_ORGANIZATION"
    ],
    "mapping": {
      "full name of the rooms": [
        "FAC_ROOMS.ROOM_FULL_NAME"
      ],
      "building names": [
        "FAC_BUILDING.BUILDING_NAME"
      ],
      "floor numbers": [
        "FAC_FLOOR.FLOOR"
      ],
      "organizations": [
        "FAC_ORGANIZATION.ORGANIZATION_NAME"
      ],
      "name of the departments": [
        "FAC_ORGANIZATION.HR_DEPARTMENT_NAME"
      ],
      "room area": [
        "FAC_ROOMS.AREA"
      ],
      "assignable floor area": [
        "FAC_FLOOR.ASSIGNABLE_AREA"
      ]
    },
    "join_keys": [
      [
        "FAC_ROOMS.BUILDING_KEY",
        "FAC_BUILDING.FAC_BUILDING_KEY"
      ],
      [
        "FAC_ROOMS.FLOOR_KEY",
        "FAC_FLOOR.FLOOR_KEY"
      ],
      [
        "FAC_ROOMS.ORGANIZATION_KEY",
        "FAC_ORGANIZATION.ORGANIZATION_KEY"
      ]
    ]
  },
  {
    "question": "Show the details of rooms including the full name of the rooms, the building names, floor numbers, the organizations occupying them, name of the departments occupying them, and the percentage of the room area over the floor area and building.",
    "db_id": "dw",
    "sql": "SELECT fr.ROOM_FULL_NAME, fb.BUILDING_NAME, ff.FLOOR, fo.ORGANIZATION_NAME, fo.HR_DEPARTMENT_NAME, CASE WHEN FLOOR_AREA = 0 THEN 0 ELSE fr.AREA/FLOOR_AREA END AS PERC_OF_FLOOR, CASE WHEN BUILDING_AREA = 0 THEN 0 ELSE fr.AREA/BUILDING_AREA END AS PERC_OF_BUILDING FROM (SELECT ROOM_FULL_NAME, BUILDING_KEY, FLOOR_KEY,ORGANIZATION_KEY, AREA, SUM(AREA) OVER (PARTITION BY FLOOR_KEY) AS FLOOR_AREA, SUM(AREA) OVER (PARTITION BY BUILDING_KEY) AS BUILDING_AREA FROM FAC_ROOMS) fr JOIN FAC_BUILDING fb ON fr.BUILDING_KEY = fb.FAC_BUILDING_KEY JOIN FAC_FLOOR ff ON fr.FLOOR_KEY = ff.FLOOR_KEY JOIN FAC_ORGANIZATION fo ON fr.ORGANIZATION_KEY = fo.ORGANIZATION_KEY;",
    "oracle_sql": "SELECT fr.ROOM_FULL_NAME, fb.BUILDING_NAME, ff.FLOOR, fo.ORGANIZATION_NAME, fo.HR_DEPARTMENT_NAME, CASE WHEN FLOOR_AREA = 0 THEN 0 ELSE fr.AREA/FLOOR_AREA END AS PERC_OF_FLOOR, CASE WHEN BUILDING_AREA = 0 THEN 0 ELSE fr.AREA/BUILDING_AREA END AS PERC_OF_BUILDING FROM (SELECT ROOM_FULL_NAME, BUILDING_KEY, FLOOR_KEY,ORGANIZATION_KEY, AREA, SUM(AREA) OVER (PARTITION BY FLOOR_KEY) AS FLOOR_AREA, SUM(AREA) OVER (PARTITION BY BUILDING_KEY) AS BUILDING_AREA FROM FAC_ROOMS) fr JOIN FAC_BUILDING fb ON fr.BUILDING_KEY = fb.FAC_BUILDING_KEY JOIN FAC_FLOOR ff ON fr.FLOOR_KEY = ff.FLOOR_KEY JOIN FAC_ORGANIZATION fo ON fr.ORGANIZATION_KEY = fo.ORGANIZATION_KEY;",
    "gold_tables": [
      "dw#sep#FAC_ROOMS",
      "dw#sep#FAC_BUILDING",
      "dw#sep#FAC_FLOOR",
      "dw#sep#FAC_ORGANIZATION"
    ],
    "mapping": {
      "full name": [
        "FAC_ROOMS.ROOM_FULL_NAME"
      ],
      "building names": [
        "FAC_BUILDING.BUILDING_NAME"
      ],
      "floor numbers": [
        "FAC_FLOOR.FLOOR"
      ],
      "organizations": [
        "FAC_ORGANIZATION.ORGANIZATION_NAME"
      ],
      "departments": [
        "FAC_ORGANIZATION.HR_DEPARTMENT_NAME"
      ],
      "room area": [
        "FAC_ROOMS.AREA"
      ],
      "floor area": [
        "FAC_ROOMS.AREA",
        "FAC_ROOMS.FLOOR_KEY"
      ]
    },
    "join_keys": []
  },
  {
    "question": "What are the academic year, and instructors names for courses offered in the academic year 2022, along with the total number of types of courses per instructor?",
    "db_id": "dw",
    "sql": "SELECT ata.ACADEMIC_YEAR, ed.FULL_NAME, COUNT(distinct so.COURSE_NUMBER) AS Total_Courses FROM SUBJECT_OFFERED so JOIN ACADEMIC_TERMS_ALL ata ON so.TERM_CODE = ata.TERM_CODE JOIN EMPLOYEE_DIRECTORY ed ON so.RESPONSIBLE_FACULTY_MIT_ID = ed.MIT_ID WHERE ata.ACADEMIC_YEAR = 2022 GROUP BY ata.ACADEMIC_YEAR, ed.FULL_NAME;",
    "oracle_sql": "SELECT ata.ACADEMIC_YEAR, ed.FULL_NAME, COUNT(distinct so.COURSE_NUMBER) AS Total_Courses FROM SUBJECT_OFFERED so JOIN ACADEMIC_TERMS_ALL ata ON so.TERM_CODE = ata.TERM_CODE JOIN EMPLOYEE_DIRECTORY ed ON so.RESPONSIBLE_FACULTY_MIT_ID = ed.MIT_ID WHERE ata.ACADEMIC_YEAR = 2022 GROUP BY ata.ACADEMIC_YEAR, ed.FULL_NAME;",
    "gold_tables": [
      "dw#sep#SUBJECT_OFFERED",
      "dw#sep#ACADEMIC_TERMS_ALL",
      "dw#sep#EMPLOYEE_DIRECTORY"
    ],
    "mapping": {
      "academic year": [
        "ACADEMIC_TERMS_ALL.ACADEMIC_YEAR"
      ],
      "instructors names": [
        "EMPLOYEE_DIRECTORY.FULL_NAME"
      ],
      "courses": [
        "SUBJECT_OFFERED.COURSE_NUMBER"
      ]
    },
    "join_keys": [
      [
        "SUBJECT_OFFERED.TERM_CODE",
        "ACADEMIC_TERMS_ALL.TERM_CODE"
      ],
      [
        "SUBJECT_OFFERED.RESPONSIBLE_FACULTY_MIT_ID",
        "EMPLOYEE_DIRECTORY.MIT_ID"
      ]
    ]
  },
  {
    "question": "What are the building names, department names, organizations, their highest and lowest floor number, along with the total number of rooms per each building key?",
    "db_id": "dw",
    "sql": "SELECT fb.BUILDING_NAME, fo.HR_DEPARTMENT_NAME, fo.ORGANIZATION, MAX(ff.LEVEL_ID) as MAX_FLOOR, MIN(ff.LEVEL_ID) as MIN_FLOOR, COUNT(distinct fr.FAC_ROOM_KEY) AS Total_Rooms FROM FAC_BUILDING fb JOIN FAC_ROOMS fr ON fb.FAC_BUILDING_KEY = fr.BUILDING_KEY JOIN FAC_FLOOR ff ON fr.FLOOR_KEY = ff.FLOOR_KEY JOIN FAC_ORGANIZATION fo ON fr.ORGANIZATION_KEY = fo.ORGANIZATION_KEY GROUP BY fb.FAC_BUILDING_KEY, fb.BUILDING_NAME, fo.HR_DEPARTMENT_NAME, fo.ORGANIZATION;",
    "oracle_sql": "SELECT fb.BUILDING_NAME, fo.HR_DEPARTMENT_NAME, fo.ORGANIZATION, MAX(ff.LEVEL_ID) as MAX_FLOOR, MIN(ff.LEVEL_ID) as MIN_FLOOR, COUNT(distinct fr.FAC_ROOM_KEY) AS Total_Rooms FROM FAC_BUILDING fb JOIN FAC_ROOMS fr ON fb.FAC_BUILDING_KEY = fr.BUILDING_KEY JOIN FAC_FLOOR ff ON fr.FLOOR_KEY = ff.FLOOR_KEY JOIN FAC_ORGANIZATION fo ON fr.ORGANIZATION_KEY = fo.ORGANIZATION_KEY GROUP BY fb.FAC_BUILDING_KEY, fb.BUILDING_NAME, fo.HR_DEPARTMENT_NAME, fo.ORGANIZATION;",
    "gold_tables": [
      "dw#sep#FAC_BUILDING",
      "dw#sep#FAC_ROOMS",
      "dw#sep#FAC_FLOOR",
      "dw#sep#FAC_ORGANIZATION"
    ],
    "mapping": {
      "building names": [
        "FAC_BUILDING.BUILDING_NAME"
      ],
      "department names": [
        "FAC_ORGANIZATION.HR_DEPARTMENT_NAME"
      ],
      "organizations": [
        "FAC_ORGANIZATION.ORGANIZATION"
      ],
      "floor number": [
        "FAC_FLOOR.LEVEL_ID"
      ],
      "room": [
        "FAC_ROOMS.FAC_ROOM_KEY"
      ],
      "building key": [
        "FAC_BUILDING.FAC_BUILDING_KEY"
      ]
    },
    "join_keys": [
      [
        "FAC_BUILDING.FAC_BUILDING_KEY",
        "FAC_ROOMS.BUILDING_KEY"
      ],
      [
        "FAC_FLOOR.FLOOR_KEY",
        "FAC_ROOMS.FLOOR_KEY"
      ],
      [
        "FAC_ORGANIZATION.ORGANIZATION_KEY",
        "FAC_ROOMS.ORGANIZATION_KEY"
      ]
    ]
  },
  {
    "question": "Provide the complete information for students with the first name Kevin, including their full names, email addresses, department names, department phone numbers, school names, and the total student count per department and school. If a student is associated with more than one department, list a separate row for each department.",
    "db_id": "dw",
    "sql": "SELECT DISTINCT msd.FULL_NAME, msd.EMAIL_ADDRESS, sd.DEPARTMENT_NAME, sad.DEPARTMENT_PHONE_NUMBER, sd.SCHOOL_NAME, (SELECT COUNT(DISTINCT msd2.EMAIL_ADDRESS) FROM MIT_STUDENT_DIRECTORY msd2 JOIN SIS_DEPARTMENT sd2 ON msd2.DEPARTMENT = sd2.DEPARTMENT_CODE WHERE sd2.DEPARTMENT_CODE = sd.DEPARTMENT_CODE) AS Total_Students_DEPT, (SELECT COUNT(DISTINCT msd3.EMAIL_ADDRESS) FROM MIT_STUDENT_DIRECTORY msd3 JOIN SIS_DEPARTMENT sd3 ON msd3.DEPARTMENT = sd3.DEPARTMENT_CODE WHERE sd3.SCHOOL_CODE = sd.SCHOOL_CODE) AS Total_Students_SCHOOL FROM MIT_STUDENT_DIRECTORY msd JOIN SIS_DEPARTMENT sd ON msd.DEPARTMENT = sd.DEPARTMENT_CODE JOIN SIS_ADMIN_DEPARTMENT sad ON sd.DEPARTMENT_CODE = sad.SIS_ADMIN_DEPARTMENT_CODE WHERE msd.FIRST_NAME = 'Kevin';",
    "oracle_sql": "SELECT DISTINCT msd.FULL_NAME, msd.EMAIL_ADDRESS, sd.DEPARTMENT_NAME, sad.DEPARTMENT_PHONE_NUMBER, sd.SCHOOL_NAME, COUNT(distinct msd.EMAIL_ADDRESS) OVER (PARTITION BY sd.DEPARTMENT_CODE) AS Total_Students_DEPT, COUNT(distinct msd.EMAIL_ADDRESS) OVER (PARTITION BY sd.SCHOOL_CODE) AS Total_Students_SCHOOLS FROM MIT_STUDENT_DIRECTORY msd JOIN SIS_DEPARTMENT sd ON msd.DEPARTMENT = sd.DEPARTMENT_CODE JOIN SIS_ADMIN_DEPARTMENT sad ON sd.DEPARTMENT_CODE = sad.SIS_ADMIN_DEPARTMENT_CODE WHERE upper(msd.FIRST_NAME) LIKE 'KEVIN%';",
    "gold_tables": [
      "dw#sep#MIT_STUDENT_DIRECTORY",
      "dw#sep#SIS_DEPARTMENT",
      "dw#sep#SIS_ADMIN_DEPARTMENT"
    ],
    "mapping": {
      "first name": [
        "MIT_STUDENT_DIRECTORY.FIRST_NAME"
      ],
      "full names": [
        "MIT_STUDENT_DIRECTORY.FULL_NAME"
      ],
      "email addresses": [
        "MIT_STUDENT_DIRECTORY.EMAIL_ADDRESS"
      ],
      "department names": [
        "SIS_DEPARTMENT.DEPARTMENT_NAME"
      ],
      "department phone numbers": [
        "SIS_ADMIN_DEPARTMENT.DEPARTMENT_PHONE_NUMBER"
      ],
      "school names": [
        "SIS_DEPARTMENT.SCHOOL_NAME"
      ],
      "student": [
        "MIT_STUDENT_DIRECTORY.EMAIL_ADDRESS"
      ],
      "department": [
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ],
      "school": [
        "SIS_DEPARTMENT.SCHOOL_CODE"
      ]
    },
    "join_keys": [
      [
        "MIT_STUDENT_DIRECTORY.DEPARTMENT",
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ],
      [
        "SIS_ADMIN_DEPARTMENT.SIS_ADMIN_DEPARTMENT_CODE",
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ]
    ]
  },
  {
    "question": "What are the unique titles of subjects offered in the fall term along with their instructor names, instructor emails, and the total number of types of subjects per instructor?",
    "db_id": "dw",
    "sql": "SELECT ccso.SUBJECT_TITLE, e.FULL_NAME AS INSTRUCTOR, e.EMAIL_ADDRESS, Total_Subjects.Total_Subjects FROM EMPLOYEE_DIRECTORY e JOIN COURSE_CATALOG_SUBJECT_OFFERED ccso ON ccso.RESPONSIBLE_FACULTY_MIT_ID = e.MIT_ID JOIN ACADEMIC_TERMS_ALL at ON ccso.TERM_CODE = at.TERM_CODE JOIN (SELECT ccso.RESPONSIBLE_FACULTY_MIT_ID, COUNT(DISTINCT ccso.SUBJECT_ID) AS Total_Subjects FROM COURSE_CATALOG_SUBJECT_OFFERED ccso JOIN ACADEMIC_TERMS_ALL at ON ccso.TERM_CODE = at.TERM_CODE WHERE at.TERM_CODE LIKE '%FA' GROUP BY ccso.RESPONSIBLE_FACULTY_MIT_ID) AS Total_Subjects ON e.MIT_ID = Total_Subjects.RESPONSIBLE_FACULTY_MIT_ID WHERE at.TERM_CODE LIKE '%FA' GROUP BY ccso.SUBJECT_TITLE, e.FULL_NAME, e.EMAIL_ADDRESS, Total_Subjects.Total_Subjects;",
    "oracle_sql": "SELECT DISTINCT ccso.SUBJECT_TITLE, e.FULL_NAME AS INSTRUCTOR, e.EMAIL_ADDRESS, COUNT(distinct ccso.SUBJECT_ID) OVER (PARTITION BY ccso.FALL_INSTRUCTORS) AS Total_Subjects FROM EMPLOYEE_DIRECTORY e JOIN COURSE_CATALOG_SUBJECT_OFFERED ccso ON ccso.RESPONSIBLE_FACULTY_MIT_ID = e.MIT_ID JOIN ACADEMIC_TERMS_ALL at ON ccso.TERM_CODE = at.TERM_CODE WHERE at.TERM_CODE LIKE '%FA';",
    "gold_tables": [
      "dw#sep#EMPLOYEE_DIRECTORY",
      "dw#sep#COURSE_CATALOG_SUBJECT_OFFERED",
      "dw#sep#ACADEMIC_TERMS_ALL"
    ],
    "mapping": {
      "titles": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_TITLE"
      ],
      "subjects": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID"
      ],
      "fall term": [
        "ACADEMIC_TERMS_ALL.TERM_CODE"
      ],
      "instructor names": [
        "EMPLOYEE_DIRECTORY.FULL_NAME"
      ],
      "instructor emails": [
        "EMPLOYEE_DIRECTORY.EMAIL_ADDRESS"
      ]
    },
    "join_keys": [
      [
        "COURSE_CATALOG_SUBJECT_OFFERED.RESPONSIBLE_FACULTY_MIT_ID",
        "EMPLOYEE_DIRECTORY.MIT_ID"
      ],
      [
        "COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE",
        "ACADEMIC_TERMS_ALL.TERM_CODE"
      ]
    ]
  },
  {
    "question": "List the building names, names of HR departments occupying them, the total gross square footage, the total and average assignable square footage, and the built year per building key.",
    "db_id": "dw",
    "sql": "SELECT b.BUILDING_NAME, fo.HR_DEPARTMENT_NAME, SUM(b.BLDG_GROSS_SQUARE_FOOTAGE) AS Total_Gross_Sq_Ft, SUM(b.BLDG_ASSIGNABLE_SQUARE_FOOTAGE) AS Total_Assignable_Sq_Ft, AVG(b.BLDG_ASSIGNABLE_SQUARE_FOOTAGE) AS Avg_Assignable_Sq_Ft, YEAR(STR_TO_DATE(fb.DATE_BUILT, '%m/%d/%Y')) AS Year_Built FROM BUILDINGS b JOIN FAC_BUILDING fb ON b.BUILDING_KEY = fb.FAC_BUILDING_KEY JOIN FAC_ROOMS fr ON fb.FAC_BUILDING_KEY = fr.BUILDING_KEY JOIN FAC_ORGANIZATION fo ON fr.ORGANIZATION_KEY = fo.ORGANIZATION_KEY GROUP BY b.BUILDING_KEY, b.BUILDING_NAME, fo.HR_DEPARTMENT_NAME, fb.DATE_BUILT;",
    "oracle_sql": "SELECT b.BUILDING_NAME, fo.HR_DEPARTMENT_NAME, SUM(b.BLDG_GROSS_SQUARE_FOOTAGE) AS Total_Gross_Sq_Ft, SUM(b.BLDG_ASSIGNABLE_SQUARE_FOOTAGE) AS Total_Assignable_Sq_Ft, AVG(b.BLDG_ASSIGNABLE_SQUARE_FOOTAGE) AS Avg_Assignable_Sq_Ft, EXTRACT(YEAR FROM TO_DATE(fb.DATE_BUILT, 'MM/DD/YYYY')) AS Year_Built FROM BUILDINGS b JOIN FAC_BUILDING fb ON b.BUILDING_KEY = fb.FAC_BUILDING_KEY JOIN FAC_ROOMS fr ON fb.FAC_BUILDING_KEY = fr.BUILDING_KEY JOIN FAC_ORGANIZATION fo ON fr.ORGANIZATION_KEY = fo.ORGANIZATION_KEY GROUP BY b.BUILDING_KEY, b.BUILDING_NAME, fo.HR_DEPARTMENT_NAME, fb.DATE_BUILT;",
    "gold_tables": [
      "dw#sep#BUILDINGS",
      "dw#sep#FAC_BUILDING",
      "dw#sep#FAC_ROOMS",
      "dw#sep#FAC_ORGANIZATION"
    ],
    "mapping": {
      "building names": [
        "BUILDINGS.BUILDING_NAME"
      ],
      "names of HR departments": [
        "FAC_ORGANIZATION.HR_DEPARTMENT_NAME"
      ],
      "gross square footage": [
        "BUILDINGS.BLDG_GROSS_SQUARE_FOOTAGE"
      ],
      "assignable square footage": [
        "BUILDINGS.BLDG_ASSIGNABLE_SQUARE_FOOTAGE"
      ],
      "built year": [
        "FAC_BUILDING.DATE_BUILT"
      ],
      "building key": [
        "BUILDINGS.BUILDING_KEY"
      ]
    },
    "join_keys": [
      [
        "BUILDINGS.BUILDING_KEY",
        "FAC_BUILDING.FAC_BUILDING_KEY"
      ],
      [
        "FAC_BUILDING.FAC_BUILDING_KEY",
        "FAC_ROOMS.BUILDING_KEY"
      ],
      [
        "FAC_ROOMS.ORGANIZATION_KEY",
        "FAC_ORGANIZATION.ORGANIZATION_KEY"
      ]
    ]
  },
  {
    "question": "Retrieve the titles of subjects offered in the summer term along with their descriptions, responsible faculty names, email address, building name, room name, floor level, building street address, and the total number of types of courses per departmnet.",
    "db_id": "dw",
    "sql": "SELECT ccso.SUBJECT_TITLE, ccso.SUBJECT_DESCRIPTION, ccso.RESPONSIBLE_FACULTY_NAME, ed.EMAIL_ADDRESS, b.BUILDING_NAME, fr.ROOM_FULL_NAME, ff.LEVEL_ID, b.BUILDING_STREET_ADDRESS, (SELECT COUNT(DISTINCT ccso2.SUBJECT_ID) FROM COURSE_CATALOG_SUBJECT_OFFERED ccso2 WHERE ccso2.DEPARTMENT_CODE = ccso.DEPARTMENT_CODE) AS Total_Courses FROM COURSE_CATALOG_SUBJECT_OFFERED ccso JOIN EMPLOYEE_DIRECTORY ed ON ccso.RESPONSIBLE_FACULTY_MIT_ID = ed.MIT_ID JOIN ACADEMIC_TERMS at ON ccso.TERM_CODE = at.TERM_CODE JOIN FAC_ROOMS fr ON ccso.MEET_PLACE = fr.FAC_ROOM_KEY JOIN FAC_FLOOR ff ON ff.FLOOR_KEY = fr.FLOOR_KEY JOIN BUILDINGS b ON fr.BUILDING_KEY = b.BUILDING_KEY JOIN FAC_BUILDING_ADDRESS fba ON fba.BUILDING_KEY = fr.BUILDING_KEY WHERE at.TERM_CODE LIKE '%SU' AND fba.ADDRESS_PURPOSE = 'STREET';",
    "oracle_sql": "SELECT ccso.SUBJECT_TITLE, ccso.SUBJECT_DESCRIPTION, ccso.RESPONSIBLE_FACULTY_NAME, ed.EMAIL_ADDRESS, b.BUILDING_NAME, fr.ROOM_FULL_NAME, ff.LEVEL_ID, b.BUILDING_STREET_ADDRESS, COUNT(DISTINCT ccso.SUBJECT_ID) OVER (PARTITION BY ccso.DEPARTMENT_CODE) AS Total_Courses FROM COURSE_CATALOG_SUBJECT_OFFERED ccso JOIN EMPLOYEE_DIRECTORY ed ON ccso.RESPONSIBLE_FACULTY_MIT_ID = ed.MIT_ID JOIN ACADEMIC_TERMS at ON ccso.TERM_CODE = at.TERM_CODE JOIN FAC_ROOMS fr ON ccso.MEET_PLACE = fr.FAC_ROOM_KEY JOIN FAC_FLOOR ff ON ff.FLOOR_KEY = fr.FLOOR_KEY JOIN BUILDINGS b ON fr.BUILDING_KEY = b.BUILDING_KEY JOIN FAC_BUILDING_ADDRESS fba ON fba.BUILDING_KEY = fr.BUILDING_KEY WHERE at.TERM_CODE LIKE '%SU' AND fba.ADDRESS_PURPOSE = 'STREET';",
    "gold_tables": [
      "dw#sep#COURSE_CATALOG_SUBJECT_OFFERED",
      "dw#sep#EMPLOYEE_DIRECTORY",
      "dw#sep#ACADEMIC_TERMS",
      "dw#sep#FAC_ROOMS",
      "dw#sep#FAC_FLOOR",
      "dw#sep#BUILDINGS",
      "dw#sep#FAC_BUILDING_ADDRESS"
    ],
    "mapping": {
      "titles of subjects": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_TITLE"
      ],
      "summer term": [
        "ACADEMIC_TERMS.TERM_CODE"
      ],
      "descriptions": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_DESCRIPTION"
      ],
      "responsible faculty names": [
        "COURSE_CATALOG_SUBJECT_OFFERED.RESPONSIBLE_FACULTY_NAME"
      ],
      "email address": [
        "EMPLOYEE_DIRECTORY.EMAIL_ADDRESS"
      ],
      "building name": [
        "BUILDINGS.BUILDING_NAME"
      ],
      "room name": [
        "FAC_ROOMS.ROOM_FULL_NAME"
      ],
      "floor level": [
        "FAC_FLOOR.LEVEL_ID"
      ],
      "building street address": [
        "BUILDINGS.BUILDING_STREET_ADDRESS",
        "FAC_BUILDING_ADDRESS.ADDRESS_PURPOSE"
      ],
      "courses": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID"
      ],
      "department": [
        "COURSE_CATALOG_SUBJECT_OFFERED.DEPARTMENT_CODE"
      ]
    },
    "join_keys": [
      [
        "COURSE_CATALOG_SUBJECT_OFFERED.RESPONSIBLE_FACULTY_MIT_ID",
        "EMPLOYEE_DIRECTORY.MIT_ID"
      ],
      [
        "ACADEMIC_TERMS.TERM_CODE",
        "COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE"
      ],
      [
        "COURSE_CATALOG_SUBJECT_OFFERED.MEET_PLACE",
        "FAC_ROOMS.FAC_ROOM_KEY"
      ],
      [
        "FAC_ROOMS.FLOOR_KEY",
        "FAC_FLOOR.FLOOR_KEY"
      ],
      [
        "FAC_ROOMS.BUILDING_KEY",
        "BUILDINGS.BUILDING_KEY"
      ],
      [
        "FAC_ROOMS.BUILDING_KEY",
        "FAC_BUILDING_ADDRESS.BUILDING_KEY"
      ]
    ]
  },
  {
    "question": "For each term code, list the term description, attribute desciption, department name, school name, and the number of subjects in the area of humanities, arts and social sciences.",
    "db_id": "dw",
    "sql": "SELECT ata.TERM_DESCRIPTION, ccso.HASS_ATTRIBUTE_DESC, sd.DEPARTMENT_NAME, sd.SCHOOL_NAME, (SELECT COUNT(DISTINCT ccso2.SUBJECT_ID) FROM COURSE_CATALOG_SUBJECT_OFFERED ccso2 JOIN CIS_HASS_ATTRIBUTE cha2 ON ccso2.HASS_ATTRIBUTE = cha2.HASS_ATTRIBUTE WHERE ccso2.TERM_CODE = ata.TERM_CODE AND cha2.CIS_ATTRIBUTE_GROUP = cha.CIS_ATTRIBUTE_GROUP) AS Total_Subjects FROM COURSE_CATALOG_SUBJECT_OFFERED ccso JOIN CIS_HASS_ATTRIBUTE cha ON ccso.HASS_ATTRIBUTE = cha.HASS_ATTRIBUTE JOIN SIS_DEPARTMENT sd ON ccso.DEPARTMENT_CODE = sd.DEPARTMENT_CODE JOIN ACADEMIC_TERMS_ALL ata ON ccso.TERM_CODE = ata.TERM_CODE WHERE cha.CIS_ATTRIBUTE_GROUP = 'H';",
    "oracle_sql": "SELECT ata.TERM_DESCRIPTION, ccso.HASS_ATTRIBUTE_DESC, sd.DEPARTMENT_NAME, sd.SCHOOL_NAME, COUNT(distinct ccso.SUBJECT_ID) OVER (PARTITION BY ata.TERM_CODE, cha.CIS_ATTRIBUTE_GROUP) AS Total_Subjects FROM COURSE_CATALOG_SUBJECT_OFFERED ccso JOIN CIS_HASS_ATTRIBUTE cha ON ccso.HASS_ATTRIBUTE = cha.HASS_ATTRIBUTE JOIN SIS_DEPARTMENT sd ON ccso.DEPARTMENT_CODE = sd.DEPARTMENT_CODE JOIN ACADEMIC_TERMS_ALL ata ON ccso.TERM_CODE = ata.TERM_CODE WHERE cha.CIS_ATTRIBUTE_GROUP = 'H';",
    "gold_tables": [
      "dw#sep#COURSE_CATALOG_SUBJECT_OFFERED",
      "dw#sep#CIS_HASS_ATTRIBUTE",
      "dw#sep#SIS_DEPARTMENT",
      "dw#sep#ACADEMIC_TERMS_ALL"
    ],
    "mapping": {
      "term code": [
        "ACADEMIC_TERMS_ALL.TERM_CODE"
      ],
      "term description": [
        "ACADEMIC_TERMS_ALL.TERM_DESCRIPTION"
      ],
      "attribute desciption": [
        "COURSE_CATALOG_SUBJECT_OFFERED.HASS_ATTRIBUTE_DESC"
      ],
      "department name": [
        "SIS_DEPARTMENT.DEPARTMENT_NAME"
      ],
      "school name": [
        "SIS_DEPARTMENT.SCHOOL_NAME"
      ],
      "subjects": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID"
      ],
      "area of humanities, arts and social studies": [
        "CIS_HASS_ATTRIBUTE.CIS_ATTRIBUTE_GROUP"
      ]
    },
    "join_keys": [
      [
        "CIS_HASS_ATTRIBUTE.HASS_ATTRIBUTE",
        "COURSE_CATALOG_SUBJECT_OFFERED.HASS_ATTRIBUTE"
      ],
      [
        "COURSE_CATALOG_SUBJECT_OFFERED.DEPARTMENT_CODE",
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ],
      [
        "ACADEMIC_TERMS_ALL.TERM_CODE",
        "COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE"
      ]
    ]
  },
  {
    "question": "List building names, their height, street address, city, state, postal code, their gross and assignable square footage, the smallest and largest floor level and the total area of all rooms for each building key.",
    "db_id": "dw",
    "sql": "SELECT fb.BUILDING_NAME, fb.BUILDING_HEIGHT, b.BUILDING_STREET_ADDRESS, fba.CITY, fba.STATE, fba.POSTAL_CODE, fb.EXT_GROSS_AREA, fb.ASSIGNABLE_AREA, MIN(ff.LEVEL_ID) as SMALLEST_FLOOR, MAX(LEVEL_ID) AS HIGHEST_FLOOR, SUM(fr.AREA) AS Total_Room_Area FROM FAC_BUILDING fb JOIN FAC_BUILDING_ADDRESS fba ON fb.FAC_BUILDING_KEY = fba.BUILDING_KEY JOIN FAC_FLOOR ff ON fb.FAC_BUILDING_KEY = ff.BUILDING_KEY JOIN FAC_ROOMS fr ON ff.FLOOR_KEY = fr.FLOOR_KEY JOIN BUILDINGS b ON b.BUILDING_KEY = fb.FAC_BUILDING_KEY WHERE fba.ADDRESS_PURPOSE = 'STREET' GROUP BY fb.FAC_BUILDING_KEY, fb.BUILDING_NAME, fb.BUILDING_HEIGHT, fba.CITY, fba.POSTAL_CODE, fba.STATE, b.BUILDING_STREET_ADDRESS, fb.EXT_GROSS_AREA, fb.ASSIGNABLE_AREA;",
    "oracle_sql": "SELECT fb.BUILDING_NAME, fb.BUILDING_HEIGHT, b.BUILDING_STREET_ADDRESS, fba.CITY, fba.STATE, fba.POSTAL_CODE, fb.EXT_GROSS_AREA, fb.ASSIGNABLE_AREA, MIN(ff.LEVEL_ID) as SMALLEST_FLOOR, MAX(LEVEL_ID) AS HIGHEST_FLOOR, SUM(fr.AREA) AS Total_Room_Area FROM FAC_BUILDING fb JOIN FAC_BUILDING_ADDRESS fba ON fb.FAC_BUILDING_KEY = fba.BUILDING_KEY JOIN FAC_FLOOR ff ON fb.FAC_BUILDING_KEY = ff.BUILDING_KEY JOIN FAC_ROOMS fr ON ff.FLOOR_KEY = fr.FLOOR_KEY JOIN BUILDINGS b ON b.BUILDING_KEY = fb.FAC_BUILDING_KEY WHERE fba.ADDRESS_PURPOSE = 'STREET' GROUP BY fb.FAC_BUILDING_KEY, fb.BUILDING_NAME, fb.BUILDING_HEIGHT, fba.CITY, fba.POSTAL_CODE, fba.STATE, b.BUILDING_STREET_ADDRESS, fb.EXT_GROSS_AREA, fb.ASSIGNABLE_AREA;",
    "gold_tables": [
      "dw#sep#FAC_BUILDING",
      "dw#sep#FAC_BUILDING_ADDRESS",
      "dw#sep#FAC_FLOOR",
      "dw#sep#FAC_ROOMS",
      "dw#sep#BUILDINGS"
    ],
    "mapping": {
      "building names": [
        "FAC_BUILDING.BUILDING_NAME"
      ],
      "height": [
        "FAC_BUILDING.BUILDING_HEIGHT"
      ],
      "street address": [
        "BUILDINGS.BUILDING_STREET_ADDRESS",
        "FAC_BUILDING_ADDRESS.ADDRESS_PURPOSE"
      ],
      "city": [
        "FAC_BUILDING_ADDRESS.CITY"
      ],
      "state": [
        "FAC_BUILDING_ADDRESS.STATE"
      ],
      "postal code": [
        "FAC_BUILDING_ADDRESS.POSTAL_CODE"
      ],
      "gross square footage": [
        "FAC_BUILDING.EXT_GROSS_AREA"
      ],
      "assignable square footage": [
        "FAC_BUILDING.ASSIGNABLE_AREA"
      ],
      "floor level": [
        "FAC_FLOOR.LEVEL_ID"
      ],
      "area": [
        "FAC_ROOMS.AREA"
      ],
      "building key": [
        "FAC_BUILDING.FAC_BUILDING_KEY"
      ]
    },
    "join_keys": [
      [
        "FAC_BUILDING.FAC_BUILDING_KEY",
        "FAC_BUILDING_ADDRESS.BUILDING_KEY"
      ],
      [
        "FAC_BUILDING.FAC_BUILDING_KEY",
        "FAC_FLOOR.BUILDING_KEY"
      ],
      [
        "FAC_FLOOR.FLOOR_KEY",
        "FAC_ROOMS.FLOOR_KEY"
      ],
      [
        "FAC_BUILDING.FAC_BUILDING_KEY",
        "BUILDINGS.BUILDING_KEY"
      ]
    ]
  },
  {
    "question": "What is the category title, version, department name, school name, total number of courses for each course level, and the total number of degree-granting courses for each CIP category code?",
    "db_id": "dw",
    "sql": "SELECT c.CATEGORY_TITLE, c.VERSION, sd.DEPARTMENT_NAME, sd.SCHOOL_NAME, SUM(CASE WHEN scd.COURSE_LEVEL = 'U' THEN 1 ELSE 0 END) AS Total_U_Courses, SUM(CASE WHEN scd.COURSE_LEVEL = 'G' THEN 1 ELSE 0 END) AS Total_G_Courses, SUM(CASE WHEN scd.IS_DEGREE_GRANTING = 'Y' THEN 1 ELSE 0 END) AS Total_Degree_Granting_Courses FROM CIP c JOIN SIS_COURSE_DESCRIPTION scd ON c.PROGRAM_CODE = scd.CIP_PROGRAM_CODE JOIN SIS_DEPARTMENT sd ON scd.DEPARTMENT = sd.DEPARTMENT_CODE GROUP BY c.CATEGORY_CODE, c.CATEGORY_TITLE, c.VERSION, sd.DEPARTMENT_NAME, sd.SCHOOL_NAME;",
    "oracle_sql": "SELECT c.CATEGORY_TITLE, c.VERSION, sd.DEPARTMENT_NAME, sd.SCHOOL_NAME, SUM(CASE WHEN scd.COURSE_LEVEL = 'U' THEN 1 ELSE 0 END) AS Total_U_Courses, SUM(CASE WHEN scd.COURSE_LEVEL = 'G' THEN 1 ELSE 0 END) AS Total_G_Courses, SUM(CASE WHEN scd.IS_DEGREE_GRANTING = 'Y' THEN 1 ELSE 0 END) AS Total_Degree_Granting_Courses FROM CIP c JOIN SIS_COURSE_DESCRIPTION scd ON c.PROGRAM_CODE = scd.CIP_PROGRAM_CODE JOIN SIS_DEPARTMENT sd ON scd.DEPARTMENT = sd.DEPARTMENT_CODE GROUP BY c.CATEGORY_CODE, c.CATEGORY_TITLE, c.VERSION, sd.DEPARTMENT_NAME, sd.SCHOOL_NAME;",
    "gold_tables": [
      "dw#sep#CIP",
      "dw#sep#SIS_COURSE_DESCRIPTION",
      "dw#sep#SIS_DEPARTMENT"
    ],
    "mapping": {
      "category title": [
        "CIP.CATEGORY_TITLE"
      ],
      "version": [
        "CIP.VERSION"
      ],
      "department name": [
        "SIS_DEPARTMENT.DEPARTMENT_NAME"
      ],
      "school name": [
        "SIS_DEPARTMENT.SCHOOL_NAME"
      ],
      "course level": [
        "SIS_COURSE_DESCRIPTION.COURSE_LEVEL"
      ],
      "degree-granting courses": [
        "SIS_COURSE_DESCRIPTION.IS_DEGREE_GRANTING"
      ],
      "CIP category code": [
        "CIP.CATEGORY_CODE"
      ]
    },
    "join_keys": [
      [
        "SIS_COURSE_DESCRIPTION.CIP_PROGRAM_CODE",
        "CIP.PROGRAM_CODE"
      ],
      [
        "SIS_COURSE_DESCRIPTION.DEPARTMENT",
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ]
    ]
  },
  {
    "question": "What is the total number of library materials, the minimum and maximum publication years, and the total number of materials status for each course name?",
    "db_id": "dw",
    "sql": "SELECT COUNT(distinct lrc.CATALOG_SYSTEM_NUMBER) AS Total_Materials, MIN(lrc.CATALOG_YEAR) AS Min_Publication_Year, MAX(lrc.CATALOG_YEAR) AS Max_Publication_Year, COUNT(DISTINCT lms.LIBRARY_MATERIAL_STATUS) AS Total_Statuses FROM LIBRARY_COURSE_INSTRUCTOR lci JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lci.LIBRARY_COURSE_INSTRUCTOR_KEY = lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY JOIN LIBRARY_RESERVE_CATALOG lrc ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY JOIN LIBRARY_MATERIAL_STATUS lms ON lrmd.LIBRARY_MATERIAL_STATUS_KEY = lms.LIBRARY_MATERIAL_STATUS_KEY GROUP BY lci.COURSE_NAME;",
    "oracle_sql": "SELECT COUNT(distinct lrc.CATALOG_SYSTEM_NUMBER) AS Total_Materials, MIN(lrc.CATALOG_YEAR) AS Min_Publication_Year, MAX(lrc.CATALOG_YEAR) AS Max_Publication_Year, COUNT(DISTINCT lms.LIBRARY_MATERIAL_STATUS) AS Total_Statuses FROM LIBRARY_COURSE_INSTRUCTOR lci JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lci.LIBRARY_COURSE_INSTRUCTOR_KEY = lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY JOIN LIBRARY_RESERVE_CATALOG lrc ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY JOIN LIBRARY_MATERIAL_STATUS lms ON lrmd.LIBRARY_MATERIAL_STATUS_KEY = lms.LIBRARY_MATERIAL_STATUS_KEY GROUP BY lci.COURSE_NAME;",
    "gold_tables": [
      "dw#sep#LIBRARY_COURSE_INSTRUCTOR",
      "dw#sep#LIBRARY_RESERVE_MATRL_DETAIL",
      "dw#sep#LIBRARY_RESERVE_CATALOG",
      "dw#sep#LIBRARY_MATERIAL_STATUS"
    ],
    "mapping": {
      "library materials": [
        "LIBRARY_RESERVE_CATALOG.CATALOG_SYSTEM_NUMBER"
      ],
      "publication years": [
        "LIBRARY_RESERVE_CATALOG.CATALOG_YEAR"
      ],
      "materials status": [
        "LIBRARY_MATERIAL_STATUS.LIBRARY_MATERIAL_STATUS"
      ],
      "course name": [
        "LIBRARY_COURSE_INSTRUCTOR.COURSE_NAME"
      ]
    },
    "join_keys": [
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_COURSE_INSTRUCTOR_KEY",
        "LIBRARY_COURSE_INSTRUCTOR.LIBRARY_COURSE_INSTRUCTOR_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_RESERVE_CATALOG_KEY",
        "LIBRARY_RESERVE_CATALOG.LIBRARY_RESERVE_CATALOG_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_MATERIAL_STATUS_KEY",
        "LIBRARY_MATERIAL_STATUS.LIBRARY_MATERIAL_STATUS_KEY"
      ]
    ]
  },
  {
    "question": "What is the total number of library reserve materials, the minimum and maximum publication years, and the total number of enrolled students for each course instructor?",
    "db_id": "dw",
    "sql": "SELECT COUNT(distinct lrc.CATALOG_SYSTEM_NUMBER) AS Total_Materials, MIN(lrc.CATALOG_YEAR) AS Min_Publication_Year, MAX(lrc.CATALOG_YEAR) AS Max_Publication_Year, SUM(lso.NUM_ENROLLED_STUDENTS) AS Total_Enrolled_Students FROM LIBRARY_COURSE_INSTRUCTOR lci JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lci.LIBRARY_COURSE_INSTRUCTOR_KEY = lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY JOIN LIBRARY_RESERVE_CATALOG lrc ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY JOIN LIBRARY_SUBJECT_OFFERED lso ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY GROUP BY lci.INSTRUCTOR_NAME;",
    "oracle_sql": "SELECT COUNT(distinct lrc.CATALOG_SYSTEM_NUMBER) AS Total_Materials, MIN(lrc.CATALOG_YEAR) AS Min_Publication_Year, MAX(lrc.CATALOG_YEAR) AS Max_Publication_Year, SUM(lso.NUM_ENROLLED_STUDENTS) AS Total_Enrolled_Students FROM LIBRARY_COURSE_INSTRUCTOR lci JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lci.LIBRARY_COURSE_INSTRUCTOR_KEY = lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY JOIN LIBRARY_RESERVE_CATALOG lrc ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY JOIN LIBRARY_SUBJECT_OFFERED lso ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY GROUP BY lci.INSTRUCTOR_NAME;",
    "gold_tables": [
      "dw#sep#LIBRARY_COURSE_INSTRUCTOR",
      "dw#sep#LIBRARY_RESERVE_MATRL_DETAIL",
      "dw#sep#LIBRARY_RESERVE_CATALOG",
      "dw#sep#LIBRARY_SUBJECT_OFFERED"
    ],
    "mapping": {
      "library reserve materials": [
        "LIBRARY_RESERVE_CATALOG.CATALOG_SYSTEM_NUMBER"
      ],
      "publication years": [
        "LIBRARY_RESERVE_CATALOG.CATALOG_YEAR"
      ],
      "enrolled students": [
        "LIBRARY_SUBJECT_OFFERED.NUM_ENROLLED_STUDENTS"
      ],
      "course instructor": [
        "LIBRARY_COURSE_INSTRUCTOR.INSTRUCTOR_NAME"
      ]
    },
    "join_keys": [
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_COURSE_INSTRUCTOR_KEY",
        "LIBRARY_COURSE_INSTRUCTOR.LIBRARY_COURSE_INSTRUCTOR_KEY"
      ],
      [
        "LIBRARY_RESERVE_CATALOG.LIBRARY_RESERVE_CATALOG_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_RESERVE_CATALOG_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_SUBJECT_OFFERED_KEY",
        "LIBRARY_SUBJECT_OFFERED.LIBRARY_SUBJECT_OFFERED_KEY"
      ]
    ]
  },
  {
    "question": "What is the material status, term description, total number of courses and materials, occurences in departments and school, and the total number of instructors for each library material status code and term code?",
    "db_id": "dw",
    "sql": "SELECT lms.LIBRARY_MATERIAL_STATUS, ata.TERM_DESCRIPTION, COUNT(DISTINCT lso.COURSE_NUMBER) AS Total_Courses, COUNT(DISTINCT lrc.CATALOG_SYSTEM_NUMBER) AS Total_Materials, COUNT(DISTINCT lso.OFFER_DEPT_CODE), COUNT(DISTINCT lso.OFFER_SCHOOL_NAME), COUNT(DISTINCT lci.INSTRUCTOR_NAME) AS Total_Instructors FROM LIBRARY_MATERIAL_STATUS lms JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lms.LIBRARY_MATERIAL_STATUS_KEY = lrmd.LIBRARY_MATERIAL_STATUS_KEY JOIN LIBRARY_SUBJECT_OFFERED lso ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY JOIN LIBRARY_COURSE_INSTRUCTOR lci ON lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY = lci.LIBRARY_COURSE_INSTRUCTOR_KEY JOIN LIBRARY_RESERVE_CATALOG lrc ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY JOIN ACADEMIC_TERMS_ALL ata ON ata.TERM_CODE = lso.TERM_CODE GROUP BY lms.LIBRARY_MATERIAL_STATUS_CODE, lms.LIBRARY_MATERIAL_STATUS, lso.TERM_CODE, ata.TERM_DESCRIPTION;",
    "oracle_sql": "SELECT lms.LIBRARY_MATERIAL_STATUS, ata.TERM_DESCRIPTION, COUNT(DISTINCT lso.COURSE_NUMBER) AS Total_Courses, COUNT(DISTINCT lrc.CATALOG_SYSTEM_NUMBER) AS Total_Materials, COUNT(DISTINCT lso.OFFER_DEPT_CODE), COUNT(DISTINCT lso.OFFER_SCHOOL_NAME), COUNT(DISTINCT lci.INSTRUCTOR_NAME) AS Total_Instructors FROM LIBRARY_MATERIAL_STATUS lms JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lms.LIBRARY_MATERIAL_STATUS_KEY = lrmd.LIBRARY_MATERIAL_STATUS_KEY JOIN LIBRARY_SUBJECT_OFFERED lso ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY JOIN LIBRARY_COURSE_INSTRUCTOR lci ON lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY = lci.LIBRARY_COURSE_INSTRUCTOR_KEY JOIN LIBRARY_RESERVE_CATALOG lrc ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY JOIN ACADEMIC_TERMS_ALL ata ON ata.TERM_CODE = lso.TERM_CODE GROUP BY lms.LIBRARY_MATERIAL_STATUS_CODE, lms.LIBRARY_MATERIAL_STATUS, lso.TERM_CODE, ata.TERM_DESCRIPTION;",
    "gold_tables": [
      "dw#sep#LIBRARY_MATERIAL_STATUS",
      "dw#sep#LIBRARY_RESERVE_MATRL_DETAIL",
      "dw#sep#LIBRARY_SUBJECT_OFFERED",
      "dw#sep#LIBRARY_COURSE_INSTRUCTOR",
      "dw#sep#LIBRARY_RESERVE_CATALOG",
      "dw#sep#ACADEMIC_TERMS_ALL"
    ],
    "mapping": {
      "material status": [
        "LIBRARY_MATERIAL_STATUS.LIBRARY_MATERIAL_STATUS"
      ],
      "term description": [
        "ACADEMIC_TERMS_ALL.TERM_DESCRIPTION"
      ],
      "courses": [
        "LIBRARY_SUBJECT_OFFERED.COURSE_NUMBER"
      ],
      "materials": [
        "LIBRARY_RESERVE_CATALOG.CATALOG_SYSTEM_NUMBER"
      ],
      "departments": [
        "LIBRARY_SUBJECT_OFFERED.OFFER_DEPT_CODE"
      ],
      "school": [
        "LIBRARY_SUBJECT_OFFERED.OFFER_SCHOOL_NAME"
      ],
      "instructors": [
        "LIBRARY_COURSE_INSTRUCTOR.INSTRUCTOR_NAME"
      ],
      "library material status code": [
        "LIBRARY_MATERIAL_STATUS.LIBRARY_MATERIAL_STATUS_CODE"
      ],
      "term code": [
        "LIBRARY_SUBJECT_OFFERED.TERM_CODE"
      ]
    },
    "join_keys": [
      [
        "LIBRARY_MATERIAL_STATUS.LIBRARY_MATERIAL_STATUS_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_MATERIAL_STATUS_KEY"
      ],
      [
        "LIBRARY_SUBJECT_OFFERED.LIBRARY_SUBJECT_OFFERED_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_SUBJECT_OFFERED_KEY"
      ],
      [
        "LIBRARY_COURSE_INSTRUCTOR.LIBRARY_COURSE_INSTRUCTOR_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_COURSE_INSTRUCTOR_KEY"
      ],
      [
        "LIBRARY_RESERVE_CATALOG.LIBRARY_RESERVE_CATALOG_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_RESERVE_CATALOG_KEY"
      ],
      [
        "ACADEMIC_TERMS_ALL.TERM_CODE",
        "LIBRARY_SUBJECT_OFFERED.TERM_CODE"
      ]
    ]
  },
  {
    "question": "For building 36, list all space units, their floor and building name, building street address, their space usage, and the number of organizations and space units on the same building and floor.",
    "db_id": "dw",
    "sql": "SELECT DISTINCT su.SPACE_UNIT, sf.FLOOR, b.BUILDING_NAME, b.BUILDING_STREET_ADDRESS, su2.SPACE_USAGE, (SELECT COUNT(DISTINCT fo2.FCLT_ORGANIZATION_KEY) FROM SPACE_UNIT su2 JOIN SPACE_DETAIL sd2 ON su2.SPACE_UNIT_KEY = sd2.SPACE_UNIT_KEY JOIN FCLT_ORGANIZATION fo2 ON fo2.FCLT_ORGANIZATION_KEY = su2.FCLT_ORGANIZATION_KEY WHERE sd2.FLOOR_KEY = sd.FLOOR_KEY AND sd2.BUILDING_KEY = sd.BUILDING_KEY) AS Total_Organizations, (SELECT COUNT(DISTINCT su3.SPACE_UNIT) FROM SPACE_UNIT su3 JOIN SPACE_DETAIL sd3 ON su3.SPACE_UNIT_KEY = sd3.SPACE_UNIT_KEY WHERE sd3.FLOOR_KEY = sd.FLOOR_KEY AND sd3.BUILDING_KEY = sd.BUILDING_KEY) AS Total_Space_Units FROM SPACE_UNIT su JOIN SPACE_DETAIL sd ON su.SPACE_UNIT_KEY = sd.SPACE_UNIT_KEY JOIN SPACE_USAGE su2 ON su2.SPACE_USAGE_KEY = sd.SPACE_USAGE_KEY JOIN SPACE_FLOOR sf ON sd.FLOOR_KEY = sf.FLOOR_KEY JOIN BUILDINGS b ON b.BUILDING_KEY = sd.BUILDING_KEY JOIN FCLT_ORGANIZATION fo ON fo.FCLT_ORGANIZATION_KEY = su.FCLT_ORGANIZATION_KEY JOIN FCLT_BUILDING_ADDRESS fba ON fba.FCLT_BUILDING_KEY = b.BUILDING_KEY WHERE fba.ADDRESS_PURPOSE = 'STREET' AND b.BUILDING_NUMBER = 36;",
    "oracle_sql": "SELECT DISTINCT su.SPACE_UNIT, sf.FLOOR, b.BUILDING_NAME, b.BUILDING_STREET_ADDRESS, su2.SPACE_USAGE, COUNT(DISTINCT fo.FCLT_ORGANIZATION_KEY) OVER (PARTITION BY sd.FLOOR_KEY, sd.BUILDING_KEY) AS Total_Organizations, COUNT(DISTINCT su.SPACE_UNIT) OVER (PARTITION BY sd.FLOOR_KEY, sd.BUILDING_KEY) AS Total_Space_Units FROM SPACE_UNIT su JOIN SPACE_DETAIL sd ON su.SPACE_UNIT_KEY = sd.SPACE_UNIT_KEY JOIN SPACE_USAGE su2 ON su2.SPACE_USAGE_KEY = sd.SPACE_USAGE_KEY JOIN SPACE_FLOOR sf ON sd.FLOOR_KEY = sf.FLOOR_KEY JOIN BUILDINGS b ON b.BUILDING_KEY = sd.BUILDING_KEY JOIN FCLT_ORGANIZATION fo ON fo.FCLT_ORGANIZATION_KEY = su.FCLT_ORGANIZATION_KEY JOIN FCLT_BUILDING_ADDRESS fba ON fba.FCLT_BUILDING_KEY = b.BUILDING_KEY WHERE fba.ADDRESS_PURPOSE = 'STREET' AND b.BUILDING_NUMBER = '36';",
    "gold_tables": [
      "dw#sep#SPACE_UNIT",
      "dw#sep#SPACE_DETAIL",
      "dw#sep#FCLT_ORGANIZATION",
      "dw#sep#SPACE_USAGE",
      "dw#sep#SPACE_FLOOR",
      "dw#sep#BUILDINGS",
      "dw#sep#FCLT_BUILDING_ADDRESS"
    ],
    "mapping": {
      "building 36": [
        "BUILDINGS.BUILDING_NUMBER"
      ],
      "space units": [
        "SPACE_UNIT.SPACE_UNIT"
      ],
      "floor": [
        "SPACE_FLOOR.FLOOR"
      ],
      "building name": [
        "BUILDINGS.BUILDING_NAME"
      ],
      "building street address": [
        "BUILDINGS.BUILDING_STREET_ADDRESS",
        "FCLT_BUILDING_ADDRESS.ADDRESS_PURPOSE"
      ],
      "space usage": [
        "SPACE_USAGE.SPACE_USAGE"
      ],
      "organizations": [
        "FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY"
      ]
    },
    "join_keys": [
      [
        "SPACE_DETAIL.SPACE_UNIT_KEY",
        "SPACE_UNIT.SPACE_UNIT_KEY"
      ],
      [
        "SPACE_USAGE.SPACE_USAGE_KEY",
        "SPACE_DETAIL.SPACE_USAGE_KEY"
      ],
      [
        "SPACE_DETAIL.FLOOR_KEY",
        "SPACE_FLOOR.FLOOR_KEY"
      ],
      [
        "SPACE_DETAIL.BUILDING_KEY",
        "BUILDINGS.BUILDING_KEY"
      ],
      [
        "FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY",
        "SPACE_UNIT.FCLT_ORGANIZATION_KEY"
      ],
      [
        "BUILDINGS.BUILDING_KEY",
        "FCLT_BUILDING_ADDRESS.FCLT_BUILDING_KEY"
      ]
    ]
  },
  {
    "question": "For each distinct mailing list containing more than 1000 people and with a name starting with A (case insensitive), provide its name, whether it is a mailing list, whether it is a moira group, whether it is a NFS group, the owner of the mailing list, and the number of people in the list.",
    "db_id": "dw",
    "sql": "SELECT ml.MOIRA_LIST_NAME, ml.IS_MOIRA_MAILING_LIST, ml.IS_MOIRA_GROUP, ml.IS_NFS_GROUP, mlo.OWNER, member_counts.occurrences FROM MOIRA_LIST_DETAIL mld JOIN MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY JOIN MOIRA_LIST_OWNER mlo ON mld.MOIRA_LIST_OWNER_KEY = mlo.MOIRA_LIST_OWNER_KEY JOIN ( SELECT mld.MOIRA_LIST_KEY, COUNT(mld.MOIRA_LIST_MEMBER) AS occurrences FROM MOIRA_LIST_DETAIL mld GROUP BY mld.MOIRA_LIST_KEY HAVING COUNT(mld.MOIRA_LIST_MEMBER) > 1000 ) member_counts ON ml.MOIRA_LIST_KEY = member_counts.MOIRA_LIST_KEY WHERE upper(ml.MOIRA_LIST_NAME) LIKE 'A%';",
    "oracle_sql": "SELECT DISTINCT ml.MOIRA_LIST_NAME, ml.IS_MOIRA_MAILING_LIST, ml.IS_MOIRA_GROUP, ml.IS_NFS_GROUP, mlo.OWNER, COUNT(mld.MOIRA_LIST_MEMBER) AS occurrences FROM MOIRA_LIST_DETAIL mld JOIN MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY JOIN MOIRA_LIST_OWNER mlo ON mld.MOIRA_LIST_OWNER_KEY = mlo.MOIRA_LIST_OWNER_KEY WHERE UPPER(ml.MOIRA_LIST_NAME) LIKE 'A%' GROUP BY ml.MOIRA_LIST_NAME, ml.IS_MOIRA_MAILING_LIST, ml.IS_MOIRA_GROUP, ml.IS_NFS_GROUP, mlo.OWNER HAVING COUNT(mld.MOIRA_LIST_MEMBER) > 1000;",
    "gold_tables": [
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#MOIRA_LIST",
      "dw#sep#MOIRA_LIST_OWNER"
    ],
    "mapping": {
      "name": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "mailing list": [
        "MOIRA_LIST.IS_MOIRA_MAILING_LIST"
      ],
      "moira group": [
        "MOIRA_LIST.IS_MOIRA_GROUP"
      ],
      "NFS group": [
        "MOIRA_LIST.IS_NFS_GROUP"
      ],
      "owner": [
        "MOIRA_LIST_OWNER.OWNER"
      ],
      "people": [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ]
    },
    "join_keys": [
      [
        "MOIRA_LIST.MOIRA_LIST_KEY",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY"
      ],
      [
        "MOIRA_LIST_OWNER.MOIRA_LIST_OWNER_KEY",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_OWNER_KEY"
      ]
    ]
  },
  {
    "question": "List the mailing lists with the largest number of members and the least number of members, including their names, owners, public status, hidden status, and number of members in the list. If a mailing list has multiple owners, create a separate entry for each owner. Similarly, if multiple lists share the minimum or maximum member count, include all those lists.",
    "db_id": "dw",
    "sql": "WITH Occurrences AS ( SELECT mld.MOIRA_LIST_KEY, mld.MOIRA_LIST_OWNER_KEY, COUNT(mld.MOIRA_LIST_MEMBER) AS occurrences FROM MOIRA_LIST_DETAIL mld GROUP BY mld.MOIRA_LIST_KEY,mld.MOIRA_LIST_OWNER_KEY ) SELECT DISTINCT ml.MOIRA_LIST_NAME, mlo.OWNER, ml.IS_PUBLIC, ml.IS_HIDDEN, o.occurrences FROM Occurrences o JOIN MOIRA_LIST ml ON o.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY JOIN MOIRA_LIST_OWNER mlo ON O.MOIRA_LIST_OWNER_KEY = mlo.MOIRA_LIST_OWNER_KEY WHERE o.occurrences = (SELECT MIN(occurrences) FROM Occurrences) OR o.occurrences = (SELECT MAX(occurrences) FROM Occurrences);",
    "oracle_sql": "WITH Occurrences AS ( SELECT ml.MOIRA_LIST_NAME, mlo.OWNER, ml.IS_PUBLIC, ml.IS_HIDDEN, COUNT(mld.MOIRA_LIST_MEMBER) AS occurrences FROM MOIRA_LIST_DETAIL mld JOIN MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY JOIN MOIRA_LIST_OWNER mlo ON mld.MOIRA_LIST_OWNER_KEY = mlo.MOIRA_LIST_OWNER_KEY GROUP BY ml.MOIRA_LIST_NAME, ml.IS_PUBLIC, ml.IS_HIDDEN, mlo.OWNER ), MaxMinOccurrences AS ( SELECT MAX(occurrences) AS max_occurrences, MIN(occurrences) AS min_occurrences FROM Occurrences ) SELECT o.MOIRA_LIST_NAME, o.OWNER, o.IS_PUBLIC, o.IS_HIDDEN, o.occurrences FROM Occurrences o JOIN MaxMinOccurrences mm ON o.occurrences = mm.max_occurrences OR o.occurrences = mm.min_occurrences;",
    "gold_tables": [
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#MOIRA_LIST",
      "dw#sep#MOIRA_LIST_OWNER"
    ],
    "mapping": {
      "names": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "owners": [
        "MOIRA_LIST_OWNER.OWNER"
      ],
      "public status": [
        "MOIRA_LIST.IS_PUBLIC"
      ],
      "hidden status": [
        "MOIRA_LIST.IS_HIDDEN"
      ],
      "members": [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ]
    },
    "join_keys": [
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY",
        "MOIRA_LIST.MOIRA_LIST_KEY"
      ],
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_OWNER_KEY",
        "MOIRA_LIST_OWNER.MOIRA_LIST_OWNER_KEY"
      ]
    ]
  },
  {
    "question": "For email lists with names starting with C (case insensitive) and containing faculty who teach courses in the summer in financial aid years after 2001, provide the name of the list, the number of people in the list, and the number of faculty in the list.",
    "db_id": "dw",
    "sql": "WITH FilteredLists AS ( SELECT ml.MOIRA_LIST_KEY, ml.MOIRA_LIST_NAME FROM MOIRA_LIST ml WHERE upper(ml.MOIRA_LIST_NAME) LIKE 'C%' ) SELECT DISTINCT fl.MOIRA_LIST_NAME AS Moira_List_Name, COUNT(mld.MOIRA_LIST_MEMBER) AS Member_Count, COUNT(DISTINCT ed.MIT_ID) AS Distinct_Faculty_Count FROM COURSE_CATALOG_SUBJECT_OFFERED ccso JOIN EMPLOYEE_DIRECTORY ed ON ccso.RESPONSIBLE_FACULTY_MIT_ID = ed.MIT_ID JOIN MOIRA_LIST_DETAIL mld ON UPPER(ed.KRB_NAME) = UPPER(mld.MOIRA_LIST_MEMBER) JOIN FilteredLists fl ON mld.MOIRA_LIST_KEY = fl.MOIRA_LIST_KEY JOIN ACADEMIC_TERMS at ON ccso.TERM_CODE = at.TERM_CODE WHERE at.TERM_CODE LIKE '%SU' AND CAST(at.FINANCIAL_AID_YEAR AS UNSIGNED) > 2001 GROUP BY fl.MOIRA_LIST_NAME;",
    "oracle_sql": "WITH FilteredLists AS ( SELECT ml.MOIRA_LIST_KEY, ml.MOIRA_LIST_NAME FROM MOIRA_LIST ml WHERE upper(ml.MOIRA_LIST_NAME) LIKE 'C%' ) SELECT DISTINCT fl.MOIRA_LIST_NAME AS Moira_List_Name, COUNT(mld.MOIRA_LIST_MEMBER) AS Member_Count, COUNT(DISTINCT ed.MIT_ID) AS Distinct_Faculty_Count FROM COURSE_CATALOG_SUBJECT_OFFERED ccso JOIN EMPLOYEE_DIRECTORY ed ON ccso.RESPONSIBLE_FACULTY_MIT_ID = ed.MIT_ID JOIN MOIRA_LIST_DETAIL mld ON UPPER(ed.KRB_NAME) = UPPER(mld.MOIRA_LIST_MEMBER) JOIN FilteredLists fl ON mld.MOIRA_LIST_KEY = fl.MOIRA_LIST_KEY JOIN ACADEMIC_TERMS at ON ccso.TERM_CODE = at.TERM_CODE WHERE at.TERM_CODE LIKE '%SU' AND CAST(at.FINANCIAL_AID_YEAR AS UNSIGNED) > 2001 GROUP BY fl.MOIRA_LIST_NAME;",
    "gold_tables": [
      "dw#sep#MOIRA_LIST",
      "dw#sep#COURSE_CATALOG_SUBJECT_OFFERED",
      "dw#sep#EMPLOYEE_DIRECTORY",
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#ACADEMIC_TERMS"
    ],
    "mapping": {
      "names": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "faculty": [
        "EMPLOYEE_DIRECTORY.MIT_ID"
      ],
      "courses in the summer": [
        "ACADEMIC_TERMS.TERM_CODE"
      ],
      "financial aid years": [
        "ACADEMIC_TERMS.FINANCIAL_AID_YEAR"
      ],
      "people": [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ]
    },
    "join_keys": [
      [
        "EMPLOYEE_DIRECTORY.MIT_ID",
        "COURSE_CATALOG_SUBJECT_OFFERED.RESPONSIBLE_FACULTY_MIT_ID"
      ],
      [
        "ACADEMIC_TERMS.TERM_CODE",
        "COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE"
      ]
    ]
  },
  {
    "question": "Regarding the mailing list about duo users, provide the number of students in this list, and the number of departments and schools associated with these students.",
    "db_id": "dw",
    "sql": "SELECT COUNT(DISTINCT se.MIT_ID) AS Student_Count, COUNT(DISTINCT sd.DEPARTMENT_CODE) AS Department_Count, COUNT(DISTINCT sd.SCHOOL_CODE) AS School_Count FROM MOIRA_LIST ml JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY JOIN SE_PERSON se ON upper(mld.MOIRA_LIST_MEMBER) = upper(se.KRB_NAME) JOIN MIT_STUDENT_DIRECTORY msd ON msd.FULL_NAME = se.FULL_NAME JOIN SIS_DEPARTMENT sd ON msd.DEPARTMENT = sd.DEPARTMENT_CODE WHERE ml.MOIRA_LIST_NAME = 'candle-duo-users'",
    "oracle_sql": "SELECT COUNT(DISTINCT se.MIT_ID) AS Student_Count, COUNT(DISTINCT sd.DEPARTMENT_CODE) AS Department_Count, COUNT(DISTINCT sd.SCHOOL_CODE) AS School_Count FROM MOIRA_LIST ml JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY JOIN SE_PERSON se ON upper(mld.MOIRA_LIST_MEMBER) = upper(se.KRB_NAME) JOIN MIT_STUDENT_DIRECTORY msd ON msd.FULL_NAME = se.FULL_NAME JOIN SIS_DEPARTMENT sd ON msd.DEPARTMENT = sd.DEPARTMENT_CODE WHERE ml.MOIRA_LIST_NAME = 'candle-duo-users'",
    "gold_tables": [
      "dw#sep#MOIRA_LIST",
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#SE_PERSON",
      "dw#sep#MIT_STUDENT_DIRECTORY",
      "dw#sep#SIS_DEPARTMENT"
    ],
    "mapping": {
      "duo users": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "students": [
        "SE_PERSON.MIT_ID"
      ],
      "departments": [
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ],
      "schools": [
        "SIS_DEPARTMENT.SCHOOL_CODE"
      ]
    },
    "join_keys": [
      [
        "MOIRA_LIST.MOIRA_LIST_KEY",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY"
      ],
      [
        "MIT_STUDENT_DIRECTORY.DEPARTMENT",
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ]
    ]
  },
  {
    "question": "For faculty who are responsible for courses in 2023 fall term, list the name of mailing lists with ten members that they subscribe to, the number of faculty in these lists, and the number of courses associated with those faculty.",
    "db_id": "dw",
    "sql": "WITH filtered_lists AS ( SELECT mld.MOIRA_LIST_KEY FROM MOIRA_LIST_DETAIL mld GROUP BY mld.MOIRA_LIST_KEY HAVING COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) = 10 ), instructor_courses AS ( SELECT fl.MOIRA_LIST_KEY, ccso.RESPONSIBLE_FACULTY_MIT_ID, COUNT(DISTINCT ccso.SUBJECT_TITLE) AS course_count FROM filtered_lists fl JOIN MOIRA_LIST_DETAIL mld ON fl.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY JOIN employee_directory ed ON UPPER(mld.MOIRA_LIST_MEMBER) = UPPER(ed.KRB_NAME) JOIN COURSE_CATALOG_SUBJECT_OFFERED ccso ON ed.MIT_ID = ccso.RESPONSIBLE_FACULTY_MIT_ID WHERE ccso.TERM_CODE = '2023FA' GROUP BY fl.MOIRA_LIST_KEY, ccso.RESPONSIBLE_FACULTY_MIT_ID ), instructor_counts AS ( SELECT MOIRA_LIST_KEY, COUNT(DISTINCT RESPONSIBLE_FACULTY_MIT_ID) AS instructor_count, SUM(course_count) AS total_courses FROM instructor_courses GROUP BY MOIRA_LIST_KEY ) SELECT ml.MOIRA_LIST_NAME, ic.instructor_count, ic.total_courses FROM instructor_counts ic JOIN MOIRA_LIST ml ON ic.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY WHERE ic.instructor_count > 0;",
    "oracle_sql": "WITH rel_lists AS (SELECT DISTINCT ml.MOIRA_LIST_KEY AS MOIRA_LIST_KEY, ccso.RESPONSIBLE_FACULTY_MIT_ID, ccso.RESPONSIBLE_FACULTY_NAME AS RESPONSIBLE_FACULTY_NAME FROM COURSE_CATALOG_SUBJECT_OFFERED ccso JOIN SE_PERSON se ON ccso.RESPONSIBLE_FACULTY_MIT_ID = se.MIT_ID JOIN MOIRA_LIST_DETAIL mld ON UPPER(se.KRB_NAME) = UPPER(mld.MOIRA_LIST_MEMBER) JOIN MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY WHERE ccso.TERM_CODE = '2023FA'), membership AS (SELECT ml.MOIRA_LIST_KEY AS moira_list_name, COUNT(*) AS membership_num FROM MOIRA_LIST ml JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY JOIN (SELECT DISTINCT MOIRA_LIST_KEY FROM rel_lists) rl ON rl.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY GROUP BY ml.MOIRA_LIST_KEY HAVING COUNT(*) = 10), course_count AS (SELECT ccso.RESPONSIBLE_FACULTY_MIT_ID, ccso.RESPONSIBLE_FACULTY_NAME AS RESPONSIBLE_FACULTY_NAME, COUNT(DISTINCT ccso.SUBJECT_TITLE) AS course_count FROM COURSE_CATALOG_SUBJECT_OFFERED ccso GROUP BY ccso.RESPONSIBLE_FACULTY_MIT_ID, ccso.RESPONSIBLE_FACULTY_NAME) SELECT ml.MOIRA_LIST_NAME AS moira_list_name, COUNT(DISTINCT rl.RESPONSIBLE_FACULTY_MIT_ID) AS faculty_count, SUM(cct.course_count) AS total_courses FROM membership m JOIN rel_lists rl ON rl.MOIRA_LIST_KEY = m.moira_list_name JOIN course_count cct ON rl.RESPONSIBLE_FACULTY_MIT_ID = cct.RESPONSIBLE_FACULTY_MIT_ID JOIN MOIRA_LIST ml ON m.moira_list_name = ml.MOIRA_LIST_KEY GROUP BY ml.MOIRA_LIST_NAME;",
    "gold_tables": [
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#EMPLOYEE_DIRECTORY",
      "dw#sep#COURSE_CATALOG_SUBJECT_OFFERED",
      "dw#sep#MOIRA_LIST"
    ],
    "mapping": {
      "faculty": [
        "COURSE_CATALOG_SUBJECT_OFFERED.RESPONSIBLE_FACULTY_MIT_ID"
      ],
      "2023 fall term": [
        "COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE"
      ],
      "name of mailing lists": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "members": [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ],
      "courses": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_TITLE"
      ]
    },
    "join_keys": [
      [
        "employee_directory.MIT_ID",
        "COURSE_CATALOG_SUBJECT_OFFERED.RESPONSIBLE_FACULTY_MIT_ID"
      ],
      [
        "employee_directory.KRB_NAME",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ],
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY",
        "MOIRA_LIST.MOIRA_LIST_KEY"
      ]
    ]
  },
  {
    "question": "For each course instructor in the 'keeper-zephyr' mailing list, provide the name of mailing lists they subscribe to, instructor name, earliest and latest publication years, and total number of enrolled students.",
    "db_id": "dw",
    "sql": "WITH FilteredLists AS ( SELECT ml.MOIRA_LIST_KEY, ml.MOIRA_LIST_NAME, mld.MOIRA_LIST_MEMBER FROM MOIRA_LIST ml JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY WHERE ml.MOIRA_LIST_NAME='keeper-zephyr' ) SELECT fl.MOIRA_LIST_NAME, lci.INSTRUCTOR_NAME, MIN(lrc.CATALOG_YEAR) AS Min_Publication_Year, MAX(lrc.CATALOG_YEAR) AS Max_Publication_Year, SUM(lso.NUM_ENROLLED_STUDENTS) AS Total_Enrolled_Students FROM LIBRARY_COURSE_INSTRUCTOR lci JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lci.LIBRARY_COURSE_INSTRUCTOR_KEY = lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY JOIN LIBRARY_RESERVE_CATALOG lrc ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY JOIN LIBRARY_SUBJECT_OFFERED lso ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY JOIN SE_PERSON se ON lci.INSTRUCTOR_NAME = se.FULL_NAME JOIN FilteredLists fl ON UPPER(se.KRB_NAME) = UPPER(fl.MOIRA_LIST_MEMBER) GROUP BY fl.MOIRA_LIST_NAME, lci.INSTRUCTOR_NAME;",
    "oracle_sql": "SELECT ml.MOIRA_LIST_NAME, lci.INSTRUCTOR_NAME, MIN(lrc.CATALOG_YEAR) AS Min_Publication_Year, MAX(lrc.CATALOG_YEAR) AS Max_Publication_Year, SUM(lso.NUM_ENROLLED_STUDENTS) AS Total_Enrolled_Students FROM LIBRARY_COURSE_INSTRUCTOR lci JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lci.LIBRARY_COURSE_INSTRUCTOR_KEY = lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY JOIN LIBRARY_RESERVE_CATALOG lrc ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY JOIN LIBRARY_SUBJECT_OFFERED lso ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY JOIN SE_PERSON se ON lci.INSTRUCTOR_NAME = se.FULL_NAME JOIN MOIRA_LIST_DETAIL mld ON UPPER(se.KRB_NAME) = UPPER(mld.MOIRA_LIST_MEMBER) JOIN MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY WHERE ml.MOIRA_LIST_NAME = 'keeper-zephyr' GROUP BY ml.MOIRA_LIST_NAME, lci.INSTRUCTOR_NAME;",
    "gold_tables": [
      "dw#sep#MOIRA_LIST",
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#LIBRARY_COURSE_INSTRUCTOR",
      "dw#sep#LIBRARY_RESERVE_MATRL_DETAIL",
      "dw#sep#LIBRARY_RESERVE_CATALOG",
      "dw#sep#LIBRARY_SUBJECT_OFFERED",
      "dw#sep#SE_PERSON"
    ],
    "mapping": {
      "'keeper-zephyr' mailing list": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "name of mailing lists": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "instructor name": [
        "LIBRARY_COURSE_INSTRUCTOR.INSTRUCTOR_NAME"
      ],
      "publication years": [
        "LIBRARY_RESERVE_CATALOG.CATALOG_YEAR"
      ],
      "enrolled students": [
        "LIBRARY_SUBJECT_OFFERED.NUM_ENROLLED_STUDENTS"
      ]
    },
    "join_keys": [
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_COURSE_INSTRUCTOR_KEY",
        "LIBRARY_COURSE_INSTRUCTOR.LIBRARY_COURSE_INSTRUCTOR_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_RESERVE_CATALOG_KEY",
        "LIBRARY_RESERVE_CATALOG.LIBRARY_RESERVE_CATALOG_KEY"
      ],
      [
        "LIBRARY_SUBJECT_OFFERED.LIBRARY_SUBJECT_OFFERED_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_SUBJECT_OFFERED_KEY"
      ],
      [
        "LIBRARY_COURSE_INSTRUCTOR.INSTRUCTOR_NAME",
        "SE_PERSON.FULL_NAME"
      ]
    ]
  },
  {
    "question": "For each mailing list with a name beginning with R (case insensitive), and that Professor Ayden Hopkins is subscribed to, list its name, description, owner, number of people in the list, and number of tenured faculty in the list.",
    "db_id": "dw",
    "sql": "WITH FilteredLists AS ( SELECT DISTINCT ml.MOIRA_LIST_KEY, ml.MOIRA_LIST_NAME, ml.MOIRA_LIST_DESCRIPTION, mlo.OWNER FROM SE_PERSON se JOIN MOIRA_LIST_DETAIL mld ON UPPER(se.KRB_NAME) = UPPER(mld.MOIRA_LIST_MEMBER) JOIN MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY JOIN MOIRA_LIST_OWNER mlo ON mld.MOIRA_LIST_OWNER_KEY = mlo.MOIRA_LIST_OWNER_KEY WHERE se.FULL_NAME = 'Hopkins, Ayden' AND UPPER(ml.MOIRA_LIST_NAME) LIKE 'R%' ), MemberCounts AS ( SELECT fl.MOIRA_LIST_KEY, fl.MOIRA_LIST_NAME, fl.MOIRA_LIST_DESCRIPTION, fl.OWNER, COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) AS Member_Count FROM FilteredLists fl JOIN MOIRA_LIST_DETAIL mld ON fl.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY GROUP BY fl.MOIRA_LIST_KEY, fl.MOIRA_LIST_NAME, fl.MOIRA_LIST_DESCRIPTION, fl.OWNER ), FacultyTenuredCounts AS ( SELECT fl.MOIRA_LIST_KEY, COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) AS Faculty_Tenured_Count FROM FilteredLists fl JOIN MOIRA_LIST_DETAIL mld ON fl.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY JOIN SE_PERSON se ON UPPER(mld.MOIRA_LIST_MEMBER) = UPPER(se.KRB_NAME) WHERE se.PAYROLL_RANK = 'Faculty Tenured' GROUP BY fl.MOIRA_LIST_KEY ) SELECT DISTINCT mc.MOIRA_LIST_NAME, mc.MOIRA_LIST_DESCRIPTION, mc.OWNER, mc.Member_Count, COALESCE(ftc.Faculty_Tenured_Count, 0) AS Faculty_Tenured_Count FROM MemberCounts mc LEFT JOIN FacultyTenuredCounts ftc ON mc.MOIRA_LIST_KEY = ftc.MOIRA_LIST_KEY ORDER BY mc.Member_Count DESC;",
    "oracle_sql": "WITH MemberCounts AS ( SELECT ml.MOIRA_LIST_NAME, COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) AS Member_Count FROM SE_PERSON se JOIN MOIRA_LIST_DETAIL mld ON upper(se.KRB_NAME) = upper(mld.MOIRA_LIST_MEMBER) JOIN MOIRA_LIST_OWNER mlo ON mld.MOIRA_LIST_OWNER_KEY = mlo.MOIRA_LIST_OWNER_KEY JOIN MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY WHERE ml.MOIRA_LIST_NAME IN ( SELECT DISTINCT ml_sub.MOIRA_LIST_NAME FROM SE_PERSON se_sub JOIN MOIRA_LIST_DETAIL mld_sub ON upper(se_sub.KRB_NAME) = upper(mld_sub.MOIRA_LIST_MEMBER) JOIN MOIRA_LIST ml_sub ON mld_sub.MOIRA_LIST_KEY = ml_sub.MOIRA_LIST_KEY WHERE se_sub.FULL_NAME = 'Hopkins, Ayden' ) GROUP BY ml.MOIRA_LIST_NAME ), FacultyTenuredCounts AS ( SELECT ml.MOIRA_LIST_NAME, COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) AS Faculty_Tenured_Count FROM SE_PERSON se JOIN MOIRA_LIST_DETAIL mld ON upper(se.KRB_NAME) = upper(mld.MOIRA_LIST_MEMBER) JOIN MOIRA_LIST_OWNER mlo ON mld.MOIRA_LIST_OWNER_KEY = mlo.MOIRA_LIST_OWNER_KEY JOIN MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY WHERE ml.MOIRA_LIST_NAME IN ( SELECT DISTINCT ml_sub.MOIRA_LIST_NAME FROM SE_PERSON se_sub JOIN MOIRA_LIST_DETAIL mld_sub ON upper(se_sub.KRB_NAME) = upper(mld_sub.MOIRA_LIST_MEMBER) JOIN MOIRA_LIST ml_sub ON mld_sub.MOIRA_LIST_KEY = ml_sub.MOIRA_LIST_KEY WHERE se_sub.FULL_NAME = 'Hopkins, Ayden' ) AND se.PAYROLL_RANK = 'Faculty Tenured' GROUP BY ml.MOIRA_LIST_NAME ) SELECT DISTINCT mc.MOIRA_LIST_NAME, ml.MOIRA_LIST_DESCRIPTION, mlo.OWNER, mc.Member_Count, COALESCE(ftc.Faculty_Tenured_Count, 0) AS Faculty_Tenured_Count FROM MemberCounts mc LEFT JOIN FacultyTenuredCounts ftc ON mc.MOIRA_LIST_NAME = ftc.MOIRA_LIST_NAME JOIN MOIRA_LIST ml ON mc.MOIRA_LIST_NAME = ml.MOIRA_LIST_NAME JOIN MOIRA_LIST_DETAIL mld ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY JOIN MOIRA_LIST_OWNER mlo ON MLD.MOIRA_LIST_OWNER_KEY = mlo.MOIRA_LIST_OWNER_KEY WHERE UPPER(ml.MOIRA_LIST_NAME) LIKE 'C%' ORDER BY mc.Member_Count DESC;",
    "gold_tables": [
      "dw#sep#SE_PERSON",
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#MOIRA_LIST",
      "dw#sep#MOIRA_LIST_OWNER"
    ],
    "mapping": {
      "name": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "Professor Ayden Hopkins": [
        "SE_PERSON.FULL_NAME"
      ],
      "description": [
        "MOIRA_LIST.MOIRA_LIST_DESCRIPTION"
      ],
      "owner": [
        "MOIRA_LIST_OWNER.OWNER"
      ],
      "people": [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ],
      "tenured faculty": [
        "SE_PERSON.PAYROLL_RANK",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ]
    },
    "join_keys": [
      [
        "MOIRA_LIST.MOIRA_LIST_KEY",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY"
      ],
      [
        "MOIRA_LIST_OWNER.MOIRA_LIST_OWNER_KEY",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_OWNER_KEY"
      ]
    ]
  },
  {
    "question": "For the email list with name 'date-destiny', list the name of the list, department name, the number of students from the Management department, and the percentage of students who are from the Management department, rounded to two decimal places.",
    "db_id": "dw",
    "sql": "WITH FilteredList AS ( SELECT MOIRA_LIST_KEY, MOIRA_LIST_NAME FROM MOIRA_LIST WHERE MOIRA_LIST_NAME = 'date-destiny' ), FilteredListDetails AS ( SELECT mld.MOIRA_LIST_KEY, mld.MOIRA_LIST_MEMBER FROM MOIRA_LIST_DETAIL mld JOIN FilteredList fl ON mld.MOIRA_LIST_KEY = fl.MOIRA_LIST_KEY ) SELECT ml.MOIRA_LIST_NAME, COUNT(CASE WHEN UPPER(ad.SIS_ADMIN_DEPARTMENT_NAME) = 'MANAGEMENT' THEN 1 ELSE NULL END) AS MANAGEMENT_STUDENT_COUNT, ROUND( COUNT(CASE WHEN UPPER(ad.SIS_ADMIN_DEPARTMENT_NAME) = 'MANAGEMENT' THEN 1 ELSE NULL END) * 100.0 / COUNT(fld.MOIRA_LIST_MEMBER), 2 ) AS MANAGEMENT_STUDENT_PERCENTAGE FROM MIT_STUDENT_DIRECTORY msd JOIN SE_PERSON se ON msd.FULL_NAME = se.FULL_NAME JOIN FilteredListDetails fld ON UPPER(se.KRB_NAME) = UPPER(fld.MOIRA_LIST_MEMBER) JOIN FilteredList ml ON fld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY LEFT JOIN SIS_ADMIN_DEPARTMENT ad ON msd.DEPARTMENT = ad.SIS_ADMIN_DEPARTMENT_CODE GROUP BY ml.MOIRA_LIST_NAME;",
    "oracle_sql": "WITH FilteredList AS ( SELECT MOIRA_LIST_KEY, MOIRA_LIST_NAME FROM MOIRA_LIST WHERE MOIRA_LIST_NAME = 'date-destiny' ), FilteredListDetails AS ( SELECT mld.MOIRA_LIST_KEY, mld.MOIRA_LIST_MEMBER FROM MOIRA_LIST_DETAIL mld JOIN FilteredList fl ON mld.MOIRA_LIST_KEY = fl.MOIRA_LIST_KEY ) SELECT ml.MOIRA_LIST_NAME, COUNT(CASE WHEN UPPER(ad.SIS_ADMIN_DEPARTMENT_NAME) = 'MANAGEMENT' THEN 1 ELSE NULL END) AS MANAGEMENT_STUDENT_COUNT, ROUND( COUNT(CASE WHEN UPPER(ad.SIS_ADMIN_DEPARTMENT_NAME) = 'MANAGEMENT' THEN 1 ELSE NULL END) * 100.0 / COUNT(fld.MOIRA_LIST_MEMBER), 2 ) AS MANAGEMENT_STUDENT_PERCENTAGE FROM MIT_STUDENT_DIRECTORY msd JOIN SE_PERSON se ON msd.FULL_NAME = se.FULL_NAME JOIN FilteredListDetails fld ON UPPER(se.KRB_NAME) = UPPER(fld.MOIRA_LIST_MEMBER) JOIN FilteredList ml ON fld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY LEFT JOIN SIS_ADMIN_DEPARTMENT ad ON msd.DEPARTMENT = ad.SIS_ADMIN_DEPARTMENT_CODE GROUP BY ml.MOIRA_LIST_NAME;",
    "gold_tables": [
      "dw#sep#MOIRA_LIST",
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#MIT_STUDENT_DIRECTORY",
      "dw#sep#SE_PERSON",
      "dw#sep#SIS_ADMIN_DEPARTMENT"
    ],
    "mapping": {
      "name": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "department name": [
        "SIS_ADMIN_DEPARTMENT.SIS_ADMIN_DEPARTMENT_NAME"
      ],
      "students": [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ],
      "Management department": [
        "SIS_ADMIN_DEPARTMENT.SIS_ADMIN_DEPARTMENT_NAME"
      ]
    },
    "join_keys": [
      [
        "SE_PERSON.FULL_NAME",
        "MIT_STUDENT_DIRECTORY.FULL_NAME"
      ],
      [
        "SE_PERSON.KRB_NAME",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ],
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY",
        "MOIRA_LIST.MOIRA_LIST_KEY"
      ],
      [
        "MIT_STUDENT_DIRECTORY.DEPARTMENT",
        "SIS_ADMIN_DEPARTMENT.SIS_ADMIN_DEPARTMENT_CODE"
      ]
    ]
  },
  {
    "question": "For the building with the most floors, list the building name and the names of the mailing lists staring with a (case insensitive) that the building employees with kerberos starting with c (case insensitive) subscribe to.",
    "db_id": "dw",
    "sql": "WITH FilteredMoiraLists AS ( SELECT MOIRA_LIST_KEY, MOIRA_LIST_NAME FROM MOIRA_LIST WHERE MOIRA_LIST_NAME LIKE 'a%' ), FilteredMoiraListDetails AS ( SELECT mld.MOIRA_LIST_MEMBER, mld.MOIRA_LIST_KEY FROM MOIRA_LIST_DETAIL mld JOIN FilteredMoiraLists fml ON mld.MOIRA_LIST_KEY = fml.MOIRA_LIST_KEY ), FloorsWithLevels AS ( SELECT fb.BUILDING_NAME, MAX(ff.LEVEL_ID) OVER (PARTITION BY ff.BUILDING_KEY) AS MAX_LEVEL, MIN(ff.LEVEL_ID) OVER (PARTITION BY ff.BUILDING_KEY) AS MIN_LEVEL FROM FAC_BUILDING fb JOIN FAC_ROOMS fr ON fb.FAC_BUILDING_KEY = fr.BUILDING_KEY JOIN FAC_FLOOR ff ON fr.FLOOR_KEY = ff.FLOOR_KEY ), FloorsPerBuilding AS ( SELECT BUILDING_NAME, MAX_LEVEL - MIN_LEVEL + 1 AS NUM_FLOORS FROM FloorsWithLevels GROUP BY BUILDING_NAME, MAX_LEVEL, MIN_LEVEL ), MaxFloors AS ( SELECT MAX(NUM_FLOORS) AS MAX_FLOORS FROM FloorsPerBuilding ), BuildingWithMostFloors AS ( SELECT a.BUILDING_NAME FROM FloorsPerBuilding a JOIN MaxFloors b ON a.NUM_FLOORS = b.MAX_FLOORS ), EmployeesInTallestBuildings AS ( SELECT DISTINCT UPPER(e.KRB_NAME) AS KRB_NAME, fb.building_name FROM BuildingWithMostFloors b JOIN FAC_BUILDING fb ON b.BUILDING_NAME = fb.BUILDING_NAME JOIN FAC_ROOMS fr ON fb.FAC_BUILDING_KEY = fr.BUILDING_KEY JOIN EMPLOYEE_DIRECTORY e ON e.OFFICE_LOCATION = fr.FAC_ROOM_KEY WHERE upper(e.KRB_NAME) LIKE 'C%' ) SELECT DISTINCT etb.BUILDING_NAME, fml.MOIRA_LIST_NAME FROM EmployeesInTallestBuildings etb JOIN FilteredMoiraListDetails fmld ON UPPER(etb.KRB_NAME) = UPPER(fmld.MOIRA_LIST_MEMBER) JOIN FilteredMoiraLists fml ON fmld.MOIRA_LIST_KEY = fml.MOIRA_LIST_KEY;",
    "oracle_sql": "WITH FloorsWithLevels AS (SELECT fb.BUILDING_NAME, e.FULL_NAME, ml.MOIRA_LIST_NAME, e.KRB_NAME, MAX(ff.LEVEL_ID) OVER (PARTITION BY ff.BUILDING_KEY) AS MAX_LEVEL, MIN(ff.LEVEL_ID) OVER (PARTITION BY ff.BUILDING_KEY) AS MIN_LEVEL FROM FAC_BUILDING fb JOIN FAC_ROOMS fr ON fb.FAC_BUILDING_KEY = fr.BUILDING_KEY JOIN FAC_FLOOR ff ON fr.FLOOR_KEY = ff.FLOOR_KEY JOIN EMPLOYEE_DIRECTORY e ON e.OFFICE_LOCATION = fr.FAC_ROOM_KEY JOIN MOIRA_LIST_DETAIL mld ON e.KRB_NAME = mld.MOIRA_LIST_MEMBER JOIN MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY), FloorsPerBuilding AS (SELECT BUILDING_NAME, FULL_NAME, MOIRA_LIST_NAME, KRB_NAME, MAX_LEVEL - MIN_LEVEL AS NUM_FLOORS FROM FloorsWithLevels GROUP BY BUILDING_NAME, FULL_NAME, MOIRA_LIST_NAME, KRB_NAME, MAX_LEVEL, MIN_LEVEL), MaxFloors AS (SELECT MAX(NUM_FLOORS) AS MAX_FLOORS FROM FloorsPerBuilding) SELECT a.BUILDING_NAME, a.MOIRA_LIST_NAME FROM FloorsPerBuilding a JOIN MaxFloors b ON a.NUM_FLOORS = b.MAX_FLOORS WHERE LOWER(a.MOIRA_LIST_NAME) LIKE 'a%' AND LOWER(a.KRB_NAME) LIKE 'c%';",
    "gold_tables": [
      "dw#sep#MOIRA_LIST",
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#FAC_BUILDING",
      "dw#sep#FAC_ROOMS",
      "dw#sep#FAC_FLOOR",
      "dw#sep#EMPLOYEE_DIRECTORY"
    ],
    "mapping": {
      "floors": [
        "FAC_FLOOR.LEVEL_ID"
      ],
      "building name": [
        "FAC_BUILDING.BUILDING_NAME"
      ],
      "names of the mailing lists": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "kerberos": [
        "EMPLOYEE_DIRECTORY.KRB_NAME"
      ]
    },
    "join_keys": [
      [
        "FAC_ROOMS.BUILDING_KEY",
        "FAC_BUILDING.FAC_BUILDING_KEY"
      ],
      [
        "FAC_FLOOR.FLOOR_KEY",
        "FAC_ROOMS.FLOOR_KEY"
      ],
      [
        "FAC_ROOMS.FAC_ROOM_KEY",
        "EMPLOYEE_DIRECTORY.OFFICE_LOCATION"
      ],
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER",
        "EMPLOYEE_DIRECTORY.KRB_NAME"
      ],
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY",
        "MOIRA_LIST.MOIRA_LIST_KEY"
      ]
    ]
  },
  {
    "question": "For the email lists subscribed by faculty members with last names begin with Y, list the names of the lists, the total number of subjects managed by faculty in those mailing lists, and the number of such faculty in the lists.",
    "db_id": "dw",
    "sql": "SELECT DISTINCT ml.MOIRA_LIST_NAME, COUNT(ccso.SUBJECT_ID) AS course_count, COUNT(DISTINCT ccso.RESPONSIBLE_FACULTY_NAME) AS distinct_faculty_count FROM COURSE_CATALOG_SUBJECT_OFFERED CCSO JOIN EMPLOYEE_DIRECTORY E ON ccso.RESPONSIBLE_FACULTY_MIT_ID = E.MIT_ID JOIN MOIRA_LIST_DETAIL mld ON upper(e.KRB_NAME_UPPERCASE) = upper(mld.MOIRA_LIST_MEMBER) JOIN MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY WHERE ccso.RESPONSIBLE_FACULTY_NAME LIKE 'Y%' GROUP BY ML.MOIRA_LIST_NAME",
    "oracle_sql": "SELECT DISTINCT ml.MOIRA_LIST_NAME, COUNT(ccso.SUBJECT_ID) AS course_count, COUNT(DISTINCT ccso.RESPONSIBLE_FACULTY_NAME) AS distinct_faculty_count FROM COURSE_CATALOG_SUBJECT_OFFERED CCSO JOIN EMPLOYEE_DIRECTORY E ON ccso.RESPONSIBLE_FACULTY_MIT_ID = E.MIT_ID JOIN MOIRA_LIST_DETAIL mld ON upper(e.KRB_NAME_UPPERCASE) = upper(mld.MOIRA_LIST_MEMBER) JOIN MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY WHERE ccso.RESPONSIBLE_FACULTY_NAME LIKE 'Y%' GROUP BY ML.MOIRA_LIST_NAME",
    "gold_tables": [
      "dw#sep#COURSE_CATALOG_SUBJECT_OFFERED",
      "dw#sep#EMPLOYEE_DIRECTORY",
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#MOIRA_LIST"
    ],
    "mapping": {
      "last names": [
        "COURSE_CATALOG_SUBJECT_OFFERED.RESPONSIBLE_FACULTY_NAME"
      ],
      "names of the lists": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "subjects": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID"
      ],
      "faculty": [
        "COURSE_CATALOG_SUBJECT_OFFERED.RESPONSIBLE_FACULTY_NAME"
      ]
    },
    "join_keys": [
      [
        "COURSE_CATALOG_SUBJECT_OFFERED.RESPONSIBLE_FACULTY_MIT_ID",
        "EMPLOYEE_DIRECTORY.MIT_ID"
      ]
    ]
  },
  {
    "question": "For students with last names starting with H who are subscribed to mailing list 'beacon-date-date', list the names of the students, the phone numbers of departments they belong to, and the size of the mailing list 'beacon-date-date' that they are subscribed to.",
    "db_id": "dw",
    "sql": "WITH FilteredMoiraLists AS ( SELECT MOIRA_LIST_KEY, MOIRA_LIST_NAME FROM MOIRA_LIST WHERE MOIRA_LIST_NAME = 'beacon-date-date' ), FilteredMoiraListDetails AS ( SELECT mld.MOIRA_LIST_MEMBER, mld.MOIRA_LIST_KEY FROM MOIRA_LIST_DETAIL mld JOIN FilteredMoiraLists fml ON mld.MOIRA_LIST_KEY = fml.MOIRA_LIST_KEY ), MailingListSizes AS ( SELECT fml.MOIRA_LIST_KEY, fml.MOIRA_LIST_NAME, COUNT(fmld.MOIRA_LIST_MEMBER) AS List_Size FROM FilteredMoiraLists fml JOIN FilteredMoiraListDetails fmld ON fml.MOIRA_LIST_KEY = fmld.MOIRA_LIST_KEY GROUP BY fml.MOIRA_LIST_KEY, fml.MOIRA_LIST_NAME ) SELECT msd.FULL_NAME AS Student_Name, sad.DEPARTMENT_PHONE_NUMBER, MLS.List_Size AS List_Size FROM MIT_STUDENT_DIRECTORY msd JOIN SIS_DEPARTMENT sd ON msd.DEPARTMENT = sd.DEPARTMENT_CODE JOIN SIS_ADMIN_DEPARTMENT sad ON sd.DEPARTMENT_CODE = sad.SIS_ADMIN_DEPARTMENT_CODE JOIN SE_PERSON se ON msd.FULL_NAME = se.FULL_NAME JOIN FilteredMoiraListDetails fmld ON UPPER(se.KRB_NAME) = UPPER(fmld.MOIRA_LIST_MEMBER) JOIN FilteredMoiraLists fml ON fmld.MOIRA_LIST_KEY = fml.MOIRA_LIST_KEY JOIN MailingListSizes MLS ON fml.MOIRA_LIST_KEY = MLS.MOIRA_LIST_KEY WHERE msd.LAST_NAME LIKE 'H%';",
    "oracle_sql": "WITH FilteredMoiraLists AS ( SELECT MOIRA_LIST_KEY, MOIRA_LIST_NAME FROM MOIRA_LIST WHERE MOIRA_LIST_NAME = 'beacon-date-date' ), FilteredMoiraListDetails AS ( SELECT mld.MOIRA_LIST_MEMBER, mld.MOIRA_LIST_KEY FROM MOIRA_LIST_DETAIL mld JOIN FilteredMoiraLists fml ON mld.MOIRA_LIST_KEY = fml.MOIRA_LIST_KEY ), MailingListSizes AS ( SELECT fml.MOIRA_LIST_KEY, fml.MOIRA_LIST_NAME, COUNT(fmld.MOIRA_LIST_MEMBER) AS List_Size FROM FilteredMoiraLists fml JOIN FilteredMoiraListDetails fmld ON fml.MOIRA_LIST_KEY = fmld.MOIRA_LIST_KEY GROUP BY fml.MOIRA_LIST_KEY, fml.MOIRA_LIST_NAME ) SELECT msd.FULL_NAME AS Student_Name, sad.DEPARTMENT_PHONE_NUMBER, MLS.List_Size AS List_Size FROM MIT_STUDENT_DIRECTORY msd JOIN SIS_DEPARTMENT sd ON msd.DEPARTMENT = sd.DEPARTMENT_CODE JOIN SIS_ADMIN_DEPARTMENT sad ON sd.DEPARTMENT_CODE = sad.SIS_ADMIN_DEPARTMENT_CODE JOIN SE_PERSON se ON msd.FULL_NAME = se.FULL_NAME JOIN FilteredMoiraListDetails fmld ON UPPER(se.KRB_NAME) = UPPER(fmld.MOIRA_LIST_MEMBER) JOIN FilteredMoiraLists fml ON fmld.MOIRA_LIST_KEY = fml.MOIRA_LIST_KEY JOIN MailingListSizes MLS ON fml.MOIRA_LIST_KEY = MLS.MOIRA_LIST_KEY WHERE msd.LAST_NAME LIKE 'H%';",
    "gold_tables": [
      "dw#sep#MOIRA_LIST",
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#MIT_STUDENT_DIRECTORY",
      "dw#sep#SIS_DEPARTMENT",
      "dw#sep#SIS_ADMIN_DEPARTMENT",
      "dw#sep#SE_PERSON"
    ],
    "mapping": {
      "last names": [
        "MIT_STUDENT_DIRECTORY.LAST_NAME"
      ],
      "mailing list 'beacon-date-date'": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "names": [
        "MIT_STUDENT_DIRECTORY.FULL_NAME"
      ],
      "phone numbers": [
        "SIS_ADMIN_DEPARTMENT.DEPARTMENT_PHONE_NUMBER"
      ],
      "size of the mailing list": [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ]
    },
    "join_keys": [
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY",
        "MOIRA_LIST.MOIRA_LIST_KEY"
      ],
      [
        "MIT_STUDENT_DIRECTORY.DEPARTMENT",
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ],
      [
        "SIS_DEPARTMENT.DEPARTMENT_CODE",
        "SIS_ADMIN_DEPARTMENT.SIS_ADMIN_DEPARTMENT_CODE"
      ],
      [
        "MIT_STUDENT_DIRECTORY.FULL_NAME",
        "SE_PERSON.FULL_NAME"
      ],
      [
        "SE_PERSON.KRB_NAME",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ],
      [
        "MOIRA_LIST.MOIRA_LIST_KEY",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY"
      ]
    ]
  },
  {
    "question": "Give the count of mailing lists with names starting with B that include members from the Electrical Engineering and Computer Science department, along with the name of the list starting with B that have the highest number of members from that department and the corresponding member count.",
    "db_id": "dw",
    "sql": "WITH DistinctLists AS ( SELECT ml.MOIRA_LIST_NAME, COUNT(DISTINCT se.MIT_ID) AS Member_Count FROM MOIRA_LIST ml JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY JOIN SE_PERSON se ON UPPER(mld.MOIRA_LIST_MEMBER) = UPPER(se.KRB_NAME) WHERE UPPER(ml.MOIRA_LIST_NAME) LIKE 'B%' AND se.ORGANIZATION = 'Electrical Engineering-Computer Science' GROUP BY ml.MOIRA_LIST_NAME ), Moira_List_With_Most_Members AS ( SELECT MOIRA_LIST_NAME, Member_Count FROM DistinctLists WHERE Member_Count = (SELECT MAX(Member_Count) FROM DistinctLists) ) SELECT COUNT(DISTINCT dl.MOIRA_LIST_NAME) AS Moira_Lists_Start_With_B, (SELECT MOIRA_LIST_NAME FROM Moira_List_With_Most_Members LIMIT 1) AS Moira_List_With_Most_Members, (SELECT Member_Count FROM Moira_List_With_Most_Members LIMIT 1) AS Most_Number_Of_Members FROM DistinctLists dl;",
    "oracle_sql": "WITH DistinctLists AS (SELECT ml.MOIRA_LIST_NAME, COUNT(DISTINCT se.MIT_ID) AS Member_Count FROM MOIRA_LIST ml JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY JOIN MOIRA_LIST_OWNER mlo ON mld.MOIRA_LIST_OWNER_KEY = mlo.MOIRA_LIST_OWNER_KEY JOIN SE_PERSON se ON UPPER(mld.MOIRA_LIST_MEMBER) = upper(se.KRB_NAME) WHERE UPPER(ml.MOIRA_LIST_NAME) LIKE 'B%' AND se.ORGANIZATION = 'Electrical Engineering-Computer Science' GROUP BY ml.MOIRA_LIST_NAME), Moira_List_With_Most_Members AS (SELECT MOIRA_LIST_NAME FROM DistinctLists WHERE Member_Count = (SELECT MAX(Member_Count) FROM DistinctLists)) SELECT COUNT(DISTINCT dl.MOIRA_LIST_NAME) AS Moira_Lists_Start_With_B, MAX(mll.MOIRA_LIST_NAME) AS Moira_List_With_Most_Members, MAX(dl.Member_Count) AS Most_Number_Of_Members FROM DistinctLists dl LEFT JOIN Moira_List_With_Most_Members mll ON dl.MOIRA_LIST_NAME = mll.MOIRA_LIST_NAME;",
    "gold_tables": [
      "dw#sep#MOIRA_LIST",
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#SE_PERSON"
    ],
    "mapping": {
      "mailing lists": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "names": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "members": [
        "SE_PERSON.MIT_ID"
      ],
      "Electrical Engineering and Computer Science department": [
        "SE_PERSON.ORGANIZATION"
      ]
    },
    "join_keys": [
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY",
        "MOIRA_LIST.MOIRA_LIST_KEY"
      ],
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER",
        "SE_PERSON.KRB_NAME"
      ]
    ]
  },
  {
    "question": "For the 'kangaroo-inspire-yearn' email list, for each department present in the list, list the department name, the number of students in that department, and its percentage relative to the students in the mailing list.",
    "db_id": "dw",
    "sql": "WITH FilteredList AS ( SELECT MOIRA_LIST_KEY, MOIRA_LIST_NAME FROM MOIRA_LIST WHERE MOIRA_LIST_NAME = 'kangaroo-inspire-yearn' ), FilteredListDetails AS ( SELECT mld.MOIRA_LIST_KEY, mld.MOIRA_LIST_MEMBER FROM MOIRA_LIST_DETAIL mld JOIN FilteredList fl ON mld.MOIRA_LIST_KEY = fl.MOIRA_LIST_KEY ), DepartmentCounts AS ( SELECT ad.SIS_ADMIN_DEPARTMENT_NAME AS department_name, COUNT(DISTINCT fld.MOIRA_LIST_MEMBER) AS department_student_count FROM MIT_STUDENT_DIRECTORY msd JOIN SE_PERSON se ON msd.FULL_NAME = se.FULL_NAME JOIN FilteredListDetails fld ON UPPER(se.KRB_NAME) = UPPER(fld.MOIRA_LIST_MEMBER) LEFT JOIN SIS_ADMIN_DEPARTMENT ad ON msd.DEPARTMENT = ad.SIS_ADMIN_DEPARTMENT_CODE GROUP BY ad.SIS_ADMIN_DEPARTMENT_NAME ), TotalStudents AS ( SELECT COUNT(DISTINCT fld.MOIRA_LIST_MEMBER) AS total_students FROM FilteredListDetails fld ) SELECT dc.department_name, dc.department_student_count, ROUND( dc.department_student_count * 100.0 / ts.total_students, 2 ) AS department_student_percentage FROM DepartmentCounts dc, TotalStudents ts;",
    "oracle_sql": "WITH FilteredList AS ( SELECT MOIRA_LIST_KEY, MOIRA_LIST_NAME FROM MOIRA_LIST WHERE MOIRA_LIST_NAME = 'kangaroo-inspire-yearn' ), FilteredListDetails AS ( SELECT mld.MOIRA_LIST_KEY, mld.MOIRA_LIST_MEMBER FROM MOIRA_LIST_DETAIL mld JOIN FilteredList fl ON mld.MOIRA_LIST_KEY = fl.MOIRA_LIST_KEY ), DepartmentCounts AS ( SELECT ad.SIS_ADMIN_DEPARTMENT_NAME AS department_name, COUNT(DISTINCT fld.MOIRA_LIST_MEMBER) AS department_student_count FROM MIT_STUDENT_DIRECTORY msd JOIN SE_PERSON se ON msd.FULL_NAME = se.FULL_NAME JOIN FilteredListDetails fld ON UPPER(se.KRB_NAME) = UPPER(fld.MOIRA_LIST_MEMBER) LEFT JOIN SIS_ADMIN_DEPARTMENT ad ON msd.DEPARTMENT = ad.SIS_ADMIN_DEPARTMENT_CODE GROUP BY ad.SIS_ADMIN_DEPARTMENT_NAME ), TotalStudents AS ( SELECT COUNT(DISTINCT fld.MOIRA_LIST_MEMBER) AS total_students FROM FilteredListDetails fld ) SELECT dc.department_name, dc.department_student_count, ROUND( dc.department_student_count * 100.0 / ts.total_students, 2 ) AS department_student_percentage FROM DepartmentCounts dc, TotalStudents ts;",
    "gold_tables": [
      "dw#sep#MOIRA_LIST",
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#MIT_STUDENT_DIRECTORY",
      "dw#sep#SE_PERSON",
      "dw#sep#SIS_ADMIN_DEPARTMENT"
    ],
    "mapping": {
      "'kangaroo-inspire-yearn' email list": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "department name": [
        "SIS_ADMIN_DEPARTMENT.SIS_ADMIN_DEPARTMENT_NAME"
      ],
      "students": [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ]
    },
    "join_keys": [
      [
        "SE_PERSON.FULL_NAME",
        "MIT_STUDENT_DIRECTORY.FULL_NAME"
      ],
      [
        "SE_PERSON.KRB_NAME",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ],
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY",
        "MOIRA_LIST.MOIRA_LIST_KEY"
      ],
      [
        "MIT_STUDENT_DIRECTORY.DEPARTMENT",
        "SIS_ADMIN_DEPARTMENT.SIS_ADMIN_DEPARTMENT_CODE"
      ]
    ]
  },
  {
    "question": "Among the mailing lists subscribed by people with physical offices in building 24, provide the name of the most subscribed mailing list and the total number of subscribers.",
    "db_id": "dw",
    "sql": "WITH MailingListStats AS ( SELECT ml.MOIRA_LIST_NAME, COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) AS Total_Members FROM MOIRA_LIST ml JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY JOIN EMPLOYEE_DIRECTORY ed ON mld.MOIRA_LIST_MEMBER = ed.KRB_NAME WHERE ed.OFFICE_LOCATION LIKE '24%' GROUP BY ml.MOIRA_LIST_NAME ), Largest AS ( SELECT MOIRA_LIST_NAME, Total_Members, RANK() OVER (ORDER BY Total_Members DESC) AS Size_Rank FROM MailingListStats ) SELECT MAX(CASE WHEN Size_Rank = 1 THEN MOIRA_LIST_NAME END) AS Largest_Mailing_List, MAX(CASE WHEN Size_Rank = 1 THEN Total_Members END) AS Member_Count FROM Largest;",
    "oracle_sql": "WITH MailingListStats AS ( SELECT ml.MOIRA_LIST_NAME, COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) AS Total_Members FROM MOIRA_LIST ml JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY JOIN EMPLOYEE_DIRECTORY ed ON mld.MOIRA_LIST_MEMBER = ed.KRB_NAME WHERE ed.OFFICE_LOCATION LIKE '24%' GROUP BY ml.MOIRA_LIST_NAME ), Largest AS ( SELECT MOIRA_LIST_NAME, Total_Members, RANK() OVER (ORDER BY Total_Members DESC) AS Size_Rank FROM MailingListStats ) SELECT MAX(CASE WHEN Size_Rank = 1 THEN MOIRA_LIST_NAME END) AS Largest_Mailing_List, MAX(CASE WHEN Size_Rank = 1 THEN Total_Members END) AS Member_Count FROM Largest;",
    "gold_tables": [
      "dw#sep#MOIRA_LIST",
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#EMPLOYEE_DIRECTORY"
    ],
    "mapping": {
      "physical offices in building 24": [
        "EMPLOYEE_DIRECTORY.OFFICE_LOCATION"
      ],
      "name": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "subscribers": [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ]
    },
    "join_keys": [
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY",
        "MOIRA_LIST.MOIRA_LIST_KEY"
      ],
      [
        "EMPLOYEE_DIRECTORY.KRB_NAME",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ]
    ]
  },
  {
    "question": "For email lists subscribed by either support staff or faculty, list its name, the number of subscribers that are support staff, the number of subscribers that are faculty, as well as its active status.",
    "db_id": "dw",
    "sql": "SELECT ml.MOIRA_LIST_NAME, SUM(CASE WHEN se.EMPLOYEE_TYPE = 'Support Staff' THEN 1 ELSE 0 END) AS SUPPORT_COUNT, SUM(CASE WHEN se.EMPLOYEE_TYPE = 'Faculty' THEN 1 ELSE 0 END) AS FACULTY_COUNT, ml.IS_ACTIVE FROM MOIRA_LIST ml JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY JOIN SE_PERSON se ON upper(mld.MOIRA_LIST_MEMBER) = upper(se.KRB_NAME) WHERE se.EMPLOYEE_TYPE IN ('Support Staff', 'Faculty') GROUP BY ml.MOIRA_LIST_NAME, ml.IS_ACTIVE;",
    "oracle_sql": "SELECT ml.MOIRA_LIST_NAME, SUM(CASE WHEN se.EMPLOYEE_TYPE = 'Support Staff' THEN 1 ELSE 0 END) AS SUPPORT_COUNT, SUM(CASE WHEN se.EMPLOYEE_TYPE = 'Faculty' THEN 1 ELSE 0 END) AS FACULTY_COUNT, ml.IS_ACTIVE FROM MOIRA_LIST ml JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY JOIN SE_PERSON se ON upper(mld.MOIRA_LIST_MEMBER) = upper(se.KRB_NAME) WHERE se.EMPLOYEE_TYPE IN ('Support Staff', 'Faculty') GROUP BY ml.MOIRA_LIST_NAME, ml.IS_ACTIVE;",
    "gold_tables": [
      "dw#sep#MOIRA_LIST",
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#SE_PERSON"
    ],
    "mapping": {
      "support staff or faculty": [
        "SE_PERSON.EMPLOYEE_TYPE"
      ],
      "name": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "subscribers": [
        "SE_PERSON.EMPLOYEE_TYPE"
      ],
      "active status": [
        "MOIRA_LIST.IS_ACTIVE"
      ]
    },
    "join_keys": [
      [
        "MOIRA_LIST.MOIRA_LIST_KEY",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY"
      ]
    ]
  },
  {
    "question": "For the 'ocean-apple' mailing list, identify the department with the highest student count. Provide the department name, phone number, and the total number of students subscribed to the mailing list from that department. If multiple departments have the same highest count, list each one separately.",
    "db_id": "dw",
    "sql": "WITH FilteredList AS ( SELECT MOIRA_LIST_KEY, MOIRA_LIST_NAME FROM MOIRA_LIST WHERE MOIRA_LIST_NAME = 'ocean-apple' ), FilteredListDetails AS ( SELECT mld.MOIRA_LIST_KEY, mld.MOIRA_LIST_MEMBER FROM MOIRA_LIST_DETAIL mld JOIN FilteredList fl ON mld.MOIRA_LIST_KEY = fl.MOIRA_LIST_KEY ), StudentMemberCounts AS ( SELECT fl.MOIRA_LIST_KEY, fl.MOIRA_LIST_NAME, ad.DEPARTMENT_PHONE_NUMBER AS department_phone, ad.SIS_ADMIN_DEPARTMENT_NAME AS department_name, COUNT(DISTINCT msd.FULL_NAME) AS student_members FROM FilteredList fl JOIN FilteredListDetails fld ON fl.MOIRA_LIST_KEY = fld.MOIRA_LIST_KEY JOIN SE_PERSON se ON UPPER(fld.MOIRA_LIST_MEMBER) = UPPER(se.KRB_NAME) JOIN MIT_STUDENT_DIRECTORY msd ON se.FULL_NAME = msd.FULL_NAME LEFT JOIN SIS_ADMIN_DEPARTMENT ad ON msd.DEPARTMENT = ad.SIS_ADMIN_DEPARTMENT_CODE GROUP BY fl.MOIRA_LIST_KEY, fl.MOIRA_LIST_NAME, ad.DEPARTMENT_PHONE_NUMBER, ad.SIS_ADMIN_DEPARTMENT_NAME ), RankedDepartments AS ( SELECT department_name, department_phone, SUM(student_members) AS total_student_members, RANK() OVER (ORDER BY SUM(student_members) DESC) AS department_rank FROM StudentMemberCounts GROUP BY department_name, department_phone ) SELECT department_name AS most_prominent_dpt, department_phone AS most_prominent_dpt_phone, total_student_members FROM RankedDepartments WHERE department_rank = 1;",
    "oracle_sql": "WITH StudentMemberCounts AS (SELECT mld.MOIRA_LIST_KEY, ml.MOIRA_LIST_NAME, mo.OWNER AS list_owner, ad.DEPARTMENT_PHONE_NUMBER AS department_phone, ad.SIS_ADMIN_DEPARTMENT_NAME AS department_name, COUNT(DISTINCT msd.FULL_NAME) AS student_members FROM MOIRA_LIST_DETAIL mld JOIN MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY JOIN MOIRA_LIST_OWNER mo ON mld.MOIRA_LIST_OWNER_KEY = mo.MOIRA_LIST_OWNER_KEY JOIN SE_PERSON se ON upper(mld.MOIRA_LIST_MEMBER) = upper(se.KRB_NAME) JOIN MIT_STUDENT_DIRECTORY msd ON se.FULL_NAME = msd.FULL_NAME LEFT JOIN SIS_ADMIN_DEPARTMENT ad ON msd.DEPARTMENT = ad.SIS_ADMIN_DEPARTMENT_CODE WHERE ml.MOIRA_LIST_NAME = 'ocean-apple' GROUP BY mld.MOIRA_LIST_KEY, ml.MOIRA_LIST_NAME, mo.OWNER, ad.DEPARTMENT_PHONE_NUMBER, ad.SIS_ADMIN_DEPARTMENT_NAME), RankedDepartments AS (SELECT list_owner, department_name, department_phone, SUM(student_members) AS total_student_members, RANK() OVER (PARTITION BY list_owner ORDER BY SUM(student_members) DESC) AS department_rank FROM StudentMemberCounts GROUP BY list_owner, department_name, department_phone) SELECT list_owner, department_name AS most_prominent_dpt, department_phone AS most_prominent_dpt_phone, total_student_members FROM RankedDepartments WHERE department_rank = 1 ORDER BY list_owner;",
    "gold_tables": [
      "dw#sep#MOIRA_LIST",
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#SE_PERSON",
      "dw#sep#MIT_STUDENT_DIRECTORY",
      "dw#sep#SIS_ADMIN_DEPARTMENT"
    ],
    "mapping": {
      "'ocean-apple' mailing list": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "department name": [
        "SIS_ADMIN_DEPARTMENT.SIS_ADMIN_DEPARTMENT_NAME"
      ],
      "phone number": [
        "SIS_ADMIN_DEPARTMENT.DEPARTMENT_PHONE_NUMBER"
      ],
      "students": [
        "MIT_STUDENT_DIRECTORY.FULL_NAME"
      ]
    },
    "join_keys": [
      [
        "MOIRA_LIST.MOIRA_LIST_KEY",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY"
      ],
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER",
        "SE_PERSON.KRB_NAME"
      ],
      [
        "SE_PERSON.FULL_NAME",
        "MIT_STUDENT_DIRECTORY.FULL_NAME"
      ],
      [
        "MIT_STUDENT_DIRECTORY.DEPARTMENT",
        "SIS_ADMIN_DEPARTMENT.SIS_ADMIN_DEPARTMENT_CODE"
      ]
    ]
  },
  {
    "question": "For each mailing list, list its owner, owner type, the member visibility ('Public Members' if public, and 'Hidden Members' otherwise), and the number of members of this type of visibility. For each owner and owner type, include a grand total for all members in the format of (owner, owner type, null, total members).",
    "db_id": "dw",
    "sql": "WITH MemberVisibility AS ( SELECT mo.OWNER, mo.OWNER_TYPE, ml.MOIRA_LIST_NAME, CASE WHEN ml.IS_PUBLIC = 'Y' THEN 'Public Members' WHEN ml.IS_PUBLIC = 'N' THEN 'Hidden Members' ELSE NULL END AS member_visibility, COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) AS total_members FROM MOIRA_LIST_DETAIL mld JOIN MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY JOIN MOIRA_LIST_OWNER mo ON mld.MOIRA_LIST_OWNER_KEY = mo.MOIRA_LIST_OWNER_KEY WHERE ml.IS_MOIRA_GROUP = 'Y' AND upper(ml.MOIRA_LIST_NAME) LIKE 'B%' GROUP BY mo.OWNER, mo.OWNER_TYPE, ml.MOIRA_LIST_NAME, ml.IS_PUBLIC ), RollupResults AS ( SELECT MOIRA_LIST_NAME, member_visibility, SUM(total_members) AS total_members FROM MemberVisibility GROUP BY MOIRA_LIST_NAME, member_visibility WITH ROLLUP HAVING SUM(total_members) > 0 ) SELECT rr.MOIRA_LIST_NAME, mv.OWNER, mv.OWNER_TYPE, rr.member_visibility, rr.total_members FROM RollupResults rr LEFT JOIN (SELECT DISTINCT MOIRA_LIST_NAME, OWNER, OWNER_TYPE FROM MemberVisibility) mv ON rr.MOIRA_LIST_NAME = mv.MOIRA_LIST_NAME ORDER BY rr.MOIRA_LIST_NAME, rr.member_visibility;",
    "oracle_sql": "WITH MemberVisibility AS ( SELECT mo.OWNER, mo.OWNER_TYPE, CASE WHEN ml.IS_PUBLIC = 'Y' THEN 'Public Members' WHEN ml.IS_PUBLIC = 'N' THEN 'Hidden Members' ELSE NULL END AS member_visibility, COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) AS total_members FROM MOIRA_LIST_DETAIL mld JOIN MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY JOIN MOIRA_LIST_OWNER mo ON mld.MOIRA_LIST_OWNER_KEY = mo.MOIRA_LIST_OWNER_KEY WHERE ml.IS_MOIRA_GROUP = 'Y' GROUP BY mo.OWNER, mo.OWNER_TYPE, ml.IS_PUBLIC ), RollupResults AS ( SELECT OWNER, member_visibility, SUM(total_members) AS total_members FROM MemberVisibility GROUP BY ROLLUP(OWNER, member_visibility) HAVING SUM(total_members) > 0 ) SELECT rr.OWNER, mv.OWNER_TYPE, rr.member_visibility, rr.total_members FROM RollupResults rr LEFT JOIN ( SELECT DISTINCT OWNER, OWNER_TYPE FROM MemberVisibility ) mv ON rr.OWNER = mv.OWNER ORDER BY rr.OWNER, rr.member_visibility;",
    "gold_tables": [
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#MOIRA_LIST",
      "dw#sep#MOIRA_LIST_OWNER"
    ],
    "mapping": {
      "owner": [
        "MOIRA_LIST_OWNER.OWNER"
      ],
      "owner type": [
        "MOIRA_LIST_OWNER.OWNER_TYPE"
      ],
      "member visibility": [
        "MOIRA_LIST.IS_PUBLIC"
      ],
      "members": [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ]
    },
    "join_keys": [
      [
        "MOIRA_LIST.MOIRA_LIST_KEY",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY"
      ],
      [
        "MOIRA_LIST_OWNER.MOIRA_LIST_OWNER_KEY",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_OWNER_KEY"
      ]
    ]
  },
  {
    "question": "Group biology courses by cluster type and course level. For each group, list the name of the department, the course title, cluster type, total enrollments, average enrollment within its cluster, course level, number of unique course materials, average new and used prices for TIP materials, total material record count for TIP materials, number of unique library titles, and number of unique library ISBNs.",
    "db_id": "dw",
    "sql": "WITH EnrollmentWithAnalytics AS ( SELECT sos.SUBJECT_ID, sos.SUBJECT_TITLE, sos.OFFER_DEPT_NAME AS DEPARTMENT, sos.CLUSTER_TYPE, sos.NUM_ENROLLED_STUDENTS, AVG(sos.NUM_ENROLLED_STUDENTS) OVER (PARTITION BY sos.CLUSTER_TYPE) AS avg_enrollment_in_cluster, scd.COURSE_LEVEL FROM SUBJECT_OFFERED_SUMMARY sos LEFT JOIN SIS_COURSE_DESCRIPTION scd ON sos.COURSE_NUMBER = scd.COURSE WHERE sos.OFFER_DEPT_NAME = 'Biology' ), EnrollmentWithTIP AS ( SELECT ewa.SUBJECT_ID, ewa.SUBJECT_TITLE, ewa.DEPARTMENT, ewa.CLUSTER_TYPE, ewa.NUM_ENROLLED_STUDENTS, ewa.avg_enrollment_in_cluster, ewa.COURSE_LEVEL, tm.TITLE AS material_title, tm.NEW_SHELF_PRICE, tm.USED_SHELF_PRICE, td.RECORD_COUNT AS material_record_count FROM EnrollmentWithAnalytics ewa LEFT JOIN TIP_DETAIL td ON ewa.SUBJECT_ID = td.SUBJECT_ID LEFT JOIN TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY ), EnrollmentWithLibrary AS ( SELECT ewt.SUBJECT_ID, ewt.SUBJECT_TITLE, ewt.DEPARTMENT, ewt.CLUSTER_TYPE, ewt.NUM_ENROLLED_STUDENTS, ewt.avg_enrollment_in_cluster, ewt.COURSE_LEVEL, ewt.material_title, ewt.NEW_SHELF_PRICE, ewt.USED_SHELF_PRICE, ewt.material_record_count, lrc.CATALOG_TITLE AS library_title, lrc.CATALOG_AUTHOR_NAME AS library_author, lrc.CATALOG_ISBN AS library_isbn FROM EnrollmentWithTIP ewt LEFT JOIN LIBRARY_RESERVE_CATALOG lrc ON ewt.SUBJECT_ID = lrc.CATALOG_SYSTEM_NUMBER ) SELECT DEPARTMENT, SUBJECT_TITLE, CLUSTER_TYPE, SUM(NUM_ENROLLED_STUDENTS) AS total_enrollment, AVG(avg_enrollment_in_cluster) AS avg_enrollment_in_cluster, COURSE_LEVEL, COUNT(DISTINCT material_title) AS num_unique_materials, AVG(NEW_SHELF_PRICE) AS avg_new_material_price, AVG(USED_SHELF_PRICE) AS avg_used_material_price, SUM(material_record_count) AS total_material_records, COUNT(DISTINCT library_title) AS num_unique_library_titles, COUNT(DISTINCT library_isbn) AS num_unique_library_isbns FROM EnrollmentWithLibrary GROUP BY DEPARTMENT, SUBJECT_TITLE, CLUSTER_TYPE, COURSE_LEVEL ORDER BY DEPARTMENT, SUBJECT_TITLE, CLUSTER_TYPE;",
    "oracle_sql": "WITH EnrollmentWithAnalytics AS ( SELECT sos.SUBJECT_ID, sos.SUBJECT_TITLE, sos.OFFER_DEPT_NAME AS DEPARTMENT, sos.CLUSTER_TYPE, sos.NUM_ENROLLED_STUDENTS, AVG(sos.NUM_ENROLLED_STUDENTS) OVER (PARTITION BY sos.CLUSTER_TYPE) AS avg_enrollment_in_cluster, scd.COURSE_LEVEL FROM SUBJECT_OFFERED_SUMMARY sos LEFT JOIN SIS_COURSE_DESCRIPTION scd ON sos.COURSE_NUMBER = scd.COURSE WHERE sos.OFFER_DEPT_NAME = 'Biology' ), EnrollmentWithTIP AS ( SELECT ewa.SUBJECT_ID, ewa.SUBJECT_TITLE, ewa.DEPARTMENT, ewa.CLUSTER_TYPE, ewa.NUM_ENROLLED_STUDENTS, ewa.avg_enrollment_in_cluster, ewa.COURSE_LEVEL, tm.TITLE AS material_title, tm.NEW_SHELF_PRICE, tm.USED_SHELF_PRICE, td.RECORD_COUNT AS material_record_count FROM EnrollmentWithAnalytics ewa LEFT JOIN TIP_DETAIL td ON ewa.SUBJECT_ID = td.SUBJECT_ID LEFT JOIN TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY ), EnrollmentWithLibrary AS ( SELECT ewt.SUBJECT_ID, ewt.SUBJECT_TITLE, ewt.DEPARTMENT, ewt.CLUSTER_TYPE, ewt.NUM_ENROLLED_STUDENTS, ewt.avg_enrollment_in_cluster, ewt.COURSE_LEVEL, ewt.material_title, ewt.NEW_SHELF_PRICE, ewt.USED_SHELF_PRICE, ewt.material_record_count, lrc.CATALOG_TITLE AS library_title, lrc.CATALOG_AUTHOR_NAME AS library_author, lrc.CATALOG_ISBN AS library_isbn FROM EnrollmentWithTIP ewt LEFT JOIN LIBRARY_RESERVE_CATALOG lrc ON ewt.SUBJECT_ID = lrc.CATALOG_SYSTEM_NUMBER ) SELECT DEPARTMENT, SUBJECT_TITLE, CLUSTER_TYPE, SUM(NUM_ENROLLED_STUDENTS) AS total_enrollment, AVG(avg_enrollment_in_cluster) AS avg_enrollment_in_cluster, COURSE_LEVEL, COUNT(DISTINCT material_title) AS num_unique_materials, AVG(NEW_SHELF_PRICE) AS avg_new_material_price, AVG(USED_SHELF_PRICE) AS avg_used_material_price, SUM(material_record_count) AS total_material_records, COUNT(DISTINCT library_title) AS num_unique_library_titles, COUNT(DISTINCT library_isbn) AS num_unique_library_isbns FROM EnrollmentWithLibrary GROUP BY DEPARTMENT, SUBJECT_TITLE, CLUSTER_TYPE, COURSE_LEVEL ORDER BY DEPARTMENT, SUBJECT_TITLE, CLUSTER_TYPE;",
    "gold_tables": [
      "dw#sep#SUBJECT_OFFERED_SUMMARY",
      "dw#sep#SIS_COURSE_DESCRIPTION",
      "dw#sep#TIP_DETAIL",
      "dw#sep#TIP_MATERIAL",
      "dw#sep#LIBRARY_RESERVE_CATALOG"
    ],
    "mapping": {
      "biology courses": [
        "SUBJECT_OFFERED_SUMMARY.OFFER_DEPT_NAME"
      ],
      "cluster type": [
        "SUBJECT_OFFERED_SUMMARY.CLUSTER_TYPE"
      ],
      "course level": [
        "SIS_COURSE_DESCRIPTION.COURSE_LEVEL"
      ],
      "name of the department": [
        "SUBJECT_OFFERED_SUMMARY.OFFER_DEPT_NAME"
      ],
      "course title": [
        "SUBJECT_OFFERED_SUMMARY.SUBJECT_TITLE"
      ],
      "enrollment": [
        "SUBJECT_OFFERED_SUMMARY.NUM_ENROLLED_STUDENTS"
      ],
      "course materials": [
        "TIP_MATERIAL.TITLE"
      ],
      "new price": [
        "TIP_MATERIAL.NEW_SHELF_PRICE"
      ],
      "use price": [
        "TIP_MATERIAL.USED_SHELF_PRICE"
      ],
      "record count for TIP materials": [
        "TIP_DETAIL.RECORD_COUNT"
      ],
      "library titles": [
        "LIBRARY_RESERVE_CATALOG.CATALOG_TITLE"
      ],
      "library ISBNs": [
        "LIBRARY_RESERVE_CATALOG.CATALOG_ISBN"
      ]
    },
    "join_keys": [
      [
        "SUBJECT_OFFERED_SUMMARY.COURSE_NUMBER",
        "SIS_COURSE_DESCRIPTION.COURSE"
      ],
      [
        "TIP_MATERIAL.TIP_MATERIAL_KEY",
        "TIP_DETAIL.TIP_MATERIAL_KEY"
      ]
    ]
  },
  {
    "question": "For subjects offered this year in either the Fall or Spring term, list its department name, school name, subject ID, subject title, course level, total units, the term it is offered ('Spring' for Spring term and 'Fall' for Fall term), term description, the number of distinct instructors teaching in the Fall, and the number of distinct instructors teaching in the Spring.",
    "db_id": "dw",
    "sql": "WITH SubjectsByTerm AS ( SELECT cc.SUBJECT_ID, cc.SUBJECT_TITLE, cc.TOTAL_UNITS, cc.DEPARTMENT_NAME, CASE WHEN cc.TERM_CODE LIKE '%FA' THEN 'Fall' WHEN cc.TERM_CODE LIKE '%SP' THEN 'Spring' END AS offered_term, at.TERM_DESCRIPTION AS term_description, sd.SCHOOL_NAME, scd.COURSE_LEVEL, cc.FALL_INSTRUCTORS, cc.SPRING_INSTRUCTORS FROM COURSE_CATALOG_SUBJECT_OFFERED cc JOIN ACADEMIC_TERMS at ON cc.TERM_CODE = at.TERM_CODE LEFT JOIN SIS_DEPARTMENT sd ON cc.DEPARTMENT_CODE = sd.DEPARTMENT_CODE LEFT JOIN SIS_COURSE_DESCRIPTION scd ON cc.SUBJECT_CODE = scd.COURSE WHERE cc.IS_OFFERED_THIS_YEAR = 'Y' AND (cc.TERM_CODE LIKE '%FA' OR cc.TERM_CODE LIKE '%SP') ), SubjectsAggregated AS ( SELECT SUBJECT_ID, SUBJECT_TITLE, DEPARTMENT_NAME, SCHOOL_NAME, COURSE_LEVEL, TOTAL_UNITS, offered_term, term_description, COUNT(DISTINCT FALL_INSTRUCTORS) AS num_fall_instructors, COUNT(DISTINCT SPRING_INSTRUCTORS) AS num_spring_instructors FROM SubjectsByTerm GROUP BY SUBJECT_ID, SUBJECT_TITLE, DEPARTMENT_NAME, SCHOOL_NAME, COURSE_LEVEL, TOTAL_UNITS, offered_term, term_description ) SELECT DEPARTMENT_NAME, SCHOOL_NAME, SUBJECT_ID, SUBJECT_TITLE, COURSE_LEVEL, TOTAL_UNITS, offered_term, term_description, num_fall_instructors, num_spring_instructors FROM SubjectsAggregated ORDER BY DEPARTMENT_NAME, SUBJECT_ID, SUBJECT_TITLE, offered_term;",
    "oracle_sql": "WITH SubjectsByTerm AS ( SELECT cc.SUBJECT_ID, cc.SUBJECT_TITLE, cc.TOTAL_UNITS, cc.DEPARTMENT_NAME, CASE WHEN cc.TERM_CODE LIKE '%FA' THEN 'Fall' WHEN cc.TERM_CODE LIKE '%SP' THEN 'Spring' END AS offered_term, at.TERM_DESCRIPTION AS term_description, sd.SCHOOL_NAME, scd.COURSE_LEVEL, cc.FALL_INSTRUCTORS, cc.SPRING_INSTRUCTORS FROM COURSE_CATALOG_SUBJECT_OFFERED cc JOIN ACADEMIC_TERMS at ON cc.TERM_CODE = at.TERM_CODE LEFT JOIN SIS_DEPARTMENT sd ON cc.DEPARTMENT_CODE = sd.DEPARTMENT_CODE LEFT JOIN SIS_COURSE_DESCRIPTION scd ON cc.SUBJECT_CODE = scd.COURSE WHERE cc.IS_OFFERED_THIS_YEAR = 'Y' AND (cc.TERM_CODE LIKE '%FA' OR cc.TERM_CODE LIKE '%SP') ), SubjectsAggregated AS ( SELECT SUBJECT_ID, SUBJECT_TITLE, DEPARTMENT_NAME, SCHOOL_NAME, COURSE_LEVEL, TOTAL_UNITS, offered_term, term_description, COUNT(DISTINCT FALL_INSTRUCTORS) AS num_fall_instructors, COUNT(DISTINCT SPRING_INSTRUCTORS) AS num_spring_instructors FROM SubjectsByTerm GROUP BY SUBJECT_ID, SUBJECT_TITLE, DEPARTMENT_NAME, SCHOOL_NAME, COURSE_LEVEL, TOTAL_UNITS, offered_term, term_description ) SELECT DEPARTMENT_NAME, SCHOOL_NAME, SUBJECT_ID, SUBJECT_TITLE, COURSE_LEVEL, TOTAL_UNITS, offered_term, term_description, num_fall_instructors, num_spring_instructors FROM SubjectsAggregated ORDER BY DEPARTMENT_NAME, SUBJECT_ID, SUBJECT_TITLE, offered_term;",
    "gold_tables": [
      "dw#sep#COURSE_CATALOG_SUBJECT_OFFERED",
      "dw#sep#ACADEMIC_TERMS",
      "dw#sep#SIS_DEPARTMENT",
      "dw#sep#SIS_COURSE_DESCRIPTION"
    ],
    "mapping": {
      "subjects offered this year": [
        "COURSE_CATALOG_SUBJECT_OFFERED.IS_OFFERED_THIS_YEAR"
      ],
      "department name": [
        "COURSE_CATALOG_SUBJECT_OFFERED.DEPARTMENT_NAME"
      ],
      "school name": [
        "SIS_DEPARTMENT.SCHOOL_NAME"
      ],
      "subject ID": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID"
      ],
      "subject title": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_TITLE"
      ],
      "course level": [
        "SIS_COURSE_DESCRIPTION.COURSE_LEVEL"
      ],
      "total units": [
        "COURSE_CATALOG_SUBJECT_OFFERED.TOTAL_UNITS"
      ],
      "term": [
        "COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE"
      ],
      "term description": [
        "ACADEMIC_TERMS.TERM_DESCRIPTION"
      ],
      "instructors": [
        "COURSE_CATALOG_SUBJECT_OFFERED.FALL_INSTRUCTORS",
        "COURSE_CATALOG_SUBJECT_OFFERED.SPRING_INSTRUCTORS"
      ]
    },
    "join_keys": [
      [
        "COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE",
        "ACADEMIC_TERMS.TERM_CODE"
      ],
      [
        "COURSE_CATALOG_SUBJECT_OFFERED.DEPARTMENT_CODE",
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ],
      [
        "SIS_COURSE_DESCRIPTION.COURSE",
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_CODE"
      ]
    ]
  },
  {
    "question": "For Political Science courses with HASS attributes, for each attribute, list the name and description of the attribute, the number of unique subjects, average units, the total enrollment, the number of departments that grant degrees, and the subject code description.",
    "db_id": "dw",
    "sql": "WITH HASSAttributes AS (SELECT cc.HASS_ATTRIBUTE, cc.HASS_ATTRIBUTE_DESC, cc.SUBJECT_ID, cc.TOTAL_UNITS, sos.NUM_ENROLLED_STUDENTS, sd.DEPARTMENT_NAME, sd.IS_DEGREE_GRANTING, sc.SUBJECT_CODE_DESC FROM CIS_COURSE_CATALOG cc JOIN SIS_SUBJECT_CODE sc ON cc.SUBJECT_CODE = sc.SUBJECT_CODE JOIN SUBJECT_OFFERED_SUMMARY sos ON cc.SUBJECT_ID = sos.SUBJECT_ID LEFT JOIN SIS_DEPARTMENT sd ON sc.DEPARTMENT_CODE = sd.DEPARTMENT_CODE WHERE cc.HASS_ATTRIBUTE IS NOT NULL AND sd.DEPARTMENT_NAME = 'Political Science') SELECT HASS_ATTRIBUTE, HASS_ATTRIBUTE_DESC, COUNT(DISTINCT SUBJECT_ID) AS num_subjects, AVG(TOTAL_UNITS) AS avg_units, SUM(NUM_ENROLLED_STUDENTS) AS total_enrollment, COUNT(DISTINCT CASE WHEN IS_DEGREE_GRANTING = 'Y' THEN DEPARTMENT_NAME END) AS num_degree_granting, SUBJECT_CODE_DESC FROM HASSAttributes GROUP BY HASS_ATTRIBUTE, HASS_ATTRIBUTE_DESC, SUBJECT_CODE_DESC ORDER BY HASS_ATTRIBUTE, HASS_ATTRIBUTE_DESC, SUBJECT_CODE_DESC;",
    "oracle_sql": "WITH HASSAttributes AS (SELECT cc.HASS_ATTRIBUTE, cc.HASS_ATTRIBUTE_DESC, cc.SUBJECT_ID, cc.TOTAL_UNITS, sos.NUM_ENROLLED_STUDENTS, sd.DEPARTMENT_NAME, sd.IS_DEGREE_GRANTING, sc.SUBJECT_CODE_DESC FROM CIS_COURSE_CATALOG cc JOIN SIS_SUBJECT_CODE sc ON cc.SUBJECT_CODE = sc.SUBJECT_CODE JOIN SUBJECT_OFFERED_SUMMARY sos ON cc.SUBJECT_ID = sos.SUBJECT_ID LEFT JOIN SIS_DEPARTMENT sd ON sc.DEPARTMENT_CODE = sd.DEPARTMENT_CODE WHERE cc.HASS_ATTRIBUTE IS NOT NULL AND sd.DEPARTMENT_NAME = 'Political Science') SELECT HASS_ATTRIBUTE, HASS_ATTRIBUTE_DESC, COUNT(DISTINCT SUBJECT_ID) AS num_subjects, AVG(TOTAL_UNITS) AS avg_units, SUM(NUM_ENROLLED_STUDENTS) AS total_enrollment, COUNT(DISTINCT CASE WHEN IS_DEGREE_GRANTING = 'Y' THEN DEPARTMENT_NAME END) AS num_degree_granting, SUBJECT_CODE_DESC FROM HASSAttributes GROUP BY HASS_ATTRIBUTE, HASS_ATTRIBUTE_DESC, SUBJECT_CODE_DESC ORDER BY HASS_ATTRIBUTE, HASS_ATTRIBUTE_DESC, SUBJECT_CODE_DESC;",
    "gold_tables": [
      "dw#sep#CIS_COURSE_CATALOG",
      "dw#sep#SIS_SUBJECT_CODE",
      "dw#sep#SUBJECT_OFFERED_SUMMARY",
      "dw#sep#SIS_DEPARTMENT"
    ],
    "mapping": {
      "Political Science": [
        "SIS_DEPARTMENT.DEPARTMENT_NAME"
      ],
      "name": [
        "CIS_COURSE_CATALOG.HASS_ATTRIBUTE"
      ],
      "description": [
        "CIS_COURSE_CATALOG.HASS_ATTRIBUTE_DESC"
      ],
      "subjects": [
        "CIS_COURSE_CATALOG.SUBJECT_ID"
      ],
      "units": [
        "CIS_COURSE_CATALOG.TOTAL_UNITS"
      ],
      "enrollment": [
        "SUBJECT_OFFERED_SUMMARY.NUM_ENROLLED_STUDENTS"
      ],
      "departments that grant degrees": [
        "SIS_DEPARTMENT.IS_DEGREE_GRANTING"
      ],
      "subject code description": [
        "SIS_SUBJECT_CODE.SUBJECT_CODE_DESC"
      ]
    },
    "join_keys": [
      [
        "CIS_COURSE_CATALOG.SUBJECT_CODE",
        "SIS_SUBJECT_CODE.SUBJECT_CODE"
      ],
      [
        "SUBJECT_OFFERED_SUMMARY.SUBJECT_ID",
        "CIS_COURSE_CATALOG.SUBJECT_ID"
      ],
      [
        "SIS_DEPARTMENT.DEPARTMENT_CODE",
        "SIS_SUBJECT_CODE.DEPARTMENT_CODE"
      ]
    ]
  },
  {
    "question": "Group subjects by cluster type, department offering the subject, and the school name. For each group, list the cluster type, name of the department, school name, whether the department grants degrees, total number of subjects, total enrollment, and average enrollment. Exclude clusters or schools with no student data.",
    "db_id": "dw",
    "sql": "WITH ClusterSummary AS (SELECT sos.CLUSTER_TYPE, sos.OFFER_DEPT_NAME AS DEPARTMENT, sd.SCHOOL_NAME, COUNT(DISTINCT sos.SUBJECT_ID) AS num_subjects, SUM(sos.NUM_ENROLLED_STUDENTS) AS total_enrollment, AVG(sos.NUM_ENROLLED_STUDENTS) AS avg_enrollment, sd.IS_DEGREE_GRANTING AS degree_granting_status FROM SUBJECT_OFFERED_SUMMARY sos LEFT JOIN SIS_COURSE_DESCRIPTION scd ON sos.COURSE_NUMBER = scd.COURSE LEFT JOIN SIS_DEPARTMENT sd ON sos.OFFER_DEPT_CODE = sd.DEPARTMENT_CODE WHERE sos.CLUSTER_TYPE IS NOT NULL AND sos.NUM_ENROLLED_STUDENTS > 0 AND sd.SCHOOL_NAME IS NOT NULL GROUP BY sos.CLUSTER_TYPE, sos.OFFER_DEPT_NAME, sd.SCHOOL_NAME, sd.IS_DEGREE_GRANTING) SELECT CLUSTER_TYPE, DEPARTMENT, SCHOOL_NAME, degree_granting_status, num_subjects, total_enrollment, avg_enrollment FROM ClusterSummary ORDER BY CLUSTER_TYPE, DEPARTMENT, SCHOOL_NAME;",
    "oracle_sql": "WITH ClusterSummary AS (SELECT sos.CLUSTER_TYPE, sos.OFFER_DEPT_NAME AS DEPARTMENT, sd.SCHOOL_NAME, COUNT(DISTINCT sos.SUBJECT_ID) AS num_subjects, SUM(sos.NUM_ENROLLED_STUDENTS) AS total_enrollment, AVG(sos.NUM_ENROLLED_STUDENTS) AS avg_enrollment, sd.IS_DEGREE_GRANTING AS degree_granting_status FROM SUBJECT_OFFERED_SUMMARY sos LEFT JOIN SIS_COURSE_DESCRIPTION scd ON sos.COURSE_NUMBER = scd.COURSE LEFT JOIN SIS_DEPARTMENT sd ON sos.OFFER_DEPT_CODE = sd.DEPARTMENT_CODE WHERE sos.CLUSTER_TYPE IS NOT NULL AND sos.NUM_ENROLLED_STUDENTS > 0 AND sd.SCHOOL_NAME IS NOT NULL GROUP BY sos.CLUSTER_TYPE, sos.OFFER_DEPT_NAME, sd.SCHOOL_NAME, sd.IS_DEGREE_GRANTING) SELECT CLUSTER_TYPE, DEPARTMENT, SCHOOL_NAME, degree_granting_status, num_subjects, total_enrollment, avg_enrollment FROM ClusterSummary ORDER BY CLUSTER_TYPE, DEPARTMENT, SCHOOL_NAME;",
    "gold_tables": [
      "dw#sep#SUBJECT_OFFERED_SUMMARY",
      "dw#sep#SIS_COURSE_DESCRIPTION",
      "dw#sep#SIS_DEPARTMENT"
    ],
    "mapping": {
      "cluster type": [
        "SUBJECT_OFFERED_SUMMARY.CLUSTER_TYPE"
      ],
      "name of the department": [
        "SUBJECT_OFFERED_SUMMARY.OFFER_DEPT_NAME"
      ],
      "school name": [
        "SIS_DEPARTMENT.SCHOOL_NAME"
      ],
      "whether the department grants degrees": [
        "SIS_DEPARTMENT.IS_DEGREE_GRANTING"
      ],
      "subjects": [
        "SUBJECT_OFFERED_SUMMARY.SUBJECT_ID"
      ],
      "enrollment": [
        "SUBJECT_OFFERED_SUMMARY.NUM_ENROLLED_STUDENTS"
      ]
    },
    "join_keys": [
      [
        "SUBJECT_OFFERED_SUMMARY.COURSE_NUMBER",
        "SIS_COURSE_DESCRIPTION.COURSE"
      ],
      [
        "SIS_DEPARTMENT.DEPARTMENT_CODE",
        "SUBJECT_OFFERED_SUMMARY.OFFER_DEPT_CODE"
      ]
    ]
  },
  {
    "question": "Group classes that take place in buildings at MIT by the building name and course level. For each group, provide the name of the building, the course level ('Graduate' or 'Undergraduate'), the total number of unique courses of such level, and total instructors for these courses. Include subtotals for each building and course level and a grand total across all buildings and course levels.",
    "db_id": "dw",
    "sql": "SELECT ba.BUILDING_NAME, ba.course_level, ba.unique_courses, ba.total_instructors FROM (SELECT b.BUILDING_NAME, CASE WHEN scd.COURSE_LEVEL = 'G' THEN 'Graduate' WHEN scd.COURSE_LEVEL = 'U' THEN 'Undergraduate' ELSE 'Other' END AS course_level, COUNT(DISTINCT s.SUBJECT_ID) AS unique_courses, SUM(COUNT(DISTINCT s.RESPONSIBLE_FACULTY_NAME)) OVER (PARTITION BY b.BUILDING_NAME) AS total_instructors FROM FAC_BUILDING b JOIN SUBJECT_OFFERED s ON b.FAC_BUILDING_KEY = s.MEET_PLACE JOIN SIS_COURSE_DESCRIPTION scd ON s.COURSE_NUMBER = scd.COURSE JOIN FAC_BUILDING_ADDRESS ba ON b.FAC_BUILDING_KEY = ba.BUILDING_KEY WHERE b.SITE = 'MIT' GROUP BY b.BUILDING_NAME, scd.COURSE_LEVEL) ba ORDER BY ba.unique_courses DESC, ba.BUILDING_NAME;",
    "oracle_sql": "WITH BuildingSubjectDetails AS (SELECT b.FAC_BUILDING_KEY, b.BUILDING_NAME, s.SUBJECT_ID, CASE WHEN scd.COURSE_LEVEL = 'G' THEN 'Graduate' WHEN scd.COURSE_LEVEL = 'U' THEN 'Undergraduate' ELSE 'Other' END AS course_level, COUNT(DISTINCT s.RESPONSIBLE_FACULTY_NAME) AS num_instructors FROM FAC_BUILDING b JOIN SUBJECT_OFFERED s ON b.FAC_BUILDING_KEY = s.MEET_PLACE JOIN SIS_COURSE_DESCRIPTION scd ON s.COURSE_NUMBER = scd.COURSE JOIN FAC_BUILDING_ADDRESS ba ON b.FAC_BUILDING_KEY = ba.BUILDING_KEY WHERE b.SITE = 'MIT' GROUP BY b.FAC_BUILDING_KEY, b.BUILDING_NAME, s.SUBJECT_ID, scd.COURSE_LEVEL), BuildingAggregates AS (SELECT BUILDING_NAME, course_level, COUNT(DISTINCT SUBJECT_ID) AS unique_courses, SUM(num_instructors) AS total_instructors FROM BuildingSubjectDetails GROUP BY ROLLUP(BUILDING_NAME, course_level)) SELECT BUILDING_NAME, course_level, unique_courses, total_instructors FROM BuildingAggregates ORDER BY unique_courses DESC, BUILDING_NAME;",
    "gold_tables": [
      "dw#sep#FAC_BUILDING",
      "dw#sep#SUBJECT_OFFERED",
      "dw#sep#SIS_COURSE_DESCRIPTION",
      "dw#sep#FAC_BUILDING_ADDRESS"
    ],
    "mapping": {
      "buildings at MIT": [
        "FAC_BUILDING.SITE"
      ],
      "name of the building": [
        "FAC_BUILDING.BUILDING_NAME"
      ],
      "course level": [
        "SIS_COURSE_DESCRIPTION.COURSE_LEVEL"
      ],
      "courses": [
        "SUBJECT_OFFERED_SUMMARY.SUBJECT_ID"
      ],
      "instructors": [
        "SUBJECT_OFFERED_SUMMARY.RESPONSIBLE_FACULTY_NAME"
      ]
    },
    "join_keys": [
      [
        "FAC_BUILDING.FAC_BUILDING_KEY",
        "SUBJECT_OFFERED.MEET_PLACE"
      ],
      [
        "SUBJECT_OFFERED.COURSE_NUMBER",
        "SIS_COURSE_DESCRIPTION.COURSE"
      ],
      [
        "FAC_BUILDING_ADDRESS.BUILDING_KEY",
        "FAC_BUILDING.FAC_BUILDING_KEY"
      ]
    ]
  },
  {
    "question": "For each course, provide the room number of course location, building name, building number, building city, building state, area, organization name, room usage, term code, course level, the total number of subjects, unique meeting times, and total units. Do not include meet place or meet times with NULL values.",
    "db_id": "dw",
    "sql": "WITH MeetingPlaceDetails AS ( SELECT c.MEET_PLACE AS room_number, c.MEET_TIME, c.TERM_CODE, c.SUBJECT_ID, c.TOTAL_UNITS, b.BUILDING_NAME, b.BUILDING_NUMBER, ba.CITY AS building_city, ba.STATE AS building_state, fr.AREA, fr.ORGANIZATION_NAME, fmu.MAJOR_USE, scd.COURSE_LEVEL AS course_level, scd.COURSE_DESCRIPTION AS course_description FROM COURSE_CATALOG_SUBJECT_OFFERED c JOIN FAC_ROOMS fr ON c.MEET_PLACE = fr.FAC_ROOM_KEY JOIN FAC_BUILDING b ON fr.BUILDING_KEY = b.FAC_BUILDING_KEY JOIN FAC_MAJOR_USE fmu ON fr.MAJOR_USE_KEY = fmu.MAJOR_USE_KEY LEFT JOIN FAC_BUILDING_ADDRESS ba ON b.FAC_BUILDING_KEY = ba.BUILDING_KEY LEFT JOIN SIS_COURSE_DESCRIPTION scd ON c.SUBJECT_ID = scd.COURSE WHERE c.MEET_PLACE IS NOT NULL AND c.MEET_TIME IS NOT NULL ), MeetingPlaceAggregates AS ( SELECT room_number, BUILDING_NAME, BUILDING_NUMBER, building_city, building_state, AREA, ORGANIZATION_NAME, MAJOR_USE, TERM_CODE, course_level, COUNT(DISTINCT SUBJECT_ID) AS num_subjects, COUNT(DISTINCT MEET_TIME) AS unique_meet_times, SUM(TOTAL_UNITS) AS total_units FROM MeetingPlaceDetails GROUP BY room_number, BUILDING_NAME, BUILDING_NUMBER, building_city, building_state, AREA, ORGANIZATION_NAME, MAJOR_USE, TERM_CODE, course_level ) SELECT room_number, BUILDING_NAME, BUILDING_NUMBER, building_city, building_state, AREA, ORGANIZATION_NAME, MAJOR_USE, TERM_CODE, course_level, num_subjects, unique_meet_times, total_units FROM MeetingPlaceAggregates ORDER BY TERM_CODE, total_units DESC, room_number;",
    "oracle_sql": "WITH MeetingPlaceDetails AS ( SELECT c.MEET_PLACE AS room_number, c.MEET_TIME, c.TERM_CODE, c.SUBJECT_ID, c.TOTAL_UNITS, b.BUILDING_NAME, b.BUILDING_NUMBER, ba.CITY AS building_city, ba.STATE AS building_state, fr.AREA, fr.ORGANIZATION_NAME, fmu.MAJOR_USE, scd.COURSE_LEVEL AS course_level, scd.COURSE_DESCRIPTION AS course_description FROM COURSE_CATALOG_SUBJECT_OFFERED c JOIN FAC_ROOMS fr ON c.MEET_PLACE = fr.FAC_ROOM_KEY JOIN FAC_BUILDING b ON fr.BUILDING_KEY = b.FAC_BUILDING_KEY JOIN FAC_MAJOR_USE fmu ON fr.MAJOR_USE_KEY = fmu.MAJOR_USE_KEY LEFT JOIN FAC_BUILDING_ADDRESS ba ON b.FAC_BUILDING_KEY = ba.BUILDING_KEY LEFT JOIN SIS_COURSE_DESCRIPTION scd ON c.SUBJECT_ID = scd.COURSE WHERE c.MEET_PLACE IS NOT NULL AND c.MEET_TIME IS NOT NULL ), MeetingPlaceAggregates AS ( SELECT room_number, BUILDING_NAME, BUILDING_NUMBER, building_city, building_state, AREA, ORGANIZATION_NAME, MAJOR_USE, TERM_CODE, course_level, COUNT(DISTINCT SUBJECT_ID) AS num_subjects, COUNT(DISTINCT MEET_TIME) AS unique_meet_times, SUM(TOTAL_UNITS) AS total_units FROM MeetingPlaceDetails GROUP BY room_number, BUILDING_NAME, BUILDING_NUMBER, building_city, building_state, AREA, ORGANIZATION_NAME, MAJOR_USE, TERM_CODE, course_level ) SELECT room_number, BUILDING_NAME, BUILDING_NUMBER, building_city, building_state, AREA, ORGANIZATION_NAME, MAJOR_USE, TERM_CODE, course_level, num_subjects, unique_meet_times, total_units FROM MeetingPlaceAggregates ORDER BY TERM_CODE, total_units DESC, room_number;",
    "gold_tables": [
      "dw#sep#COURSE_CATALOG_SUBJECT_OFFERED",
      "dw#sep#FAC_ROOMS",
      "dw#sep#FAC_BUILDING",
      "dw#sep#FAC_MAJOR_USE",
      "dw#sep#FAC_BUILDING_ADDRESS",
      "dw#sep#SIS_COURSE_DESCRIPTION"
    ],
    "mapping": {
      "room number": [
        "COURSE_CATALOG_SUBJECT_OFFERED.MEET_PLACE"
      ],
      "building name": [
        "FAC_BUILDING.BUILDING_NAME"
      ],
      "building number": [
        "FAC_BUILDING.BUILDING_NUMBER"
      ],
      "building city": [
        "FAC_BUILDING_ADDRESS.CITY"
      ],
      "building state": [
        "FAC_BUILDING_ADDRESS.STATE"
      ],
      "area": [
        "FAC_ROOMS.AREA"
      ],
      "organization name": [
        "FAC_ROOMS.ORGANIZATION_NAME"
      ],
      "room usage": [
        "FAC_MAJOR_USE.MAJOR_USE"
      ],
      "term code": [
        "COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE"
      ],
      "course level": [
        "SIS_COURSE_DESCRIPTION.COURSE_LEVEL"
      ],
      "subjects": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID"
      ],
      "meeting times": [
        "COURSE_CATALOG_SUBJECT_OFFERED.MEET_TIME"
      ],
      "units": [
        "COURSE_CATALOG_SUBJECT_OFFERED.TOTAL_UNITS"
      ]
    },
    "join_keys": [
      [
        "FAC_ROOMS.FAC_ROOM_KEY",
        "COURSE_CATALOG_SUBJECT_OFFERED.MEET_PLACE"
      ],
      [
        "FAC_ROOMS.BUILDING_KEY",
        "FAC_BUILDING.FAC_BUILDING_KEY"
      ],
      [
        "FAC_ROOMS.MAJOR_USE_KEY",
        "FAC_MAJOR_USE.MAJOR_USE_KEY"
      ],
      [
        "FAC_BUILDING_ADDRESS.BUILDING_KEY",
        "FAC_BUILDING.FAC_BUILDING_KEY"
      ],
      [
        "SIS_COURSE_DESCRIPTION.COURSE",
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID"
      ]
    ]
  },
  {
    "question": "Consider only books cataloged on or after 2000. For each library material status and department, list the material status, department name, number of associated catalog items, and the total number of enrolled students in courses using those materials. Include subtotals for each material status and a grand total across all status (the corresponding status field is 'Grand Total').",
    "db_id": "dw",
    "sql": "WITH MaterialUsage AS ( SELECT lms.LIBRARY_MATERIAL_STATUS, sc.DEPARTMENT_NAME AS department, COUNT(DISTINCT lrc.LIBRARY_RESERVE_CATALOG_KEY) AS num_catalog_items, SUM(lso.NUM_ENROLLED_STUDENTS) AS total_students FROM LIBRARY_RESERVE_MATRL_DETAIL lrd JOIN LIBRARY_MATERIAL_STATUS lms ON lrd.LIBRARY_MATERIAL_STATUS_KEY = lms.LIBRARY_MATERIAL_STATUS_KEY JOIN LIBRARY_RESERVE_CATALOG lrc ON lrd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY JOIN LIBRARY_SUBJECT_OFFERED lso ON lrd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY LEFT JOIN SIS_SUBJECT_CODE sc ON lso.COURSE_NUMBER = sc.COURSE_NUMBER WHERE lrc.CATALOG_YEAR >= 2000 GROUP BY lms.LIBRARY_MATERIAL_STATUS, sc.DEPARTMENT_NAME ), MaterialSubtotals AS ( SELECT LIBRARY_MATERIAL_STATUS, NULL AS department, SUM(num_catalog_items) AS total_catalog_items, SUM(total_students) AS total_students FROM MaterialUsage GROUP BY LIBRARY_MATERIAL_STATUS ), MaterialGrandTotal AS ( SELECT 'Grand Total' AS LIBRARY_MATERIAL_STATUS, NULL AS department, SUM(num_catalog_items) AS total_catalog_items, SUM(total_students) AS total_students FROM MaterialUsage ), MaterialCombined AS ( SELECT LIBRARY_MATERIAL_STATUS, department, num_catalog_items, total_students FROM MaterialUsage UNION ALL SELECT LIBRARY_MATERIAL_STATUS, department, total_catalog_items, total_students FROM MaterialSubtotals UNION ALL SELECT LIBRARY_MATERIAL_STATUS, department, total_catalog_items, total_students FROM MaterialGrandTotal ) SELECT COALESCE(LIBRARY_MATERIAL_STATUS, 'Subtotal') AS library_material_status, department, num_catalog_items, total_students FROM MaterialCombined ORDER BY CASE WHEN LIBRARY_MATERIAL_STATUS = 'Grand Total' THEN 1 WHEN department IS NULL THEN 2 ELSE 0 END, LIBRARY_MATERIAL_STATUS, department;",
    "oracle_sql": "WITH MaterialUsage AS ( SELECT lms.LIBRARY_MATERIAL_STATUS, sc.DEPARTMENT_NAME AS department, COUNT(DISTINCT lrc.LIBRARY_RESERVE_CATALOG_KEY) AS num_catalog_items, SUM(lso.NUM_ENROLLED_STUDENTS) AS total_students FROM LIBRARY_RESERVE_MATRL_DETAIL lrd JOIN LIBRARY_MATERIAL_STATUS lms ON lrd.LIBRARY_MATERIAL_STATUS_KEY = lms.LIBRARY_MATERIAL_STATUS_KEY JOIN LIBRARY_RESERVE_CATALOG lrc ON lrd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY JOIN LIBRARY_SUBJECT_OFFERED lso ON lrd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY LEFT JOIN SIS_SUBJECT_CODE sc ON lso.COURSE_NUMBER = sc.COURSE_NUMBER WHERE lrc.CATALOG_YEAR >= 2000 GROUP BY lms.LIBRARY_MATERIAL_STATUS, sc.DEPARTMENT_NAME ), MaterialSubtotals AS ( SELECT LIBRARY_MATERIAL_STATUS, NULL AS department, SUM(num_catalog_items) AS total_catalog_items, SUM(total_students) AS total_students FROM MaterialUsage GROUP BY LIBRARY_MATERIAL_STATUS ), MaterialGrandTotal AS ( SELECT 'Grand Total' AS LIBRARY_MATERIAL_STATUS, NULL AS department, SUM(num_catalog_items) AS total_catalog_items, SUM(total_students) AS total_students FROM MaterialUsage ), MaterialCombined AS ( SELECT LIBRARY_MATERIAL_STATUS, department, num_catalog_items, total_students FROM MaterialUsage UNION ALL SELECT LIBRARY_MATERIAL_STATUS, department, total_catalog_items, total_students FROM MaterialSubtotals UNION ALL SELECT LIBRARY_MATERIAL_STATUS, department, total_catalog_items, total_students FROM MaterialGrandTotal ) SELECT COALESCE(LIBRARY_MATERIAL_STATUS, 'Subtotal') AS library_material_status, department, num_catalog_items, total_students FROM MaterialCombined ORDER BY CASE WHEN LIBRARY_MATERIAL_STATUS = 'Grand Total' THEN 1 WHEN department IS NULL THEN 2 ELSE 0 END, LIBRARY_MATERIAL_STATUS, department;",
    "gold_tables": [
      "dw#sep#LIBRARY_RESERVE_MATRL_DETAIL",
      "dw#sep#LIBRARY_MATERIAL_STATUS",
      "dw#sep#LIBRARY_RESERVE_CATALOG",
      "dw#sep#LIBRARY_SUBJECT_OFFERED",
      "dw#sep#SIS_SUBJECT_CODE"
    ],
    "mapping": {
      "cataloged on or after 2000": [
        "LIBRARY_RESERVE_CATALOG.CATALOG_YEAR"
      ],
      "material status": [
        "LIBRARY_MATERIAL_STATUS.LIBRARY_MATERIAL_STATUS"
      ],
      "department name": [
        "SIS_SUBJECT_CODE.DEPARTMENT_NAME"
      ],
      "catalog items": [
        "LIBRARY_RESERVE_CATALOG.LIBRARY_RESERVE_CATALOG_KEY"
      ],
      "enrolled students": [
        "LIBRARY_SUBJECT_OFFERED.NUM_ENROLLED_STUDENTS"
      ]
    },
    "join_keys": [
      [
        "LIBRARY_MATERIAL_STATUS.LIBRARY_MATERIAL_STATUS_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_MATERIAL_STATUS_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_RESERVE_CATALOG_KEY",
        "LIBRARY_RESERVE_CATALOG.LIBRARY_RESERVE_CATALOG_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_SUBJECT_OFFERED_KEY",
        "LIBRARY_SUBJECT_OFFERED.LIBRARY_SUBJECT_OFFERED_KEY"
      ],
      [
        "LIBRARY_SUBJECT_OFFERED.COURSE_NUMBER",
        "SIS_SUBJECT_CODE.COURSE_NUMBER"
      ]
    ]
  },
  {
    "question": "For each department in the library system, list the name of the department, total number of courses using library materials, the number of catalog items associated with those courses, and the average enrollment per course. Include a grand total across all departments (the corresponding department field should be 'Grand Total').",
    "db_id": "dw",
    "sql": "WITH DepartmentLibraryUsage AS ( SELECT lci.DEPARTMENT, lci.COURSE_NAME, COUNT(DISTINCT lrc.LIBRARY_RESERVE_CATALOG_KEY) AS num_catalog_items, SUM(lso.NUM_ENROLLED_STUDENTS) AS total_students FROM LIBRARY_RESERVE_MATRL_DETAIL lrd JOIN LIBRARY_COURSE_INSTRUCTOR lci ON lrd.LIBRARY_COURSE_INSTRUCTOR_KEY = lci.LIBRARY_COURSE_INSTRUCTOR_KEY JOIN LIBRARY_RESERVE_CATALOG lrc ON lrd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY JOIN LIBRARY_SUBJECT_OFFERED lso ON lrd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY WHERE lso.NUM_ENROLLED_STUDENTS > 0 GROUP BY lci.DEPARTMENT, lci.COURSE_NAME ), DepartmentAggregates AS ( SELECT DEPARTMENT, COUNT(DISTINCT COURSE_NAME) AS total_courses, SUM(num_catalog_items) AS total_catalog_items, AVG(total_students) AS avg_students_per_course FROM DepartmentLibraryUsage GROUP BY DEPARTMENT ), GrandTotal AS ( SELECT 'Grand Total' AS DEPARTMENT, SUM(total_courses) AS total_courses, SUM(total_catalog_items) AS total_catalog_items, AVG(avg_students_per_course) AS avg_students_per_course FROM DepartmentAggregates ) SELECT * FROM ( SELECT * FROM GrandTotal UNION ALL SELECT * FROM DepartmentAggregates ) CombinedResults ORDER BY CASE WHEN DEPARTMENT = 'Grand Total' THEN 0 ELSE 1 END, DEPARTMENT;",
    "oracle_sql": "WITH DepartmentLibraryUsage AS ( SELECT lci.DEPARTMENT, lci.COURSE_NAME, COUNT(DISTINCT lrc.LIBRARY_RESERVE_CATALOG_KEY) AS num_catalog_items, SUM(lso.NUM_ENROLLED_STUDENTS) AS total_students FROM LIBRARY_RESERVE_MATRL_DETAIL lrd JOIN LIBRARY_COURSE_INSTRUCTOR lci ON lrd.LIBRARY_COURSE_INSTRUCTOR_KEY = lci.LIBRARY_COURSE_INSTRUCTOR_KEY JOIN LIBRARY_RESERVE_CATALOG lrc ON lrd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY JOIN LIBRARY_SUBJECT_OFFERED lso ON lrd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY WHERE lso.NUM_ENROLLED_STUDENTS > 0 GROUP BY lci.DEPARTMENT, lci.COURSE_NAME ), DepartmentAggregates AS ( SELECT DEPARTMENT, COUNT(DISTINCT COURSE_NAME) AS total_courses, SUM(num_catalog_items) AS total_catalog_items, AVG(total_students) AS avg_students_per_course FROM DepartmentLibraryUsage GROUP BY DEPARTMENT ), GrandTotal AS ( SELECT 'Grand Total' AS DEPARTMENT, SUM(total_courses) AS total_courses, SUM(total_catalog_items) AS total_catalog_items, AVG(avg_students_per_course) AS avg_students_per_course FROM DepartmentAggregates ) SELECT * FROM ( SELECT * FROM GrandTotal UNION ALL SELECT * FROM DepartmentAggregates ) CombinedResults ORDER BY CASE WHEN DEPARTMENT = 'Grand Total' THEN 0 ELSE 1 END, DEPARTMENT;",
    "gold_tables": [
      "dw#sep#LIBRARY_RESERVE_MATRL_DETAIL",
      "dw#sep#LIBRARY_COURSE_INSTRUCTOR",
      "dw#sep#LIBRARY_RESERVE_CATALOG",
      "dw#sep#LIBRARY_SUBJECT_OFFERED"
    ],
    "mapping": {
      "name of the department": [
        "LIBRARY_COURSE_INSTRUCTOR.DEPARTMENT"
      ],
      "courses": [
        "LIBRARY_COURSE_INSTRUCTOR.COURSE_NAME"
      ],
      "catalog items": [
        "LIBRARY_RESERVE_CATALOG.LIBRARY_RESERVE_CATALOG_KEY"
      ],
      "enrollment": [
        "LIBRARY_SUBJECT_OFFERED.NUM_ENROLLED_STUDENTS"
      ]
    },
    "join_keys": [
      [
        "LIBRARY_COURSE_INSTRUCTOR.LIBRARY_COURSE_INSTRUCTOR_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_COURSE_INSTRUCTOR_KEY"
      ],
      [
        "LIBRARY_RESERVE_CATALOG.LIBRARY_RESERVE_CATALOG_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_RESERVE_CATALOG_KEY"
      ],
      [
        "LIBRARY_SUBJECT_OFFERED.LIBRARY_SUBJECT_OFFERED_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_SUBJECT_OFFERED_KEY"
      ]
    ]
  },
  {
    "question": "For each department and school offering courses with materials, list the department name, school name, number of unique course materials, number of courses, average new and used shelf prices of materials, total material records, and number of distinct material statuses. Include a grand total across all schools and departments (the corresponding school and department fields should be null).",
    "db_id": "dw",
    "sql": "WITH MaterialCostDetails AS ( SELECT tso.OFFER_DEPT_NAME AS department_name, tso.SUBJECT_TITLE, tm.TITLE AS material_title, tm.NEW_SHELF_PRICE, tm.USED_SHELF_PRICE, tms.TIP_MATERIAL_STATUS AS material_status, tms.TIP_MATERIAL_STATUS_CODE AS material_status_code, td.RECORD_COUNT AS material_record_count, ts.SCHOOL_NAME AS school_name FROM TIP_DETAIL td JOIN TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY JOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY JOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY JOIN SIS_DEPARTMENT ts ON tso.OFFER_DEPT_CODE = ts.DEPARTMENT_CODE WHERE tso.IS_NO_COURSE_MATERIAL = 'N' ), MaterialCostAggregates AS ( SELECT department_name, school_name, COUNT(DISTINCT material_title) AS num_unique_materials, COUNT(DISTINCT SUBJECT_TITLE) AS num_courses, AVG(NEW_SHELF_PRICE) AS avg_new_price, AVG(USED_SHELF_PRICE) AS avg_used_price, SUM(material_record_count) AS total_material_records, COUNT(DISTINCT material_status) AS num_material_statuses FROM MaterialCostDetails GROUP BY department_name, school_name ), GrandTotal AS ( SELECT NULL AS department_name, NULL AS school_name, COUNT(DISTINCT material_title) AS num_unique_materials, COUNT(DISTINCT SUBJECT_TITLE) AS num_courses, AVG(NEW_SHELF_PRICE) AS avg_new_price, AVG(USED_SHELF_PRICE) AS avg_used_price, SUM(material_record_count) AS total_material_records, COUNT(DISTINCT material_status) AS num_material_statuses FROM MaterialCostDetails ) SELECT department_name, school_name, num_unique_materials, num_courses, avg_new_price, avg_used_price, total_material_records, num_material_statuses FROM MaterialCostAggregates UNION ALL SELECT department_name, school_name, num_unique_materials, num_courses, avg_new_price, avg_used_price, total_material_records, num_material_statuses FROM GrandTotal ORDER BY school_name, department_name;",
    "oracle_sql": "WITH MaterialCostDetails AS ( SELECT tso.OFFER_DEPT_NAME AS department_name, tso.SUBJECT_TITLE, tm.TITLE AS material_title, tm.NEW_SHELF_PRICE, tm.USED_SHELF_PRICE, tms.TIP_MATERIAL_STATUS AS material_status, tms.TIP_MATERIAL_STATUS_CODE AS material_status_code, td.RECORD_COUNT AS material_record_count, ts.SCHOOL_NAME AS school_name FROM TIP_DETAIL td JOIN TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY JOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY JOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY JOIN SIS_DEPARTMENT ts ON tso.OFFER_DEPT_CODE = ts.DEPARTMENT_CODE WHERE tso.IS_NO_COURSE_MATERIAL = 'N' ), MaterialCostAggregates AS ( SELECT department_name, school_name, COUNT(DISTINCT material_title) AS num_unique_materials, COUNT(DISTINCT SUBJECT_TITLE) AS num_courses, AVG(NEW_SHELF_PRICE) AS avg_new_price, AVG(USED_SHELF_PRICE) AS avg_used_price, SUM(material_record_count) AS total_material_records, COUNT(DISTINCT material_status) AS num_material_statuses FROM MaterialCostDetails GROUP BY department_name, school_name ), GrandTotal AS ( SELECT NULL AS department_name, NULL AS school_name, COUNT(DISTINCT material_title) AS num_unique_materials, COUNT(DISTINCT SUBJECT_TITLE) AS num_courses, AVG(NEW_SHELF_PRICE) AS avg_new_price, AVG(USED_SHELF_PRICE) AS avg_used_price, SUM(material_record_count) AS total_material_records, COUNT(DISTINCT material_status) AS num_material_statuses FROM MaterialCostDetails ) SELECT department_name, school_name, num_unique_materials, num_courses, avg_new_price, avg_used_price, total_material_records, num_material_statuses FROM MaterialCostAggregates UNION ALL SELECT department_name, school_name, num_unique_materials, num_courses, avg_new_price, avg_used_price, total_material_records, num_material_statuses FROM GrandTotal ORDER BY school_name, department_name;",
    "gold_tables": [
      "dw#sep#TIP_DETAIL",
      "dw#sep#TIP_MATERIAL",
      "dw#sep#TIP_SUBJECT_OFFERED",
      "dw#sep#TIP_MATERIAL_STATUS",
      "dw#sep#SIS_DEPARTMENT"
    ],
    "mapping": {
      "courses with materials": [
        "TIP_SUBJECT_OFFERED.IS_NO_COURSE_MATERIAL"
      ],
      "department name": [
        "TIP_SUBJECT_OFFERED.OFFER_DEPT_NAME"
      ],
      "school name": [
        "SIS_DEPARTMENT.SCHOOL_NAME"
      ],
      "course materials": [
        "TIP_MATERIAL.TITLE"
      ],
      "courses": [
        "TIP_SUBJECT_OFFERED.SUBJECT_TITLE"
      ],
      "new": [
        "TIP_MATERIAL.NEW_SHELF_PRICE"
      ],
      "used": [
        "TIP_MATERIAL.USED_SHELF_PRICE"
      ],
      "material records": [
        "TIP_DETAIL.RECORD_COUNT"
      ],
      "material statuses": [
        "TIP_MATERIAL_STATUS.TIP_MATERIAL_STATUS"
      ]
    },
    "join_keys": [
      [
        "TIP_MATERIAL.TIP_MATERIAL_KEY",
        "TIP_DETAIL.TIP_MATERIAL_KEY"
      ],
      [
        "TIP_SUBJECT_OFFERED.TIP_SUBJECT_OFFERED_KEY",
        "TIP_DETAIL.TIP_SUBJECT_OFFERED_KEY"
      ],
      [
        "TIP_DETAIL.TIP_MATERIAL_STATUS_KEY",
        "TIP_MATERIAL_STATUS.TIP_MATERIAL_STATUS_KEY"
      ],
      [
        "SIS_DEPARTMENT.DEPARTMENT_CODE",
        "TIP_SUBJECT_OFFERED.OFFER_DEPT_CODE"
      ]
    ]
  },
  {
    "question": "For each TIP material status, list the total number of unique materials associated with the status, the total number of records associated with the status, and the total student enrollment associated with the status. Any material status with null values should be displayed as 'No material status'. Additionally, include a grand total across all material status (the material status for this row should be displayed as 'Grand Total').",
    "db_id": "dw",
    "sql": "SELECT COALESCE(material_status, 'Grand Total') AS material_status, num_materials, total_record_count, total_enrollment FROM (SELECT CASE WHEN material_status IS NULL THEN 'No material status' ELSE material_status END AS material_status, COUNT(DISTINCT material_title) AS num_materials, SUM(RECORD_COUNT) AS total_record_count, SUM(NUM_ENROLLED_STUDENTS) AS total_enrollment FROM (SELECT tms.TIP_MATERIAL_STATUS AS material_status, tm.TITLE AS material_title, td.RECORD_COUNT, tso.NUM_ENROLLED_STUDENTS FROM TIP_DETAIL td JOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY JOIN TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY JOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY WHERE td.RECORD_COUNT > 0) MaterialStatusDetails GROUP BY material_status WITH ROLLUP) MaterialStatusAggregates ORDER BY CASE WHEN material_status = 'Grand Total' THEN 1 ELSE 0 END, total_record_count DESC, material_status;",
    "oracle_sql": "WITH MaterialStatusDetails AS ( SELECT tms.TIP_MATERIAL_STATUS AS material_status, tm.TITLE AS material_title, td.RECORD_COUNT, tso.NUM_ENROLLED_STUDENTS FROM TIP_DETAIL td JOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY JOIN TIP_MATERIAL tm ON td.TIP_MATERIAL_KEY = tm.TIP_MATERIAL_KEY JOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY WHERE td.RECORD_COUNT > 0 ), MaterialStatusAggregates AS ( SELECT CASE WHEN GROUPING(material_status) = 1 THEN NULL WHEN material_status IS NULL THEN 'No material status' ELSE material_status END AS material_status, COUNT(DISTINCT material_title) AS num_materials, SUM(RECORD_COUNT) AS total_record_count, SUM(NUM_ENROLLED_STUDENTS) AS total_enrollment FROM MaterialStatusDetails GROUP BY ROLLUP(material_status) ) SELECT COALESCE(material_status, 'Grand Total') AS material_status, num_materials, total_record_count, total_enrollment FROM MaterialStatusAggregates ORDER BY CASE WHEN material_status = 'Grand Total' THEN 1 ELSE 0 END, total_record_count DESC, material_status;",
    "gold_tables": [
      "dw#sep#TIP_DETAIL",
      "dw#sep#TIP_MATERIAL_STATUS",
      "dw#sep#TIP_MATERIAL",
      "dw#sep#TIP_SUBJECT_OFFERED"
    ],
    "mapping": {
      "TIP material status": [
        "TIP_MATERIAL_STATUS.TIP_MATERIAL_STATUS"
      ],
      "materials": [
        "TIP_MATERIAL.TITLE"
      ],
      "records": [
        "TIP_DETAIL.RECORD_COUNT"
      ],
      "student enrollment": [
        "TIP_SUBJECT_OFFERED.NUM_ENROLLED_STUDENTS"
      ]
    },
    "join_keys": [
      [
        "TIP_DETAIL.TIP_MATERIAL_STATUS_KEY",
        "TIP_MATERIAL_STATUS.TIP_MATERIAL_STATUS_KEY"
      ],
      [
        "TIP_DETAIL.TIP_MATERIAL_KEY",
        "TIP_MATERIAL.TIP_MATERIAL_KEY"
      ],
      [
        "TIP_DETAIL.TIP_SUBJECT_OFFERED_KEY",
        "TIP_SUBJECT_OFFERED.TIP_SUBJECT_OFFERED_KEY"
      ]
    ]
  },
  {
    "question": "For each room, list its associated building name, floor number, room number, ownership type, organization name, number of rooms, area, and percentage of area relative to the building. Include subtotals across floors, subtotals across all floors for each building, and a grand total across all buildings. For the subtotal for each building and the grand total, the percentage of area should be relative to area of all buildings. All numeric values should be rounded to integers and formatted using commas as thousands separators except the relative percentages which should be rounded to two decimal places.",
    "db_id": "dw",
    "sql": "SELECT Building_Name, FLOOR, Room, OWNERSHIP_TYPE, Organization_Name, FORMAT(Total_Rooms, 0) AS Total_Rooms, FORMAT(Total_Area, 0) AS Total_Area, Percent_Of_Total FROM (SELECT 0 AS SortOrder, NULL AS Building_Name, NULL AS FLOOR, NULL AS Room, NULL AS OWNERSHIP_TYPE, NULL AS Organization_Name, SUM(Total_Rooms) AS Total_Rooms, SUM(Total_Area) AS Total_Area, 100 AS Percent_Of_Total FROM (SELECT b.BUILDING_NAME_LONG AS Building_Name, f.FLOOR, r.BUILDING_ROOM AS Room, COUNT(r.FCLT_ROOM_KEY) AS Total_Rooms, SUM(r.AREA) AS Total_Area, b.OWNERSHIP_TYPE, o.ORGANIZATION_NAME AS Organization_Name, (SELECT SUM(r2.AREA) FROM FCLT_ROOMS r2 JOIN FCLT_FLOOR f2 ON r2.FCLT_FLOOR_KEY = f2.FCLT_FLOOR_KEY WHERE f2.FCLT_BUILDING_KEY = f.FCLT_BUILDING_KEY) AS Building_Total_Area, (SELECT SUM(r3.AREA) FROM FCLT_ROOMS r3) AS Overall_Total_Area FROM FCLT_FLOOR f LEFT JOIN FCLT_ROOMS r ON f.FCLT_FLOOR_KEY = r.FCLT_FLOOR_KEY LEFT JOIN FCLT_BUILDING b ON f.FCLT_BUILDING_KEY = b.FCLT_BUILDING_KEY LEFT JOIN FCLT_ORGANIZATION o ON r.FCLT_ORGANIZATION_KEY = o.FCLT_ORGANIZATION_KEY GROUP BY b.BUILDING_NAME_LONG, f.FLOOR, r.BUILDING_ROOM, b.OWNERSHIP_TYPE, o.ORGANIZATION_NAME, f.FCLT_BUILDING_KEY) AS FloorStats WHERE Building_Name IS NOT NULL UNION ALL SELECT 1 AS SortOrder, Building_Name, FLOOR, Room, OWNERSHIP_TYPE, Organization_Name, Total_Rooms, Total_Area, CASE WHEN FLOOR IS NOT NULL AND Building_Total_Area > 0 THEN ROUND(Total_Area * 100.0 / Building_Total_Area, 2) WHEN FLOOR IS NULL AND Building_Name IS NOT NULL AND Overall_Total_Area > 0 THEN ROUND(Total_Area * 100.0 / Overall_Total_Area, 2) ELSE NULL END AS Percent_Of_Total FROM (SELECT b.BUILDING_NAME_LONG AS Building_Name, f.FLOOR, r.BUILDING_ROOM AS Room, COUNT(r.FCLT_ROOM_KEY) AS Total_Rooms, SUM(r.AREA) AS Total_Area, b.OWNERSHIP_TYPE, o.ORGANIZATION_NAME AS Organization_Name, (SELECT SUM(r2.AREA) FROM FCLT_ROOMS r2 JOIN FCLT_FLOOR f2 ON r2.FCLT_FLOOR_KEY = f2.FCLT_FLOOR_KEY WHERE f2.FCLT_BUILDING_KEY = f.FCLT_BUILDING_KEY) AS Building_Total_Area, (SELECT SUM(r3.AREA) FROM FCLT_ROOMS r3) AS Overall_Total_Area FROM FCLT_FLOOR f LEFT JOIN FCLT_ROOMS r ON f.FCLT_FLOOR_KEY = r.FCLT_FLOOR_KEY LEFT JOIN FCLT_BUILDING b ON f.FCLT_BUILDING_KEY = b.FCLT_BUILDING_KEY LEFT JOIN FCLT_ORGANIZATION o ON r.FCLT_ORGANIZATION_KEY = o.FCLT_ORGANIZATION_KEY GROUP BY b.BUILDING_NAME_LONG, f.FLOOR, r.BUILDING_ROOM, b.OWNERSHIP_TYPE, o.ORGANIZATION_NAME, f.FCLT_BUILDING_KEY WITH ROLLUP) AS RollupWithPercentages WHERE Building_Name IS NOT NULL) AS AllData ORDER BY SortOrder, Building_Name, FLOOR, Room;",
    "oracle_sql": "WITH FloorStats AS (SELECT f.FCLT_BUILDING_KEY, b.BUILDING_NAME_LONG AS Building_Name, f.FLOOR, r.BUILDING_ROOM AS Room, COUNT(r.FCLT_ROOM_KEY) AS Room_Count, SUM(r.AREA) AS Total_Floor_Area, SUM(SUM(r.AREA)) OVER (PARTITION BY f.FCLT_BUILDING_KEY) AS Building_Total_Area, SUM(SUM(r.AREA)) OVER () AS Overall_Total_Area, b.OWNERSHIP_TYPE, o.ORGANIZATION_NAME AS Organization_Name FROM FCLT_FLOOR f LEFT JOIN FCLT_ROOMS r ON f.FCLT_FLOOR_KEY = r.FCLT_FLOOR_KEY LEFT JOIN FCLT_BUILDING b ON f.FCLT_BUILDING_KEY = b.FCLT_BUILDING_KEY LEFT JOIN FCLT_ORGANIZATION o ON r.FCLT_ORGANIZATION_KEY = o.FCLT_ORGANIZATION_KEY GROUP BY f.FCLT_BUILDING_KEY, b.BUILDING_NAME_LONG, f.FLOOR, r.BUILDING_ROOM, b.OWNERSHIP_TYPE, o.ORGANIZATION_NAME), RollupWithPercentages AS (SELECT Building_Name, FLOOR, CASE WHEN GROUPING(Room) = 0 THEN Room ELSE NULL END AS Room, CASE WHEN GROUPING_ID(Building_Name, FLOOR, Room) > 0 THEN NULL ELSE OWNERSHIP_TYPE END AS OWNERSHIP_TYPE, MAX(Organization_Name) AS Organization_Name, SUM(Room_Count) AS Total_Rooms, SUM(Total_Floor_Area) AS Total_Area, MAX(Building_Total_Area) AS Building_Total_Area, MAX(Overall_Total_Area) AS Overall_Total_Area FROM FloorStats GROUP BY ROLLUP(Building_Name, FLOOR, Room), OWNERSHIP_TYPE, Organization_Name), GrandTotal AS (SELECT NULL AS Building_Name, NULL AS FLOOR, NULL AS Room, NULL AS OWNERSHIP_TYPE, NULL AS Organization_Name, SUM(Total_Rooms) AS Total_Rooms, SUM(Total_Area) AS Total_Area, NULL AS Building_Total_Area, MAX(Overall_Total_Area) AS Overall_Total_Area, 0 AS SortOrder, 100 AS Percent_Of_Total FROM RollupWithPercentages WHERE Building_Name IS NOT NULL), AllData AS (SELECT 0 AS SortOrder, Building_Name, FLOOR, Room, NULL AS OWNERSHIP_TYPE, NULL AS Organization_Name, Total_Rooms, Total_Area, Percent_Of_Total FROM GrandTotal UNION ALL SELECT 1 AS SortOrder, Building_Name, FLOOR, Room, CASE WHEN Building_Name IS NOT NULL THEN OWNERSHIP_TYPE ELSE NULL END AS OWNERSHIP_TYPE, Organization_Name, Total_Rooms, Total_Area, CASE WHEN FLOOR IS NOT NULL AND Building_Total_Area > 0 THEN ROUND(Total_Area * 100.0 / Building_Total_Area, 2) WHEN FLOOR IS NULL AND Building_Name IS NOT NULL AND Overall_Total_Area > 0 THEN ROUND(Total_Area * 100.0 / Overall_Total_Area, 2) ELSE NULL END AS Percent_Of_Total FROM RollupWithPercentages) SELECT Building_Name, FLOOR, Room, OWNERSHIP_TYPE, Organization_Name, TO_CHAR(Total_Rooms, '999,999') AS Total_Rooms, TO_CHAR(Total_Area, '999,999,999') AS Total_Area, Percent_Of_Total FROM AllData ORDER BY SortOrder, Building_Name, FLOOR, Room;",
    "gold_tables": [
      "dw#sep#FCLT_ROOMS",
      "dw#sep#FCLT_FLOOR",
      "dw#sep#FCLT_BUILDING",
      "dw#sep#FCLT_ORGANIZATION"
    ],
    "mapping": {
      "room": [
        "FCLT_ROOMS.FCLT_ROOM_KEY"
      ],
      "building name": [
        "FCLT_BUILDING.BUILDING_NAME_LONG"
      ],
      "floor number": [
        "FCLT_FLOOR.FLOOR"
      ],
      "room number": [
        "FCLT_ROOMS.BUILDING_ROOM"
      ],
      "ownership type": [
        "FCLT_BUILDING.OWNERSHIP_TYPE"
      ],
      "organization name": [
        "FCLT_ORGANIZATION.ORGANIZATION_NAME"
      ],
      "number of rooms": [
        "FCLT_ROOMS.FCLT_ROOM_KEY"
      ],
      "area": [
        "FCLT_ROOMS.AREA"
      ]
    },
    "join_keys": [
      [
        "FCLT_FLOOR.FCLT_FLOOR_KEY",
        "FCLT_ROOMS.FCLT_FLOOR_KEY"
      ],
      [
        "FCLT_BUILDING.FCLT_BUILDING_KEY",
        "FCLT_FLOOR.FCLT_BUILDING_KEY"
      ],
      [
        "FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY",
        "FCLT_ROOMS.FCLT_ORGANIZATION_KEY"
      ]
    ]
  },
  {
    "question": "For each financial aid year and academic year, list the number of fiscal periods, quarters, the start term date, the end term date, and number of distinct department-level term parameters.",
    "db_id": "dw",
    "sql": "WITH FinancialAidDetails AS ( SELECT at.TERM_CODE, at.TERM_DESCRIPTION, at.ACADEMIC_YEAR, at.FINANCIAL_AID_YEAR, td.START_DATE AS Term_Start_Date, td.END_DATE AS Term_End_Date, tm.FISCAL_PERIOD, tm.FISCAL_YEAR, tq.FY_QUARTER_CODE, tp.TERM_PARAMETER AS Dept_Term_Param FROM ACADEMIC_TERMS at JOIN TIME_DAY td ON at.TERM_START_DATE = td.CALENDAR_DATE JOIN TIME_MONTH tm ON td.FISCAL_PERIOD = tm.FISCAL_PERIOD AND td.FISCAL_YEAR = tm.FISCAL_YEAR JOIN TIME_QUARTER tq ON tm.FISCAL_YEAR = tq.FISCAL_YEAR AND tm.FY_QUARTER_CODE = tq.FY_QUARTER_CODE LEFT JOIN ACADEMIC_TERM_PARAMETER tp ON at.TERM_CODE = tp.TERM_CODE WHERE at.FINANCIAL_AID_YEAR IS NOT NULL ) SELECT FINANCIAL_AID_YEAR, ACADEMIC_YEAR, COUNT(DISTINCT FISCAL_PERIOD) AS Total_Fiscal_Periods, COUNT(DISTINCT FY_QUARTER_CODE) AS Total_Quarters, MIN(Term_Start_Date) AS First_Term_Start_Date, MAX(Term_End_Date) AS Last_Term_End_Date, COUNT(DISTINCT Dept_Term_Param) AS Distinct_Term_Params FROM FinancialAidDetails GROUP BY FINANCIAL_AID_YEAR, ACADEMIC_YEAR ORDER BY FINANCIAL_AID_YEAR DESC, ACADEMIC_YEAR ASC;",
    "oracle_sql": "WITH FinancialAidDetails AS ( SELECT at.TERM_CODE, at.TERM_DESCRIPTION, at.ACADEMIC_YEAR, at.FINANCIAL_AID_YEAR, td.START_DATE AS Term_Start_Date, td.END_DATE AS Term_End_Date, tm.FISCAL_PERIOD, tm.FISCAL_YEAR, tq.FY_QUARTER_CODE, tp.TERM_PARAMETER AS Dept_Term_Param FROM ACADEMIC_TERMS at JOIN TIME_DAY td ON at.TERM_START_DATE = td.CALENDAR_DATE JOIN TIME_MONTH tm ON td.FISCAL_PERIOD = tm.FISCAL_PERIOD AND td.FISCAL_YEAR = tm.FISCAL_YEAR JOIN TIME_QUARTER tq ON tm.FISCAL_YEAR = tq.FISCAL_YEAR AND tm.FY_QUARTER_CODE = tq.FY_QUARTER_CODE LEFT JOIN ACADEMIC_TERM_PARAMETER tp ON at.TERM_CODE = tp.TERM_CODE WHERE at.FINANCIAL_AID_YEAR IS NOT NULL ) SELECT FINANCIAL_AID_YEAR, ACADEMIC_YEAR, COUNT(DISTINCT FISCAL_PERIOD) AS Total_Fiscal_Periods, COUNT(DISTINCT FY_QUARTER_CODE) AS Total_Quarters, MIN(Term_Start_Date) AS First_Term_Start_Date, MAX(Term_End_Date) AS Last_Term_End_Date, COUNT(DISTINCT Dept_Term_Param) AS Distinct_Term_Params FROM FinancialAidDetails GROUP BY FINANCIAL_AID_YEAR, ACADEMIC_YEAR ORDER BY FINANCIAL_AID_YEAR DESC, ACADEMIC_YEAR ASC;",
    "gold_tables": [
      "dw#sep#ACADEMIC_TERMS",
      "dw#sep#TIME_DAY",
      "dw#sep#TIME_MONTH",
      "dw#sep#TIME_QUARTER",
      "dw#sep#ACADEMIC_TERM_PARAMETER"
    ],
    "mapping": {
      "financial aid year": [
        "ACADEMIC_TERMS.FINANCIAL_AID_YEAR"
      ],
      "academic year": [
        "ACADEMIC_TERMS.ACADEMIC_YEAR"
      ],
      "fiscal periods": [
        "TIME_MONTH.FISCAL_PERIOD"
      ],
      "quarters": [
        "TIME_QUARTER.FY_QUARTER_CODE"
      ],
      "start term date": [
        "TIME_DAY.START_DATE"
      ],
      "end term date": [
        "TIME_DAY.END_DATE"
      ],
      "department-level term parameters": [
        "ACADEMIC_TERM_PARAMETER.TERM_PARAMETER"
      ]
    },
    "join_keys": [
      [
        "ACADEMIC_TERMS.TERM_START_DATE",
        "TIME_DAY.CALENDAR_DATE"
      ],
      [
        "TIME_DAY.FISCAL_PERIOD",
        "TIME_MONTH.FISCAL_PERIOD"
      ],
      [
        "TIME_QUARTER.FISCAL_YEAR",
        "TIME_MONTH.FISCAL_YEAR"
      ],
      [
        "ACADEMIC_TERM_PARAMETER.TERM_CODE",
        "ACADEMIC_TERMS.TERM_CODE"
      ]
    ]
  },
  {
    "question": "Group buildings by campus sectors. For each group, list the campus sector, name of the building, city and state where the building is located, total number of floors, total assignable area, total number of rooms, total number of organizations, ownership type, and a rank column indicating the order (1-indexed) of this row within each sector based on the descending order of assignable area. Include subtotals for each sector and a grand total across all sectors. The subtotal and grand total only need to computed over the total number of floors and assignable area.",
    "db_id": "dw",
    "sql": "WITH BuildingArea AS ( SELECT b.CAMPUS_SECTOR, b.BUILDING_NAME_LONG AS Building_Name, f.FLOOR AS Floor_Number, b.ASSIGNABLE_AREA, ba.CITY AS Building_City, ba.STATE AS Building_State FROM FCLT_BUILDING b LEFT JOIN FCLT_FLOOR f ON b.FCLT_BUILDING_KEY = f.FCLT_BUILDING_KEY LEFT JOIN FCLT_BUILDING_ADDRESS ba ON b.FCLT_BUILDING_KEY = ba.FCLT_BUILDING_KEY ), TotalRooms AS ( SELECT b.BUILDING_NAME_LONG AS Building_Name, COUNT(r.FCLT_ROOM_KEY) AS Total_Rooms FROM FCLT_BUILDING b LEFT JOIN FCLT_ROOMS r ON b.FCLT_BUILDING_KEY = r.FCLT_BUILDING_KEY GROUP BY b.BUILDING_NAME_LONG ), TotalOrganizations AS ( SELECT b.BUILDING_NAME_LONG AS Building_Name, COUNT(DISTINCT o.FCLT_ORGANIZATION_KEY) AS Total_Organizations FROM FCLT_BUILDING b LEFT JOIN FCLT_ROOMS r ON b.FCLT_BUILDING_KEY = r.FCLT_BUILDING_KEY LEFT JOIN FCLT_ORGANIZATION o ON r.FCLT_ORGANIZATION_KEY = o.FCLT_ORGANIZATION_KEY GROUP BY b.BUILDING_NAME_LONG ), BuildingDetails AS ( SELECT b.BUILDING_NAME_LONG AS Building_Name, b.OWNERSHIP_TYPE AS Ownership_Type FROM FCLT_BUILDING b ), RollupRows AS ( SELECT CAMPUS_SECTOR, Building_Name, MAX(Building_City) AS Building_City, MAX(Building_State) AS Building_State, COUNT(DISTINCT Floor_Number) AS Total_Floors, SUM(ASSIGNABLE_AREA) AS Assignable_Area FROM BuildingArea GROUP BY CAMPUS_SECTOR, Building_Name WITH ROLLUP ), RankedRows AS ( SELECT rr.CAMPUS_SECTOR AS Campus_Sector, rr.Building_Name, rr.Building_City, rr.Building_State, rr.Total_Floors, rr.Assignable_Area, tr.Total_Rooms, toz.Total_Organizations, bd.Ownership_Type, CASE WHEN rr.Building_Name IS NOT NULL THEN RANK() OVER (PARTITION BY rr.CAMPUS_SECTOR ORDER BY rr.Assignable_Area DESC) - 1 ELSE NULL END AS Adjusted_Sector_Rank FROM RollupRows rr LEFT JOIN TotalRooms tr ON rr.Building_Name = tr.Building_Name LEFT JOIN TotalOrganizations toz ON rr.Building_Name = toz.Building_Name LEFT JOIN BuildingDetails bd ON rr.Building_Name = bd.Building_Name WHERE rr.CAMPUS_SECTOR IS NOT NULL ), GrandTotal AS ( SELECT NULL AS Campus_Sector, NULL AS Building_Name, NULL AS Building_City, NULL AS Building_State, SUM(Total_Floors) AS Total_Floors, SUM(Assignable_Area) AS Assignable_Area, NULL AS Total_Rooms, NULL AS Total_Organizations, NULL AS Ownership_Type, 1 AS Adjusted_Sector_Rank FROM RankedRows ) SELECT Campus_Sector, Building_Name, Building_City, Building_State, Total_Floors, FORMAT(Assignable_Area, 0) AS Assignable_Area, Total_Rooms, Total_Organizations, Ownership_Type, Adjusted_Sector_Rank FROM RankedRows UNION ALL SELECT Campus_Sector, Building_Name, NULL AS Building_City, NULL AS Building_State, Total_Floors, FORMAT(Assignable_Area, 0) AS Assignable_Area, NULL AS Total_Rooms, NULL AS Total_Organizations, Ownership_Type, Adjusted_Sector_Rank FROM GrandTotal ORDER BY Campus_Sector, Adjusted_Sector_Rank, Building_Name;",
    "oracle_sql": "WITH BuildingArea AS ( SELECT b.CAMPUS_SECTOR, b.BUILDING_NAME_LONG AS Building_Name, f.FLOOR AS Floor_Number, b.ASSIGNABLE_AREA, ba.CITY AS Building_City, ba.STATE AS Building_State FROM FCLT_BUILDING b LEFT JOIN FCLT_FLOOR f ON b.FCLT_BUILDING_KEY = f.FCLT_BUILDING_KEY LEFT JOIN FCLT_BUILDING_ADDRESS ba ON b.FCLT_BUILDING_KEY = ba.FCLT_BUILDING_KEY ), TotalRooms AS ( SELECT b.BUILDING_NAME_LONG AS Building_Name, COUNT(r.FCLT_ROOM_KEY) AS Total_Rooms FROM FCLT_BUILDING b LEFT JOIN FCLT_ROOMS r ON b.FCLT_BUILDING_KEY = r.FCLT_BUILDING_KEY GROUP BY b.BUILDING_NAME_LONG ), TotalOrganizations AS ( SELECT b.BUILDING_NAME_LONG AS Building_Name, COUNT(DISTINCT o.FCLT_ORGANIZATION_KEY) AS Total_Organizations FROM FCLT_BUILDING b LEFT JOIN FCLT_ROOMS r ON b.FCLT_BUILDING_KEY = r.FCLT_BUILDING_KEY LEFT JOIN FCLT_ORGANIZATION o ON r.FCLT_ORGANIZATION_KEY = o.FCLT_ORGANIZATION_KEY GROUP BY b.BUILDING_NAME_LONG ), BuildingDetails AS ( SELECT b.BUILDING_NAME_LONG AS Building_Name, b.OWNERSHIP_TYPE AS Ownership_Type FROM FCLT_BUILDING b ), RollupRows AS ( SELECT CASE WHEN GROUPING(CAMPUS_SECTOR) = 1 THEN NULL ELSE CAMPUS_SECTOR END AS Campus_Sector, CASE WHEN GROUPING(Building_Name) = 1 THEN NULL ELSE Building_Name END AS Building_Name, CASE WHEN GROUPING(Building_Name) = 1 THEN NULL ELSE MAX(Building_City) END AS Building_City, CASE WHEN GROUPING(Building_Name) = 1 THEN NULL ELSE MAX(Building_State) END AS Building_State, COUNT(DISTINCT Floor_Number) AS Total_Floors, SUM(ASSIGNABLE_AREA) AS Assignable_Area FROM BuildingArea GROUP BY ROLLUP(CAMPUS_SECTOR, Building_Name) ), RankedRows AS ( SELECT rr.Campus_Sector, rr.Building_Name, rr.Building_City, rr.Building_State, rr.Total_Floors, rr.Assignable_Area, tr.Total_Rooms, toz.Total_Organizations, bd.Ownership_Type, CASE WHEN rr.Building_Name IS NOT NULL THEN RANK() OVER (PARTITION BY rr.Campus_Sector ORDER BY rr.Assignable_Area DESC) - 1 ELSE NULL END AS Adjusted_Sector_Rank FROM RollupRows rr LEFT JOIN TotalRooms tr ON rr.Building_Name = tr.Building_Name LEFT JOIN TotalOrganizations toz ON rr.Building_Name = toz.Building_Name LEFT JOIN BuildingDetails bd ON rr.Building_Name = bd.Building_Name WHERE rr.Campus_Sector IS NOT NULL ), GrandTotal AS ( SELECT NULL AS Campus_Sector, NULL AS Building_Name, NULL AS Building_City, NULL AS Building_State, SUM(Total_Floors) AS Total_Floors, SUM(Assignable_Area) AS Assignable_Area, NULL AS Total_Rooms, NULL AS Total_Organizations, NULL AS Ownership_Type, 1 AS Adjusted_Sector_Rank FROM RankedRows ) SELECT Campus_Sector, Building_Name, Building_City, Building_State, Total_Floors, TO_CHAR(Assignable_Area, '999,999,999') AS Assignable_Area, Total_Rooms, Total_Organizations, Ownership_Type, Adjusted_Sector_Rank FROM RankedRows UNION ALL SELECT Campus_Sector, Building_Name, NULL AS Building_City, NULL AS Building_State, Total_Floors, TO_CHAR(Assignable_Area, '999,999,999') AS Assignable_Area, NULL AS Total_Rooms, NULL AS Total_Organizations, Ownership_Type, Adjusted_Sector_Rank FROM GrandTotal ORDER BY Campus_Sector, Adjusted_Sector_Rank, Building_Name;",
    "gold_tables": [
      "dw#sep#FCLT_BUILDING",
      "dw#sep#FCLT_FLOOR",
      "dw#sep#FCLT_BUILDING_ADDRESS",
      "dw#sep#FCLT_ROOMS",
      "dw#sep#FCLT_ORGANIZATION"
    ],
    "mapping": {
      "campus sector": [
        "FCLT_BUILDING.CAMPUS_SECTOR"
      ],
      "name of the building": [
        "FCLT_BUILDING.BUILDING_NAME_LONG"
      ],
      "city": [
        "FCLT_BUILDING_ADDRESS.CITY"
      ],
      "state": [
        "FCLT_BUILDING_ADDRESS.STATE"
      ],
      "floors": [
        "FCLT_FLOOR.FLOOR"
      ],
      "area": [
        "FCLT_BUILDING.ASSIGNABLE_AREA"
      ],
      "rooms": [
        "FCLT_ROOMS.FCLT_ROOM_KEY"
      ],
      "organizations": [
        "FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY"
      ],
      "ownership type": [
        "FCLT_BUILDING.OWNERSHIP_TYPE"
      ]
    },
    "join_keys": [
      [
        "FCLT_BUILDING.FCLT_BUILDING_KEY",
        "FCLT_FLOOR.FCLT_BUILDING_KEY"
      ],
      [
        "FCLT_BUILDING.FCLT_BUILDING_KEY",
        "FCLT_BUILDING_ADDRESS.FCLT_BUILDING_KEY"
      ],
      [
        "FCLT_BUILDING.FCLT_BUILDING_KEY",
        "FCLT_ROOMS.FCLT_BUILDING_KEY"
      ],
      [
        "FCLT_ROOMS.FCLT_BUILDING_KEY",
        "FCLT_BUILDING.FCLT_BUILDING_KEY"
      ],
      [
        "FCLT_ROOMS.FCLT_ORGANIZATION_KEY",
        "FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY"
      ]
    ]
  },
  {
    "question": "For each department, list the name of the department, the title of the TIP material associated with the department, author, ISBN, library term code, and whether it is available in the library reserves ('Available in Library' if yes and 'Not Available in Library' otherwise), the total number of instructors per library book for the department, the total number of materials available in the library for the department, and the total number of available materials across all departments.",
    "db_id": "dw",
    "sql": "WITH TIPMaterials AS ( SELECT tm.TITLE AS TIP_Title, tm.ISBN AS TIP_ISBN, tso.OFFER_DEPT_NAME AS TIP_Department FROM TIP_MATERIAL tm JOIN TIP_DETAIL td ON tm.TIP_MATERIAL_KEY = td.TIP_MATERIAL_KEY JOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY ), InstructorCounts AS ( SELECT lrc.CATALOG_ISBN AS ISBN, COUNT(DISTINCT lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY) AS Num_Instructors FROM LIBRARY_RESERVE_CATALOG lrc JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lrc.LIBRARY_RESERVE_CATALOG_KEY = lrmd.LIBRARY_RESERVE_CATALOG_KEY GROUP BY lrc.CATALOG_ISBN ), DepartmentMaterials AS ( SELECT lso.OFFER_DEPT_NAME AS Department, COUNT(DISTINCT lrc.CATALOG_ISBN) AS Total_Available_Materials_Per_Dept FROM LIBRARY_RESERVE_CATALOG lrc JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lrc.LIBRARY_RESERVE_CATALOG_KEY = lrmd.LIBRARY_RESERVE_CATALOG_KEY JOIN LIBRARY_SUBJECT_OFFERED lso ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY GROUP BY lso.OFFER_DEPT_NAME ), OverallMaterials AS ( SELECT COUNT(DISTINCT lrc.CATALOG_ISBN) AS Total_Available_Materials_All_Departments FROM LIBRARY_RESERVE_CATALOG lrc JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lrc.LIBRARY_RESERVE_CATALOG_KEY = lrmd.LIBRARY_RESERVE_CATALOG_KEY ) SELECT DISTINCT tm.TIP_Department AS Department, tm.TIP_Title, tm.TIP_ISBN, lrmd.TERM_CODE AS Library_Term_Code, CASE WHEN lrc.CATALOG_ISBN IS NOT NULL THEN 'Available in Library' ELSE 'Not Available in Library' END AS Availability_Status, COALESCE(ic.Num_Instructors, 0) AS Num_Instructors, COALESCE(dm.Total_Available_Materials_Per_Dept, 0) AS Total_Available_Materials_Per_Dept, COALESCE(om.Total_Available_Materials_All_Departments, 0) AS Total_Available_Materials_All_Departments FROM TIPMaterials tm LEFT JOIN LIBRARY_RESERVE_CATALOG lrc ON tm.TIP_ISBN = lrc.CATALOG_ISBN LEFT JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lrc.LIBRARY_RESERVE_CATALOG_KEY = lrmd.LIBRARY_RESERVE_CATALOG_KEY LEFT JOIN InstructorCounts ic ON tm.TIP_ISBN = ic.ISBN LEFT JOIN DepartmentMaterials dm ON tm.TIP_Department = dm.Department LEFT JOIN OverallMaterials om ON 1=1 ORDER BY tm.TIP_Department, tm.TIP_Title;",
    "oracle_sql": "WITH TIPMaterials AS (SELECT tm.TITLE AS TIP_Title, tm.AUTHOR AS TIP_Author, tm.ISBN AS TIP_ISBN, tso.OFFER_DEPT_NAME AS TIP_Department FROM TIP_MATERIAL tm JOIN TIP_DETAIL td ON tm.TIP_MATERIAL_KEY = td.TIP_MATERIAL_KEY JOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY), LibraryReserves AS (SELECT lrc.CATALOG_ISBN AS Library_ISBN, lso.OFFER_DEPT_NAME AS Library_Department, lrmd.TERM_CODE, lci.INSTRUCTOR_NAME AS Library_Instructor_Name FROM LIBRARY_RESERVE_CATALOG lrc JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lrc.LIBRARY_RESERVE_CATALOG_KEY = lrmd.LIBRARY_RESERVE_CATALOG_KEY JOIN LIBRARY_SUBJECT_OFFERED lso ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY JOIN LIBRARY_COURSE_INSTRUCTOR lci ON lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY = lci.LIBRARY_COURSE_INSTRUCTOR_KEY), CombinedData AS (SELECT tm.TIP_Title, tm.TIP_Author, tm.TIP_ISBN, tm.TIP_Department, lr.TERM_CODE, CASE WHEN lr.Library_ISBN IS NOT NULL THEN 'Available in Library' ELSE 'Not Available in Library' END AS Availability_Status, COUNT(DISTINCT lr.Library_Instructor_Name) OVER (PARTITION BY lr.Library_Department) AS Num_Instructors_Per_Dept FROM TIPMaterials tm LEFT JOIN LibraryReserves lr ON tm.TIP_ISBN = lr.Library_ISBN) SELECT DISTINCT TIP_Department, TIP_Title, TIP_Author, TIP_ISBN, TERM_CODE, Availability_Status, Num_Instructors_Per_Dept, COUNT(CASE WHEN Availability_Status = 'Available in Library' THEN 1 END) OVER (PARTITION BY TIP_Department) AS Available_Materials_Per_Dept, COUNT(CASE WHEN Availability_Status = 'Available in Library' THEN 1 END) OVER () AS Total_Available_Materials FROM CombinedData ORDER BY TIP_Department, TIP_Title;",
    "gold_tables": [
      "dw#sep#TIP_MATERIAL",
      "dw#sep#TIP_DETAIL",
      "dw#sep#TIP_SUBJECT_OFFERED",
      "dw#sep#LIBRARY_RESERVE_CATALOG",
      "dw#sep#LIBRARY_RESERVE_MATRL_DETAIL",
      "dw#sep#LIBRARY_SUBJECT_OFFERED"
    ],
    "mapping": {
      "name of the department": [
        "TIP_SUBJECT_OFFERED.OFFER_DEPT_NAME"
      ],
      "title of the TIP material": [
        "TIP_MATERIAL.TITLE"
      ],
      "author": [
        "TIP_MATERIAL.AUTHOR"
      ],
      "ISBN": [
        "TIP_MATERIAL.ISBN"
      ],
      "library term code": [
        "LIBRARY_RESERVE_MATRL_DETAIL.TERM_CODE"
      ],
      "available in the library reserves": [
        "LIBRARY_RESERVE_CATALOG.CATALOG_ISBN"
      ],
      "instructors": [
        "LIBRARY_COURSE_INSTRUCTOR.INSTRUCTOR_NAME"
      ]
    },
    "join_keys": [
      [
        "TIP_MATERIAL.TIP_MATERIAL_KEY",
        "TIP_DETAIL.TIP_MATERIAL_KEY"
      ],
      [
        "TIP_SUBJECT_OFFERED.TIP_SUBJECT_OFFERED_KEY",
        "TIP_DETAIL.TIP_SUBJECT_OFFERED_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_RESERVE_CATALOG_KEY",
        "LIBRARY_RESERVE_CATALOG.LIBRARY_RESERVE_CATALOG_KEY"
      ],
      [
        "LIBRARY_SUBJECT_OFFERED.LIBRARY_SUBJECT_OFFERED_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_SUBJECT_OFFERED_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_COURSE_INSTRUCTOR_KEY",
        "LIBRARY_COURSE_INSTRUCTOR.LIBRARY_COURSE_INSTRUCTOR_KEY"
      ]
    ]
  },
  {
    "question": "For each department and material status, list the name of the department, the material status, the number of TIP materials associated with this department and status, the number of library materials associated with this department and status, the total number of TIP and library materials associated with this department and status. Include a subtotal for each department and a grand total across all departments.",
    "db_id": "dw",
    "sql": "WITH TIPMaterialStatuses AS ( SELECT tso.OFFER_DEPT_NAME AS Department, tms.TIP_MATERIAL_STATUS AS Status, COUNT(td.TIP_MATERIAL_KEY) AS Total_TIP_Materials FROM TIP_DETAIL td JOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY JOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY GROUP BY tso.OFFER_DEPT_NAME, tms.TIP_MATERIAL_STATUS ), LibraryMaterialStatuses AS ( SELECT lso.OFFER_DEPT_NAME AS Department, lms.LIBRARY_MATERIAL_STATUS AS Status, COUNT(lrmd.LIBRARY_RESERVE_CATALOG_KEY) AS Total_Library_Materials FROM LIBRARY_RESERVE_MATRL_DETAIL lrmd JOIN LIBRARY_SUBJECT_OFFERED lso ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY JOIN LIBRARY_MATERIAL_STATUS lms ON lrmd.LIBRARY_MATERIAL_STATUS_KEY = lms.LIBRARY_MATERIAL_STATUS_KEY GROUP BY lso.OFFER_DEPT_NAME, lms.LIBRARY_MATERIAL_STATUS ), CombinedStatuses AS ( SELECT Department, Status, Total_TIP_Materials, 0 AS Total_Library_Materials FROM TIPMaterialStatuses UNION ALL SELECT Department, Status, 0 AS Total_TIP_Materials, Total_Library_Materials FROM LibraryMaterialStatuses ) SELECT Department, Status, SUM(Total_TIP_Materials) AS Total_TIP_Materials, SUM(Total_Library_Materials) AS Total_Library_Materials, SUM(Total_TIP_Materials + Total_Library_Materials) AS Total_All_Materials FROM CombinedStatuses GROUP BY Department, Status WITH ROLLUP ORDER BY Department, Status;",
    "oracle_sql": "WITH TIPMaterialStatuses AS ( SELECT tso.OFFER_DEPT_NAME AS Department, tms.TIP_MATERIAL_STATUS AS Status, COUNT(td.TIP_MATERIAL_KEY) AS Total_TIP_Materials FROM TIP_DETAIL td JOIN TIP_SUBJECT_OFFERED tso ON td.TIP_SUBJECT_OFFERED_KEY = tso.TIP_SUBJECT_OFFERED_KEY JOIN TIP_MATERIAL_STATUS tms ON td.TIP_MATERIAL_STATUS_KEY = tms.TIP_MATERIAL_STATUS_KEY GROUP BY tso.OFFER_DEPT_NAME, tms.TIP_MATERIAL_STATUS ), LibraryMaterialStatuses AS ( SELECT lso.OFFER_DEPT_NAME AS Department, lms.LIBRARY_MATERIAL_STATUS AS Status, COUNT(lrmd.LIBRARY_RESERVE_CATALOG_KEY) AS Total_Library_Materials FROM LIBRARY_RESERVE_MATRL_DETAIL lrmd JOIN LIBRARY_SUBJECT_OFFERED lso ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY JOIN LIBRARY_MATERIAL_STATUS lms ON lrmd.LIBRARY_MATERIAL_STATUS_KEY = lms.LIBRARY_MATERIAL_STATUS_KEY GROUP BY lso.OFFER_DEPT_NAME, lms.LIBRARY_MATERIAL_STATUS ), CombinedStatuses AS ( SELECT COALESCE(tms.Department, lms.Department) AS Department, COALESCE(tms.Status, lms.Status) AS Status, COALESCE(tms.Total_TIP_Materials, 0) AS Total_TIP_Materials, COALESCE(lms.Total_Library_Materials, 0) AS Total_Library_Materials FROM TIPMaterialStatuses tms FULL OUTER JOIN LibraryMaterialStatuses lms ON tms.Department = lms.Department AND tms.Status = lms.Status ) SELECT Department, Status, SUM(Total_TIP_Materials) AS Total_TIP_Materials, SUM(Total_Library_Materials) AS Total_Library_Materials, SUM(Total_TIP_Materials + Total_Library_Materials) AS Total_All_Materials FROM CombinedStatuses GROUP BY ROLLUP(Department, Status) ORDER BY Department, Status;",
    "gold_tables": [
      "dw#sep#TIP_DETAIL",
      "dw#sep#TIP_SUBJECT_OFFERED",
      "dw#sep#TIP_MATERIAL_STATUS",
      "dw#sep#LIBRARY_RESERVE_MATRL_DETAIL",
      "dw#sep#LIBRARY_SUBJECT_OFFERED",
      "dw#sep#LIBRARY_MATERIAL_STATUS"
    ],
    "mapping": {
      "name of the department": [
        "TIP_SUBJECT_OFFERED.OFFER_DEPT_NAME"
      ],
      "material status": [
        "TIP_MATERIAL_STATUS.TIP_MATERIAL_STATUS"
      ],
      "TIP materials": [
        "TIP_DETAIL.TIP_MATERIAL_KEY"
      ],
      "library materials": [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_RESERVE_CATALOG_KEY"
      ]
    },
    "join_keys": [
      [
        "TIP_DETAIL.TIP_SUBJECT_OFFERED_KEY",
        "TIP_SUBJECT_OFFERED.TIP_SUBJECT_OFFERED_KEY"
      ],
      [
        "TIP_MATERIAL_STATUS.TIP_MATERIAL_STATUS_KEY",
        "TIP_DETAIL.TIP_MATERIAL_STATUS_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_SUBJECT_OFFERED_KEY",
        "LIBRARY_SUBJECT_OFFERED.LIBRARY_SUBJECT_OFFERED_KEY"
      ],
      [
        "LIBRARY_MATERIAL_STATUS.LIBRARY_MATERIAL_STATUS_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_MATERIAL_STATUS_KEY"
      ]
    ]
  },
  {
    "question": "For each building that is not a subdivision, list the building number, full name, street address, building type, occupancy date, ownership type, and site location. You should also include three rows at the end showing the number of owned, leased, all buildings at MIT that are not subdivisions, in the format of (null, #building Buildings, null, null, null, null, null).",
    "db_id": "dw",
    "sql": "SELECT * FROM (SELECT FAC_BUILDING.BUILDING_NUMBER AS BUILDING, FAC_BUILDING.BUILDING_NAME_LONG AS NAME, BUILDINGS.BUILDING_STREET_ADDRESS AS `STREET ADDRESS`, FAC_BUILDING.BUILDING_TYPE AS TYPE, FAC_BUILDING.DATE_OCCUPIED, FAC_BUILDING.OWNERSHIP_TYPE AS OWNERSHIP, FAC_BUILDING.SITE AS SITE FROM FAC_BUILDING_ADDRESS JOIN FAC_BUILDING ON FAC_BUILDING_ADDRESS.BUILDING_KEY = FAC_BUILDING.FAC_BUILDING_KEY JOIN BUILDINGS ON FAC_BUILDING_ADDRESS.BUILDING_KEY = BUILDINGS.BUILDING_KEY WHERE FAC_BUILDING_ADDRESS.ADDRESS_PURPOSE = 'STREET' AND FAC_BUILDING.PARENT_BUILDING_NUMBER IS NULL) AS tbl1 UNION ALL SELECT NULL, CONCAT(COUNT(FAC_BUILDING.BUILDING_NUMBER), ' Buildings'), NULL, NULL, NULL, NULL, NULL FROM FAC_BUILDING_ADDRESS JOIN FAC_BUILDING ON FAC_BUILDING_ADDRESS.BUILDING_KEY = FAC_BUILDING.FAC_BUILDING_KEY WHERE FAC_BUILDING.OWNERSHIP_TYPE = 'OWNED' AND FAC_BUILDING_ADDRESS.ADDRESS_PURPOSE = 'STREET' AND FAC_BUILDING.PARENT_BUILDING_NUMBER IS NULL AND FAC_BUILDING.SITE = 'MIT' UNION ALL SELECT NULL, CONCAT(COUNT(FAC_BUILDING.BUILDING_NUMBER), ' Buildings'), NULL, NULL, NULL, NULL, NULL FROM FAC_BUILDING_ADDRESS JOIN FAC_BUILDING ON FAC_BUILDING_ADDRESS.BUILDING_KEY = FAC_BUILDING.FAC_BUILDING_KEY WHERE FAC_BUILDING.OWNERSHIP_TYPE = 'LEASED' AND FAC_BUILDING_ADDRESS.ADDRESS_PURPOSE = 'STREET' AND FAC_BUILDING.PARENT_BUILDING_NUMBER IS NULL AND FAC_BUILDING.SITE = 'MIT' UNION ALL SELECT NULL, CONCAT(COUNT(FAC_BUILDING.BUILDING_NUMBER), ' Buildings'), NULL, NULL, NULL, NULL, NULL FROM FAC_BUILDING_ADDRESS JOIN FAC_BUILDING ON FAC_BUILDING_ADDRESS.BUILDING_KEY = FAC_BUILDING.FAC_BUILDING_KEY WHERE FAC_BUILDING_ADDRESS.ADDRESS_PURPOSE = 'STREET' AND FAC_BUILDING.PARENT_BUILDING_NUMBER IS NULL AND FAC_BUILDING.SITE = 'MIT';",
    "oracle_sql": "SELECT * FROM ( SELECT FAC_BUILDING.BUILDING_NUMBER AS BUILDING, FAC_BUILDING.BUILDING_NAME_LONG AS NAME, BUILDINGS.BUILDING_STREET_ADDRESS AS \"STREET ADDRESS\", FAC_BUILDING.BUILDING_TYPE AS TYPE, FAC_BUILDING.DATE_OCCUPIED, FAC_BUILDING.OWNERSHIP_TYPE AS OWNERSHIP, FAC_BUILDING.SITE AS SITE FROM FAC_BUILDING_ADDRESS JOIN FAC_BUILDING on FAC_BUILDING_ADDRESS.BUILDING_KEY = FAC_BUILDING.FAC_BUILDING_KEY JOIN BUILDINGS on FAC_BUILDING_ADDRESS.BUILDING_KEY = BUILDINGS.BUILDING_KEY WHERE FAC_BUILDING_ADDRESS.ADDRESS_PURPOSE = 'STREET' AND FAC_BUILDING.PARENT_BUILDING_NUMBER IS NULL ) UNION ALL SELECT null, TO_CHAR(COUNT(FAC_BUILDING.BUILDING_NUMBER)) || ' Buildings', null, null, null, null, null FROM FAC_BUILDING_ADDRESS JOIN FAC_BUILDING on FAC_BUILDING_ADDRESS.BUILDING_KEY = FAC_BUILDING.FAC_BUILDING_KEY WHERE FAC_BUILDING.OWNERSHIP_TYPE = 'OWNED' AND FAC_BUILDING_ADDRESS.ADDRESS_PURPOSE = 'STREET' AND FAC_BUILDING.PARENT_BUILDING_NUMBER IS NULL AND FAC_BUILDING.SITE = 'MIT' UNION ALL SELECT null, TO_CHAR(COUNT(FAC_BUILDING.BUILDING_NUMBER)) || ' Buildings', null, null, null, null, null FROM FAC_BUILDING_ADDRESS JOIN FAC_BUILDING ON FAC_BUILDING_ADDRESS.BUILDING_KEY = FAC_BUILDING.FAC_BUILDING_KEY WHERE FAC_BUILDING.OWNERSHIP_TYPE = 'LEASED' AND FAC_BUILDING_ADDRESS.ADDRESS_PURPOSE = 'STREET' AND FAC_BUILDING.PARENT_BUILDING_NUMBER IS NULL AND FAC_BUILDING.SITE = 'MIT' UNION ALL SELECT null, TO_CHAR(COUNT(FAC_BUILDING.BUILDING_NUMBER)) || ' Buildings', null, null, null, null, null FROM FAC_BUILDING_ADDRESS JOIN FAC_BUILDING ON FAC_BUILDING_ADDRESS.BUILDING_KEY = FAC_BUILDING.FAC_BUILDING_KEY WHERE FAC_BUILDING_ADDRESS.ADDRESS_PURPOSE = 'STREET' AND FAC_BUILDING.PARENT_BUILDING_NUMBER IS NULL AND FAC_BUILDING.SITE = 'MIT';",
    "gold_tables": [
      "dw#sep#FAC_BUILDING_ADDRESS",
      "dw#sep#FAC_BUILDING",
      "dw#sep#BUILDINGS"
    ],
    "mapping": {
      "subdivision": [
        "FAC_BUILDING.PARENT_BUILDING_NUMBER"
      ],
      "building number": [
        "FAC_BUILDING.BUILDING_NUMBER"
      ],
      "full name": [
        "FAC_BUILDING.BUILDING_NAME_LONG"
      ],
      "street address": [
        "BUILDINGS.BUILDING_STREET_ADDRESS",
        "FAC_BUILDING_ADDRESS.ADDRESS_PURPOSE"
      ],
      "building type": [
        "FAC_BUILDING.BUILDING_TYPE"
      ],
      "occupancy date": [
        "FAC_BUILDING.DATE_OCCUPIED"
      ],
      "ownership type": [
        "FAC_BUILDING.OWNERSHIP_TYPE"
      ],
      "site location": [
        "FAC_BUILDING.SITE"
      ]
    },
    "join_keys": [
      [
        "FAC_BUILDING_ADDRESS.BUILDING_KEY",
        "FAC_BUILDING.FAC_BUILDING_KEY"
      ],
      [
        "BUILDINGS.BUILDING_KEY",
        "FAC_BUILDING_ADDRESS.BUILDING_KEY"
      ],
      [
        "FAC_BUILDING.FAC_BUILDING_KEY",
        "FAC_BUILDING_ADDRESS.BUILDING_KEY"
      ],
      [
        "FAC_BUILDING.FAC_BUILDING_KEY",
        "FAC_BUILDING_ADDRESS.BUILDING_KEY"
      ],
      [
        "FAC_BUILDING.FAC_BUILDING_KEY",
        "FAC_BUILDING_ADDRESS.BUILDING_KEY"
      ]
    ]
  },
  {
    "question": "For each owned building that is not a subdivision, list the construction start year, the building number, and the year of initial occupancy. Display the construction start year only if it differs from the previous row. If the year of initial occupancy or construction start year is unknown, display 'UNKNOWN'. You should also include a row at the end showing the total number of owned buildings that are not subdivisions, in the format of (null, #building Buildings, null).",
    "db_id": "dw",
    "sql": "SELECT CASE WHEN LAG(year_construct_began) OVER (ORDER BY year_construct_began, building_sort, BUILDING_NUMBER) = year_construct_began THEN NULL WHEN BUILDING_NUMBER IS NULL THEN NULL ELSE year_construct_began END AS `YEAR CONSTRUCT BEGAN`, BUILDING_NUMBER AS BUILDING, year_occupied AS `YEAR INITIALLY OCCUPIED` FROM (SELECT year_construct_began, temp2.BUILDING_NUMBER, CASE WHEN FAC_BUILDING.BUILDING_NUMBER IS NOT NULL THEN IFNULL(DATE_FORMAT(STR_TO_DATE(FAC_BUILDING.DATE_OCCUPIED, '%m/%d/%Y'), '%Y'), 'UNKNOWN') ELSE NULL END AS year_occupied, CASE WHEN FAC_BUILDING.BUILDING_NUMBER IS NOT NULL THEN building_sort ELSE NULL END AS building_sort FROM (SELECT CASE WHEN BUILDING_NUMBER IS NOT NULL THEN year_construct_began ELSE CONCAT(year_construct_began, '*') END AS year_construct_began, BUILDING_NUMBER FROM (SELECT IFNULL(DATE_FORMAT(STR_TO_DATE(DATE_BUILT, '%m/%d/%Y'), '%Y'), 'UNKNOWN') AS year_construct_began, BUILDING_NUMBER FROM FAC_BUILDING WHERE ownership_type = 'OWNED' AND PARENT_BUILDING_NUMBER IS NULL) temp1 GROUP BY year_construct_began, BUILDING_NUMBER HAVING year_construct_began IS NOT NULL) temp2 LEFT JOIN FAC_BUILDING ON FAC_BUILDING.BUILDING_NUMBER = temp2.BUILDING_NUMBER) temp3 UNION ALL SELECT NULL, CONCAT(COUNT(FAC_BUILDING.BUILDING_NUMBER), ' Buildings'), NULL FROM FAC_BUILDING WHERE ownership_type = 'OWNED' AND PARENT_BUILDING_NUMBER IS NULL;",
    "oracle_sql": "SELECT CASE WHEN LAG(year_construct_began) OVER (ORDER BY year_construct_began, building_sort, BUILDING_NUMBER) = year_construct_began THEN NULL WHEN BUILDING_NUMBER IS NULL THEN NULL ELSE year_construct_began END AS \"YEAR CONSTRUCT BEGAN\", BUILDING_NUMBER AS BUILDING, year_occupied AS \"YEAR INITIALLY OCCUPIED\" FROM ( SELECT year_construct_began, temp2.BUILDING_NUMBER, CASE WHEN FAC_BUILDING.BUILDING_NUMBER IS NOT NULL THEN NVL(TO_CHAR(TO_DATE(FAC_BUILDING.DATE_OCCUPIED, 'MM/DD/YYYY'), 'YYYY'), 'UNKNOWN') ELSE NULL END AS year_occupied, CASE WHEN FAC_BUILDING.BUILDING_NUMBER IS NOT NULL THEN building_sort ELSE NULL END AS building_sort FROM ( SELECT CASE WHEN BUILDING_NUMBER IS NOT NULL THEN year_construct_began ELSE year_construct_began || '*' END AS year_construct_began, BUILDING_NUMBER FROM ( SELECT NVL(TO_CHAR(TO_DATE(DATE_BUILT, 'MM/DD/YYYY'), 'YYYY'), 'UNKNOWN') AS year_construct_began, BUILDING_NUMBER FROM FAC_BUILDING WHERE ownership_type = 'OWNED' AND PARENT_BUILDING_NUMBER IS NULL ) temp1 GROUP BY year_construct_began, BUILDING_NUMBER HAVING year_construct_began IS NOT NULL ) temp2 LEFT JOIN FAC_BUILDING ON FAC_BUILDING.BUILDING_NUMBER = temp2.BUILDING_NUMBER ) temp3 UNION ALL SELECT NULL, TO_CHAR(COUNT(FAC_BUILDING.BUILDING_NUMBER)) || ' Buildings', NULL FROM FAC_BUILDING WHERE ownership_type = 'OWNED' AND PARENT_BUILDING_NUMBER IS NULL;",
    "gold_tables": [
      "dw#sep#FAC_BUILDING"
    ],
    "mapping": {
      "subdivision": [
        "FAC_BUILDING.PARENT_BUILDING_NUMBER"
      ],
      "construction start year": [
        "FAC_BUILDING.DATE_BUILT"
      ],
      "building number": [
        "FAC_BUILDING.PARENT_BUILDING_NUMBER"
      ],
      "year of initial occupancy": [
        "FAC_BUILDING.DATE_OCCUPIED"
      ]
    },
    "join_keys": []
  },
  {
    "question": "Group all buildings at MIT into either owned or leased. For each group, state the ownership type, usage type, number of buildings, gross square footage, number of rooms, and the number of associated organizations. Display the ownership type only if it differs from the previous row. Include subtotals for each group and a grand total across all groups. The subtotal and grand total rows should not include ownership type and usage type. Footage should be rounded to integers and formatted using commas as thousands separators.",
    "db_id": "dw",
    "sql": "SELECT CASE WHEN LAG(OWNERSHIP) OVER (ORDER BY OWNERSHIP_TYPE DESC, TYPE) = OWNERSHIP THEN NULL ELSE OWNERSHIP END AS OWNERSHIP, TYPE, BUILDINGS, GROSS_SQFT, ROOM_COUNT, ORG_COUNT FROM (SELECT CASE WHEN FLOOR.OWNERSHIP_TYPE IS NULL OR FLOOR.BUILDING_USE IS NULL THEN 'UNKNOWN' ELSE CONCAT(FLOOR.OWNERSHIP_TYPE, '2') END AS OWNERSHIP_TYPE, CASE WHEN FLOOR.BUILDING_USE IS NULL OR FLOOR.OWNERSHIP_TYPE IS NULL THEN NULL ELSE FLOOR.OWNERSHIP_TYPE END AS OWNERSHIP, FLOOR.BUILDING_USE AS TYPE, COUNT(DISTINCT COALESCE(FLOOR.PARENT_BUILDING_NUMBER, FLOOR.FCLT_BUILDING_KEY)) AS BUILDINGS, SUM(FLOOR.EXT_GROSS_AREA) AS GROSS_SQFT, COUNT(DISTINCT rm.FCLT_ROOM_KEY) AS ROOM_COUNT, COUNT(DISTINCT org.FCLT_ORGANIZATION_KEY) AS ORG_COUNT FROM FCLT_BUILDING_HIST FLOOR LEFT JOIN FCLT_ROOMS rm ON FLOOR.FCLT_BUILDING_KEY = rm.FCLT_BUILDING_KEY LEFT JOIN FCLT_ORGANIZATION org ON rm.FCLT_ORGANIZATION_KEY = org.FCLT_ORGANIZATION_KEY WHERE FLOOR.SITE = 'MIT' GROUP BY FLOOR.OWNERSHIP_TYPE, FLOOR.BUILDING_USE ORDER BY FLOOR.OWNERSHIP_TYPE DESC, FLOOR.BUILDING_USE) AS tbltmp;",
    "oracle_sql": "SELECT CASE WHEN LAG(OWNERSHIP) OVER (ORDER BY OWNERSHIP_TYPE DESC, TYPE) = OWNERSHIP THEN NULL ELSE OWNERSHIP END AS OWNERSHIP, TYPE, BUILDINGS, GROSS_SQFT, ROOM_COUNT, ORG_COUNT FROM ( SELECT CASE WHEN GROUPING(FLOOR.OWNERSHIP_TYPE) = 1 AND GROUPING(FLOOR.BUILDING_USE) = 0 THEN FLOOR.OWNERSHIP_TYPE || '1' ELSE FLOOR.OWNERSHIP_TYPE || '2' END AS OWNERSHIP_TYPE, CASE WHEN GROUPING(FLOOR.BUILDING_USE) = 1 AND GROUPING(FLOOR.OWNERSHIP_TYPE) = 0 THEN null WHEN GROUPING(FLOOR.BUILDING_USE) = 1 AND GROUPING(FLOOR.OWNERSHIP_TYPE) = 1 THEN null ELSE FLOOR.OWNERSHIP_TYPE END AS OWNERSHIP, FLOOR.BUILDING_USE AS TYPE, COUNT(DISTINCT NVL(FLOOR.PARENT_BUILDING_NUMBER, FLOOR.FCLT_BUILDING_KEY)) AS BUILDINGS, TO_CHAR(SUM(FLOOR.EXT_GROSS_AREA), '999,999,999,999') AS GROSS_SQFT, COUNT(DISTINCT rm.FCLT_ROOM_KEY) AS ROOM_COUNT, COUNT(DISTINCT org.FCLT_ORGANIZATION_KEY) AS ORG_COUNT FROM FCLT_BUILDING_HIST FLOOR LEFT JOIN FCLT_ROOMS rm ON FLOOR.FCLT_BUILDING_KEY = rm.FCLT_BUILDING_KEY LEFT JOIN FCLT_ORGANIZATION org ON rm.FCLT_ORGANIZATION_KEY = org.FCLT_ORGANIZATION_KEY WHERE FLOOR.SITE = 'MIT' GROUP BY ROLLUP(FLOOR.OWNERSHIP_TYPE, FLOOR.BUILDING_USE) ORDER BY FLOOR.OWNERSHIP_TYPE DESC, FLOOR.BUILDING_USE ) tbltmp;",
    "gold_tables": [
      "dw#sep#FCLT_BUILDING_HIST",
      "dw#sep#FCLT_ROOMS",
      "dw#sep#FCLT_ORGANIZATION"
    ],
    "mapping": {
      "buildings at MIT": [
        "FCLT_BUILDING_HIST.SITE"
      ],
      "ownership type": [
        "FCLT_BUILDING_HIST.OWNERSHIP_TYPE"
      ],
      "usage type": [
        "FCLT_BUILDING_HIST.BUILDING_USE"
      ],
      "buildings": [
        "FCLT_BUILDING_HIST.PARENT_BUILDING_NUMBER",
        "FCLT_BUILDING_HIST.FCLT_BUILDING_KEY"
      ],
      "gross square footage": [
        "FCLT_BUILDING_HIST.EXT_GROSS_AREA"
      ],
      "rooms": [
        "FCLT_ROOMS.FCLT_ROOM_KEY"
      ],
      "organizations": [
        "FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY"
      ]
    },
    "join_keys": [
      [
        "FCLT_ROOMS.FCLT_BUILDING_KEY",
        "FCLT_BUILDING_HIST.FCLT_BUILDING_KEY"
      ],
      [
        "FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY",
        "FCLT_ROOMS.FCLT_ORGANIZATION_KEY"
      ]
    ]
  },
  {
    "question": "For each building use, list the type, the number of distinct buildings (excluding subdivisions) of this use, the total gross square footage of these buildings, and the number of unique organizations associated with the rooms in these buildings. If the building is used as a residence, display the usage type as \"RESIDENTIAL.\" You should also include a row at the end showing the total number of buildings, the gross square footage, and the number of organizations across all types of building use. All numerical values should be rounded to integers and formatted using commas as thousands separators.",
    "db_id": "dw",
    "sql": "SELECT * FROM (SELECT CASE WHEN FLOOR.BUILDING_USE = 'RESIDENT' THEN 'RESIDENTIAL' ELSE FLOOR.BUILDING_USE END AS TYPE, COUNT(DISTINCT COALESCE(FLOOR.PARENT_BUILDING_NUMBER, FLOOR.FCLT_BUILDING_KEY)) AS BUILDINGS, FORMAT(SUM(FLOOR.EXT_GROSS_AREA), 0) AS GROSS_SQFT, COUNT(DISTINCT org.FCLT_ORGANIZATION_KEY) AS NUM_ORGANIZATIONS FROM FCLT_BUILDING FLOOR LEFT JOIN FCLT_ROOMS rm ON FLOOR.FCLT_BUILDING_KEY = rm.FCLT_BUILDING_KEY LEFT JOIN FCLT_ORGANIZATION org ON rm.FCLT_ORGANIZATION_KEY = org.FCLT_ORGANIZATION_KEY WHERE FLOOR.BUILDING_USE IS NOT NULL GROUP BY FLOOR.BUILDING_USE) AS derived_table UNION ALL SELECT NULL AS TYPE, COUNT(DISTINCT COALESCE(FLOOR.PARENT_BUILDING_NUMBER, FLOOR.FCLT_BUILDING_KEY)) AS BUILDINGS, FORMAT(SUM(FLOOR.EXT_GROSS_AREA), 0) AS GROSS_SQFT, COUNT(DISTINCT org.FCLT_ORGANIZATION_KEY) AS NUM_ORGANIZATIONS FROM FCLT_BUILDING FLOOR LEFT JOIN FCLT_ROOMS rm ON FLOOR.FCLT_BUILDING_KEY = rm.FCLT_BUILDING_KEY LEFT JOIN FCLT_ORGANIZATION org ON rm.FCLT_ORGANIZATION_KEY = org.FCLT_ORGANIZATION_KEY;",
    "oracle_sql": "SELECT * FROM ( SELECT CASE WHEN FLOOR.BUILDING_USE = 'RESIDENT' THEN 'RESIDENTIAL' ELSE FLOOR.BUILDING_USE END AS TYPE, COUNT(DISTINCT NVL(FLOOR.PARENT_BUILDING_NUMBER, FLOOR.FCLT_BUILDING_KEY)) AS BUILDINGS, TO_CHAR(SUM(FLOOR.EXT_GROSS_AREA), '999,999,999,999,999') AS GROSS_SQFT, COUNT(DISTINCT org.FCLT_ORGANIZATION_KEY) AS NUM_ORGANIZATIONS FROM FCLT_BUILDING FLOOR LEFT JOIN FCLT_ROOMS rm ON FLOOR.FCLT_BUILDING_KEY = rm.FCLT_BUILDING_KEY LEFT JOIN FCLT_ORGANIZATION org ON rm.FCLT_ORGANIZATION_KEY = org.FCLT_ORGANIZATION_KEY WHERE FLOOR.BUILDING_USE IS NOT NULL GROUP BY FLOOR.BUILDING_USE ) UNION ALL SELECT NULL AS TYPE, COUNT(DISTINCT NVL(FLOOR.PARENT_BUILDING_NUMBER, FLOOR.FCLT_BUILDING_KEY)) AS BUILDINGS, TO_CHAR(SUM(FLOOR.EXT_GROSS_AREA), '999,999,999,999,999') AS GROSS_SQFT, COUNT(DISTINCT org.FCLT_ORGANIZATION_KEY) AS NUM_ORGANIZATIONS FROM FCLT_BUILDING FLOOR LEFT JOIN FCLT_ROOMS rm ON FLOOR.FCLT_BUILDING_KEY = rm.FCLT_BUILDING_KEY LEFT JOIN FCLT_ORGANIZATION org ON rm.FCLT_ORGANIZATION_KEY = org.FCLT_ORGANIZATION_KEY;",
    "gold_tables": [
      "dw#sep#FCLT_BUILDING",
      "dw#sep#FCLT_ROOMS",
      "dw#sep#FCLT_ORGANIZATION"
    ],
    "mapping": {
      "building use": [
        "FCLT_BUILDING.BUILDING_USE"
      ],
      "buildings": [
        "FCLT_BUILDING.PARENT_BUILDING_NUMBER",
        "FCLT_BUILDING.FCLT_BUILDING_KEY"
      ],
      "gross square footage": [
        "FCLT_BUILDING.EXT_GROSS_AREA"
      ],
      "organizations": [
        "FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY"
      ]
    },
    "join_keys": [
      [
        "FCLT_ROOMS.FCLT_BUILDING_KEY",
        "FCLT_BUILDING.FCLT_BUILDING_KEY"
      ],
      [
        "FCLT_ROOMS.FCLT_ORGANIZATION_KEY",
        "FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY"
      ],
      [
        "FCLT_ROOMS.FCLT_BUILDING_KEY",
        "FCLT_BUILDING.FCLT_BUILDING_KEY"
      ],
      [
        "FCLT_ROOMS.FCLT_ORGANIZATION_KEY",
        "FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY"
      ]
    ]
  },
  {
    "question": "For each organization except Cambridge-MIT Institute, list its ID, number, level, formatted name according to level (if level is 2, there should be 1 space before the name, if level is 3, there should be 2 space before the name, up to level 6), whether it is assignable ('ASSIGNABLE' if assignable, 'NON-ASSIGNABLE' otherwise), total area, number of rooms, and average room area. Area and number of rooms should be rounded to integers and formatted using commas as thousands separators.",
    "db_id": "dw",
    "sql": "SELECT o1.organization_id, organization_number, organization_level, CASE WHEN organization_level = 2 THEN CONCAT(' ', organization_name) WHEN organization_level = 3 THEN CONCAT(' ', organization_name) WHEN organization_level = 4 THEN CONCAT(' ', organization_name) WHEN organization_level = 5 THEN CONCAT(' ', organization_name) WHEN organization_level = 6 THEN CONCAT(' ', organization_name) ELSE organization_name END AS formatted_name, CASE WHEN ASSIGNABLE = 1 THEN 'ASSIGNABLE' ELSE 'NON-ASSIGNABLE' END AS assign, (SELECT FORMAT(SUM(area), 0) FROM FCLT_ROOMS r JOIN FCLT_ORGANIZATION o ON r.FCLT_ORGANIZATION_KEY = o.FCLT_ORGANIZATION_KEY WHERE o.organization_id = o1.organization_id) AS area, (SELECT FORMAT(COUNT(ROOM), 0) FROM FCLT_ROOMS r JOIN FCLT_ORGANIZATION o ON r.FCLT_ORGANIZATION_KEY = o.FCLT_ORGANIZATION_KEY WHERE o.organization_id = o1.organization_id) AS rmcnt, (SELECT FORMAT(AVG(area), 0) FROM FCLT_ROOMS r JOIN FCLT_ORGANIZATION o ON r.FCLT_ORGANIZATION_KEY = o.FCLT_ORGANIZATION_KEY WHERE o.organization_id = o1.organization_id) AS area_avg FROM FCLT_ORGANIZATION o1 JOIN MASTER_DEPT_HIERARCHY ON o1.DLC_KEY = MASTER_DEPT_HIERARCHY.DLC_KEY WHERE o1.organization_name NOT IN ('CAMBRIDGE-MIT INST');",
    "oracle_sql": "SELECT o1.organization_id, organization_number, organization_level, CASE WHEN organization_level = 2 THEN ' ' || organization_name WHEN organization_level = 3 THEN ' ' || organization_name WHEN organization_level = 4 THEN ' ' || organization_name WHEN organization_level = 5 THEN ' ' || organization_name WHEN organization_level = 6 THEN ' ' || organization_name ELSE organization_name END AS formatted_name, CASE WHEN ASSIGNABLE = 1 THEN 'ASSIGNABLE' ELSE 'NON-ASSIGNABLE' END AS assign, (SELECT TO_CHAR(SUM(area), '999,999,999') FROM FCLT_ROOMS r JOIN FCLT_ORGANIZATION o on r.FCLT_ORGANIZATION_KEY = o.FCLT_ORGANIZATION_KEY WHERE o.organization_id = o1.organization_id) AS area, (SELECT TO_CHAR(COUNT(ROOM), '999,999,999') FROM FCLT_ROOMS r JOIN FCLT_ORGANIZATION o on r.FCLT_ORGANIZATION_KEY = o.FCLT_ORGANIZATION_KEY WHERE o.organization_id = o1.organization_id) AS rmcnt, (SELECT TO_CHAR(AVG(area), '999,999,999') FROM FCLT_ROOMS r JOIN FCLT_ORGANIZATION o on r.FCLT_ORGANIZATION_KEY = o.FCLT_ORGANIZATION_KEY WHERE o.organization_id = o1.organization_id) AS area_avg FROM FCLT_ORGANIZATION o1 JOIN MASTER_DEPT_HIERARCHY ON o1.DLC_KEY = MASTER_DEPT_HIERARCHY.DLC_KEY WHERE o1.organization_name NOT IN ('CAMBRIDGE-MIT INST')",
    "gold_tables": [
      "dw#sep#FCLT_ROOMS",
      "dw#sep#FCLT_ORGANIZATION",
      "dw#sep#MASTER_DEPT_HIERARCHY"
    ],
    "mapping": {
      "Cambridge-MIT Institute": [
        "FCLT_ORGANIZATION.ORGANIZATION_NAME"
      ],
      "ID": [
        "FCLT_ORGANIZATION.ORGANIZATION_ID"
      ],
      "number": [
        "FCLT_ORGANIZATION.ORGANIZATION_NUMBER"
      ],
      "level": [
        "FCLT_ORGANIZATION.ORGANIZATION_LEVEL"
      ],
      "name": [
        "FCLT_ORGANIZATION.ORGANIZATION_NAME"
      ],
      "assignable": [
        "FCLT_ORGANIZATION.ASSIGNABLE"
      ],
      "area": [
        "FCLT_ROOMS.AREA"
      ],
      "rooms": [
        "FCLT_ROOMS.ROOM"
      ],
      "room area": [
        "FCLT_ROOMS.AREA"
      ]
    },
    "join_keys": [
      [
        "FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY",
        "FCLT_ROOMS.FCLT_ORGANIZATION_KEY"
      ],
      [
        "FCLT_ROOMS.FCLT_ORGANIZATION_KEY",
        "FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY"
      ],
      [
        "FCLT_ROOMS.FCLT_ORGANIZATION_KEY",
        "FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY"
      ],
      [
        "FCLT_ORGANIZATION.DLC_KEY",
        "MASTER_DEPT_HIERARCHY.DLC_KEY"
      ]
    ]
  },
  {
    "question": "Group all rooms into whether or not they are assignable and the major use descriptions. For each group, state \"ASSIGNABLE\" if the room is assignable and \"NON-ASSIGNABLE\" otherwise, the major use description, the total number of rooms, total area, and average area. Include subtotals for each group and a grand total across all groups. The assignable status and major use descriptions should only be displayed when they differ from the previous row. Do not include rooms whose major use or major use description starts with 'ZUSE.' The results should be sorted by assignable status and major use description. The subtotal and grand total rows should not include assignable status or major use description.",
    "db_id": "dw",
    "sql": "SELECT CASE WHEN LAG(assign) OVER (ORDER BY assign) = assign THEN NULL ELSE assign END AS assign, CASE WHEN LAG(muse) OVER (ORDER BY assign, muse_sort) = muse THEN NULL ELSE muse END AS muse, rmcnt, area, area_avg FROM (SELECT CASE WHEN GROUPING(ASSIGNABLE) = 1 THEN NULL ELSE CASE WHEN ASSIGNABLE = 1 THEN 'ASSIGNABLE' ELSE 'NON-ASSIGNABLE' END END AS assign, CASE WHEN GROUPING(FCLT_ROOMS.MAJOR_USE_DESC) = 1 AND GROUPING(ASSIGNABLE) = 0 THEN NULL ELSE FCLT_ROOMS.MAJOR_USE_DESC END AS muse, CASE WHEN GROUPING(FCLT_ROOMS.MAJOR_USE_DESC) = 1 AND GROUPING(ASSIGNABLE) = 0 THEN 'zzz' ELSE FCLT_ROOMS.MAJOR_USE_DESC END AS muse_sort, COUNT(ROOM) AS rmcnt, SUM(FCLT_ROOMS.AREA) AS area, AVG(FCLT_ROOMS.AREA) AS area_avg FROM FCLT_ROOMS JOIN FCLT_MAJOR_USE ON FCLT_MAJOR_USE.FCLT_MAJOR_USE_KEY = FCLT_ROOMS.FCLT_MAJOR_USE_KEY WHERE FCLT_MAJOR_USE.MAJOR_USE NOT LIKE 'ZUSE%' AND FCLT_MAJOR_USE.DESCRIPTION NOT LIKE 'ZUSE%' GROUP BY ASSIGNABLE, FCLT_ROOMS.MAJOR_USE_DESC WITH ROLLUP ORDER BY assign, muse_sort) tbltmp;",
    "oracle_sql": "SELECT CASE WHEN LAG(assign) OVER (ORDER BY assign) = assign THEN NULL ELSE assign END AS assign, CASE WHEN LAG(muse) OVER (ORDER BY assign, muse_sort) = muse THEN NULL ELSE muse END AS muse, rmcnt, area, area_avg FROM (SELECT CASE WHEN GROUPING(ASSIGNABLE) = 1 THEN NULL ELSE CASE WHEN ASSIGNABLE = 1 THEN 'ASSIGNABLE' ELSE 'NON-ASSIGNABLE' END END AS assign, CASE WHEN GROUPING(FCLT_ROOMS.MAJOR_USE_DESC) = 1 AND GROUPING(ASSIGNABLE) = 0 THEN NULL ELSE FCLT_ROOMS.MAJOR_USE_DESC END AS muse, CASE WHEN GROUPING(FCLT_ROOMS.MAJOR_USE_DESC) = 1 AND GROUPING(ASSIGNABLE) = 0 THEN 'zzz' ELSE FCLT_ROOMS.MAJOR_USE_DESC END AS muse_sort, TO_CHAR(COUNT(ROOM), '999,999,999') AS rmcnt, TO_CHAR(SUM(FCLT_ROOMS.AREA), '999,999,999') AS area, TO_CHAR(AVG(FCLT_ROOMS.AREA), '999,999,999') AS area_avg FROM FCLT_ROOMS JOIN FCLT_MAJOR_USE ON FCLT_MAJOR_USE.FCLT_MAJOR_USE_KEY = FCLT_ROOMS.FCLT_MAJOR_USE_KEY WHERE FCLT_MAJOR_USE.MAJOR_USE NOT LIKE 'ZUSE%' AND FCLT_MAJOR_USE.DESCRIPTION NOT LIKE 'ZUSE%' GROUP BY ROLLUP(ASSIGNABLE, FCLT_ROOMS.MAJOR_USE_DESC) ORDER BY assign, muse_sort) tbltmp;",
    "gold_tables": [
      "dw#sep#FCLT_ROOMS",
      "dw#sep#FCLT_MAJOR_USE"
    ],
    "mapping": {
      "rooms": [
        "FCLT_ROOMS.ROOM"
      ],
      "assignable": [
        "FCLT_MAJOR_USE.ASSIGNABLE"
      ],
      "major use description": [
        "FCLT_MAJOR_USE.MAJOR_USE",
        "FCLT_ROOMS.MAJOR_USE_DESC",
        "FCLT_MAJOR_USE.DESCRIPTION"
      ],
      "area": [
        "FCLT_ROOMS.AREA"
      ]
    },
    "join_keys": [
      [
        "FCLT_ROOMS.FCLT_MAJOR_USE_KEY",
        "FCLT_MAJOR_USE.FCLT_MAJOR_USE_KEY"
      ]
    ]
  },
  {
    "question": "List each floor key and department name within the Stata building, as well as the number of rooms, total area, and average area per department on each floor. Include subtotals for each floor and a grand total across all floors. Sort the results by floor key and department name in ascending order. Exclude departments without any rooms in the building. Only the first row of each floor group should include the floor key, and the subtotal and grand total rows should not include floor key or department name. Number of rooms and area should be rounded to integers and formatted using commas as thousands separators.",
    "db_id": "dw",
    "sql": "SELECT CASE WHEN LAG(FLOOR_KEY) OVER (ORDER BY COALESCE(FAC_FLOOR.FLOOR_SORT_SEQUENCE, 999), flsort, orgname) = FLOOR_KEY THEN NULL ELSE FLOOR_KEY END AS flid2, CASE WHEN orgname = 'zzz' THEN NULL ELSE orgname END AS dept, rmcnt, areasum, area_avg FROM (SELECT FLOOR_KEY AS flsort, CASE WHEN GROUPING(FLOOR_KEY) = 0 AND GROUPING(org.ORGANIZATION_NAME) = 1 THEN 'SUBTOTAL' WHEN GROUPING(FLOOR_KEY) = 1 AND GROUPING(org.ORGANIZATION_NAME) = 1 THEN 'TOTAL' ELSE FLOOR_KEY END AS flid, CASE WHEN GROUPING(FLOOR_KEY) = 0 AND GROUPING(org.ORGANIZATION_NAME) = 1 THEN 'zzz' ELSE org.ORGANIZATION_NAME END AS orgname, COUNT(rm.FAC_ROOM_KEY) AS rmcnt, SUM(rm.AREA) AS areasum, AVG(rm.AREA) AS area_avg FROM FAC_ROOMS rm JOIN FCLT_ORGANIZATION org ON rm.ORGANIZATION_KEY = org.FCLT_ORGANIZATION_KEY JOIN BUILDINGS bu ON rm.BUILDING_KEY = bu.BUILDING_KEY WHERE bu.BUILDING_NAME = 'Ray and Maria Stata Center' GROUP BY FLOOR_KEY, org.ORGANIZATION_NAME WITH ROLLUP ORDER BY flsort, orgname) tbltmp LEFT JOIN FAC_FLOOR ON FLOOR_KEY = flsort;",
    "oracle_sql": "SELECT CASE WHEN LAG(FLOOR_KEY) OVER (ORDER BY NVL(FAC_FLOOR.FLOOR_SORT_SEQUENCE, 999), flsort, orgname) = FLOOR_KEY THEN NULL ELSE FLOOR_KEY END AS flid2, CASE WHEN orgname = 'zzz' THEN NULL ELSE orgname END AS dept, rmcnt, areasum, area_avg FROM ( SELECT CASE WHEN GROUPING(FLOOR_KEY) = 1 AND GROUPING(org.ORGANIZATION_NAME) = 1 THEN 'zzz' ELSE FLOOR_KEY END AS flsort, CASE WHEN GROUPING(FLOOR_KEY) = 0 AND GROUPING(org.ORGANIZATION_NAME) = 1 THEN 'SUBTOTAL' WHEN GROUPING(FLOOR_KEY) = 1 AND GROUPING(org.ORGANIZATION_NAME) = 1 THEN 'TOTAL' ELSE FLOOR_KEY END AS flid, CASE WHEN GROUPING(FLOOR_KEY) = 0 AND GROUPING(org.ORGANIZATION_NAME) = 1 THEN 'zzz' ELSE org.ORGANIZATION_NAME END AS orgname, TO_CHAR(COUNT(rm.FAC_ROOM_KEY), '999,999,999') AS rmcnt, TO_CHAR(SUM(rm.AREA), '999,999,999') AS areasum, TO_CHAR(AVG(rm.AREA), '999,999,999') AS area_avg FROM FAC_ROOMS rm JOIN FCLT_ORGANIZATION org ON rm.ORGANIZATION_KEY = org.FCLT_ORGANIZATION_KEY JOIN BUILDINGS bu ON rm.BUILDING_KEY = bu.BUILDING_KEY WHERE bu.BUILDING_NAME = 'Ray and Maria Stata Center' GROUP BY ROLLUP(FLOOR_KEY, org.ORGANIZATION_NAME) ORDER BY flsort, orgname ) tbltmp LEFT JOIN FAC_FLOOR ON FLOOR_KEY = flsort;",
    "gold_tables": [
      "dw#sep#FAC_ROOMS",
      "dw#sep#FCLT_ORGANIZATION",
      "dw#sep#BUILDINGS",
      "dw#sep#FAC_FLOOR"
    ],
    "mapping": {
      "floor key": [
        "FAC_FLOOR.FLOOR_KEY"
      ],
      "department name": [
        "FCLT_ORGANIZATION.ORGANIZATION_NAME"
      ],
      "Stata building": [
        "BUILDINGS.BUILDING_NAME"
      ],
      "rooms": [
        "FAC_ROOMS.FAC_ROOM_KEY"
      ],
      "area": [
        "FAC_ROOMS.AREA"
      ]
    },
    "join_keys": [
      [
        "FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY",
        "FAC_ROOMS.ORGANIZATION_KEY"
      ],
      [
        "BUILDINGS.BUILDING_KEY",
        "FAC_ROOMS.BUILDING_KEY"
      ]
    ]
  },
  {
    "question": "List each building key and floor key within the department of facilities, the number of rooms, total area, average area per floor, building name, access level, zip code, and city. Include subtotals for each building and a grand total across all buildings. The subtotals and grand total should not include zip code or city. Numbers of rooms and area should be rounded to integers and formatted using commas as thousands separators.",
    "db_id": "dw",
    "sql": "SELECT DISTINCT tbltmp.blsort AS building_id, tbltmp.flsort AS floor_id, tbltmp.rmcnt AS total_rooms, tbltmp.areasum AS total_area, tbltmp.area_avg AS avg_area, fb.BUILDING_NAME_LONG AS building_name, fb.ACCESS_LEVEL_NAME AS access_level, CASE WHEN tbltmp.flsort IS NULL THEN NULL ELSE fba.POSTAL_CODE END AS postal_code, CASE WHEN tbltmp.flsort IS NULL THEN NULL ELSE fba.CITY END AS city FROM (SELECT rm.BUILDING_KEY AS blsort, rm.FLOOR_KEY AS flsort, COUNT(rm.FAC_ROOM_KEY) AS rmcnt, SUM(rm.AREA) AS areasum, AVG(rm.AREA) AS area_avg FROM FAC_ROOMS rm JOIN FAC_ORGANIZATION fo ON rm.ORGANIZATION_KEY = fo.ORGANIZATION_KEY WHERE fo.ORGANIZATION_NAME = 'DP OF FACILITIES' GROUP BY rm.BUILDING_KEY, rm.FLOOR_KEY WITH ROLLUP) tbltmp LEFT JOIN FAC_FLOOR fl ON fl.BUILDING_KEY = tbltmp.blsort AND fl.FLOOR_KEY = tbltmp.flsort LEFT JOIN FAC_BUILDING fb ON tbltmp.blsort = fb.FAC_BUILDING_KEY LEFT JOIN FAC_BUILDING_ADDRESS fba ON tbltmp.blsort = fba.BUILDING_KEY ORDER BY building_id, floor_id, postal_code, city;",
    "oracle_sql": "SELECT DISTINCT tbltmp.blsort AS building_id, tbltmp.flsort AS floor_id, tbltmp.rmcnt AS total_rooms, tbltmp.areasum AS total_area, tbltmp.area_avg AS avg_area, fb.BUILDING_NAME_LONG AS building_name, fb.ACCESS_LEVEL_NAME AS access_level, CASE WHEN tbltmp.flsort IS NULL THEN NULL ELSE fba.POSTAL_CODE END AS postal_code, CASE WHEN tbltmp.flsort IS NULL THEN NULL ELSE fba.CITY END AS city FROM ( SELECT CASE WHEN GROUPING(rm.BUILDING_KEY) = 1 THEN NULL ELSE rm.BUILDING_KEY END AS blsort, CASE WHEN GROUPING(rm.FLOOR_KEY) = 1 THEN NULL ELSE rm.FLOOR_KEY END AS flsort, TO_CHAR(COUNT(rm.FAC_ROOM_KEY), '999,999,999') AS rmcnt, TO_CHAR(SUM(rm.AREA), '999,999,999') AS areasum, TO_CHAR(AVG(rm.AREA), '999,999,999') AS area_avg FROM FAC_ROOMS rm JOIN FAC_ORGANIZATION fo ON rm.ORGANIZATION_KEY = fo.ORGANIZATION_KEY WHERE fo.ORGANIZATION_NAME = 'DP OF FACILITIES' GROUP BY ROLLUP(rm.BUILDING_KEY, rm.FLOOR_KEY) ) tbltmp LEFT JOIN FAC_FLOOR fl ON fl.BUILDING_KEY = tbltmp.blsort AND fl.FLOOR_KEY = tbltmp.flsort LEFT JOIN FAC_BUILDING fb ON tbltmp.blsort = fb.FAC_BUILDING_KEY LEFT JOIN FAC_BUILDING_ADDRESS fba ON tbltmp.blsort = fba.BUILDING_KEY ORDER BY building_id, floor_id, postal_code, city;",
    "gold_tables": [
      "dw#sep#FAC_ROOMS",
      "dw#sep#FAC_ORGANIZATION",
      "dw#sep#FAC_FLOOR",
      "dw#sep#FAC_BUILDING",
      "dw#sep#FAC_BUILDING_ADDRESS"
    ],
    "mapping": {
      "building key": [
        "FAC_ROOMS.BUILDING_KEY"
      ],
      "floor key": [
        "FAC_ROOMS.FLOOR_KEY"
      ],
      "department": [
        "FAC_ORGANIZATION.ORGANIZATION_NAME"
      ],
      "rooms": [
        "FAC_ROOMS.FAC_ROOM_KEY"
      ],
      "area": [
        "FAC_ROOMS.AREA"
      ],
      "building name": [
        "FAC_BUILDING.BUILDING_NAME_LONG"
      ],
      "access level": [
        "FAC_BUILDING.ACCESS_LEVEL_NAME"
      ],
      "zip code": [
        "FAC_BUILDING_ADDRESS.POSTAL_CODE"
      ],
      "city": [
        "FAC_BUILDING_ADDRESS.CITY"
      ]
    },
    "join_keys": [
      [
        "FAC_ORGANIZATION.ORGANIZATION_KEY",
        "FAC_ROOMS.ORGANIZATION_KEY"
      ]
    ]
  },
  {
    "question": "List the department, school, course number, subject title, total number of enrolled students, term code, and count of distinct catalog ISBNs. Add a summary row at the bottom showing the total number of students and distinct catalog ISBNs for the current term in the format of ('TOTAL:', null, null, null, total number of students, null, number of distinct catalog ISBNs).",
    "db_id": "dw",
    "sql": "SELECT * FROM (SELECT OFFER_DEPT_NAME AS DEPT, OFFER_SCHOOL_NAME AS SCHOOL, COURSE_NUMBER AS COURSE_NR, SUBJECT_TITLE AS TITLE, SUM(NUM_ENROLLED_STUDENTS) AS TOTAL_ENROLLED, lso.TERM_CODE, COUNT(DISTINCT CATALOG_ISBN) AS OWNERSHIP FROM LIBRARY_SUBJECT_OFFERED lso JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY JOIN LIBRARY_RESERVE_CATALOG lrc ON lrc.LIBRARY_RESERVE_CATALOG_KEY = lrmd.LIBRARY_RESERVE_CATALOG_KEY GROUP BY OFFER_DEPT_NAME, OFFER_SCHOOL_NAME, COURSE_NUMBER, SUBJECT_TITLE, lso.TERM_CODE) AS SubQuery UNION ALL SELECT 'TOTAL:', NULL, NULL, NULL, SUM(NUM_ENROLLED_STUDENTS), NULL, COUNT(DISTINCT CATALOG_ISBN) FROM LIBRARY_SUBJECT_OFFERED lso JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY JOIN LIBRARY_RESERVE_CATALOG lrc ON lrc.LIBRARY_RESERVE_CATALOG_KEY = lrmd.LIBRARY_RESERVE_CATALOG_KEY JOIN ACADEMIC_TERM_PARAMETER acp ON lso.TERM_CODE = acp.TERM_CODE WHERE IS_CURRENT_TERM = 'Y' GROUP BY IS_CURRENT_TERM ORDER BY DEPT, COURSE_NR, TITLE, TERM_CODE;",
    "oracle_sql": "SELECT * FROM (SELECT OFFER_DEPT_NAME AS \"DEPT\", OFFER_SCHOOL_NAME AS \"SCHOOL\", COURSE_NUMBER AS COURSE_NR, SUBJECT_TITLE AS TITLE, SUM(NUM_ENROLLED_STUDENTS) AS TYPE, lso.TERM_CODE, COUNT(DISTINCT CATALOG_ISBN) AS OWNERSHIP FROM LIBRARY_SUBJECT_OFFERED lso JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY JOIN LIBRARY_RESERVE_CATALOG lrc ON lrc.LIBRARY_RESERVE_CATALOG_KEY = lrmd.LIBRARY_RESERVE_CATALOG_KEY GROUP BY OFFER_DEPT_NAME, OFFER_SCHOOL_NAME, COURSE_NUMBER, SUBJECT_TITLE, lso.TERM_CODE ORDER BY OFFER_DEPT_NAME, COURSE_NUMBER, SUBJECT_TITLE, lso.TERM_CODE) UNION ALL SELECT 'TOTAL:', NULL, NULL, NULL, SUM(NUM_ENROLLED_STUDENTS), NULL, COUNT(DISTINCT CATALOG_ISBN) FROM LIBRARY_SUBJECT_OFFERED lso JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY JOIN LIBRARY_RESERVE_CATALOG lrc ON lrc.LIBRARY_RESERVE_CATALOG_KEY = lrmd.LIBRARY_RESERVE_CATALOG_KEY JOIN ACADEMIC_TERM_PARAMETER acp ON lso.TERM_CODE = acp.TERM_CODE WHERE IS_CURRENT_TERM = 'Y'",
    "gold_tables": [
      "dw#sep#LIBRARY_SUBJECT_OFFERED",
      "dw#sep#LIBRARY_RESERVE_MATRL_DETAIL",
      "dw#sep#LIBRARY_RESERVE_CATALOG",
      "dw#sep#ACADEMIC_TERM_PARAMETER"
    ],
    "mapping": {
      "department": [
        "LIBRARY_SUBJECT_OFFERED.OFFER_DEPT_NAME"
      ],
      "school": [
        "LIBRARY_SUBJECT_OFFERED.OFFER_SCHOOL_NAME"
      ],
      "course number": [
        "LIBRARY_SUBJECT_OFFERED.COURSE_NUMBER"
      ],
      "subject title": [
        "LIBRARY_SUBJECT_OFFERED.SUBJECT_TITLE"
      ],
      "enrolled students": [
        "LIBRARY_SUBJECT_OFFERED.NUM_ENROLLED_STUDENTS"
      ],
      "term code": [
        "LIBRARY_SUBJECT_OFFERED.TERM_CODE"
      ],
      "catalog ISBNs": [
        "LIBRARY_RESERVE_CATALOG.CATALOG_ISBN"
      ]
    },
    "join_keys": [
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_SUBJECT_OFFERED_KEY",
        "LIBRARY_SUBJECT_OFFERED.LIBRARY_SUBJECT_OFFERED_KEY"
      ],
      [
        "LIBRARY_RESERVE_CATALOG.LIBRARY_RESERVE_CATALOG_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_RESERVE_CATALOG_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_SUBJECT_OFFERED_KEY",
        "LIBRARY_SUBJECT_OFFERED.LIBRARY_SUBJECT_OFFERED_KEY"
      ],
      [
        "LIBRARY_RESERVE_CATALOG.LIBRARY_RESERVE_CATALOG_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_RESERVE_CATALOG_KEY"
      ],
      [
        "ACADEMIC_TERM_PARAMETER.TERM_CODE",
        "LIBRARY_SUBJECT_OFFERED.TERM_CODE"
      ]
    ]
  },
  {
    "question": "For each mailing list that involves subscribers that work in departments with names starting with 'Computer Science', state the ownership type, the list name, the number of owners, and the number of subscribers. Display the ownership type only if it differs from the previous entry. Include subtotals (the corresponding type field shoud be 'SUBTOTAL') for each ownership type and a grand total (the corresponding type field shoud be 'TOTAL') across all ownership types.",
    "db_id": "dw",
    "sql": "SELECT CASE WHEN LAG(OWNERSHIP_TYPE) OVER (ORDER BY OWNERSHIP_TYPE_gr DESC, ML) = OWNERSHIP_TYPE THEN NULL ELSE OWNERSHIP_TYPE END AS OWNERSHIP_TYPE, ML, nr_owner, nr_member FROM (SELECT CASE WHEN OWNER_TYPE IS NULL AND MOIRA_LIST_NAME IS NOT NULL THEN CONCAT(OWNER_TYPE, '1') ELSE CONCAT(OWNER_TYPE, '2') END AS OWNERSHIP_TYPE_gr, CASE WHEN MOIRA_LIST_NAME IS NULL AND OWNER_TYPE IS NOT NULL THEN 'SUBTOTAL' WHEN MOIRA_LIST_NAME IS NULL AND OWNER_TYPE IS NULL THEN 'TOTAL' ELSE OWNER_TYPE END AS OWNERSHIP_TYPE, MOIRA_LIST_NAME AS ML, COUNT(DISTINCT OWNER) AS nr_owner, COUNT(DISTINCT MOIRA_LIST_MEMBER_MIT_ID) AS nr_member FROM MOIRA_LIST_OWNER mlo JOIN MOIRA_LIST_DETAIL mld ON mld.MOIRA_LIST_OWNER_KEY = mlo.MOIRA_LIST_OWNER_KEY JOIN MOIRA_LIST ml ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY JOIN EMPLOYEE_DIRECTORY ON MIT_ID = MOIRA_LIST_MEMBER_MIT_ID WHERE department_name LIKE 'Computer Science%' GROUP BY OWNER_TYPE, MOIRA_LIST_NAME WITH ROLLUP ORDER BY OWNER_TYPE DESC, MOIRA_LIST_NAME) tbltmp;",
    "oracle_sql": "SELECT CASE WHEN LAG(OWNERSHIP_TYPE) OVER (ORDER BY OWNERSHIP_TYPE_gr DESC, ML) = OWNERSHIP_TYPE THEN NULL ELSE OWNERSHIP_TYPE END AS OWNERSHIP_TYPE, ML, nr_owner, nr_member FROM (SELECT CASE WHEN GROUPING(OWNER_TYPE) = 1 AND GROUPING(MOIRA_LIST_NAME) = 0 THEN OWNER_TYPE || '1' ELSE OWNER_TYPE || '2' END AS OWNERSHIP_TYPE_gr, CASE WHEN GROUPING(MOIRA_LIST_NAME) = 1 AND GROUPING(OWNER_TYPE) = 0 THEN 'SUBTOTAL' WHEN GROUPING(MOIRA_LIST_NAME) = 1 AND GROUPING(OWNER_TYPE) = 1 THEN 'TOTAL' ELSE OWNER_TYPE END AS OWNERSHIP_TYPE, MOIRA_LIST_NAME AS ML, COUNT(DISTINCT OWNER) AS nr_owner, COUNT(DISTINCT MOIRA_LIST_MEMBER_MIT_ID) AS nr_member FROM MOIRA_LIST_OWNER mlo JOIN MOIRA_LIST_DETAIL mld ON mld.MOIRA_LIST_OWNER_KEY = mlo.MOIRA_LIST_OWNER_KEY JOIN MOIRA_LIST ml ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY JOIN EMPLOYEE_DIRECTORY ON MIT_ID = MOIRA_LIST_MEMBER_MIT_ID WHERE department_name LIKE 'Computer Science%' GROUP BY ROLLUP(OWNER_TYPE, MOIRA_LIST_NAME) ORDER BY OWNER_TYPE DESC, MOIRA_LIST_NAME) tbltmp",
    "gold_tables": [
      "dw#sep#MOIRA_LIST_OWNER",
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#MOIRA_LIST",
      "dw#sep#EMPLOYEE_DIRECTORY"
    ],
    "mapping": {
      "departments with names starting with 'Computer Science'": [
        "EMPLOYEE_DIRECTORY.DEPARTMENT_NAME"
      ],
      "ownership type": [
        "MOIRA_LIST_OWNER.OWNER_TYPE"
      ],
      "list name": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "owners": [
        "MOIRA_LIST_OWNER.OWNER"
      ],
      "subscribers": [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER_MIT_ID"
      ]
    },
    "join_keys": [
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_OWNER_KEY",
        "MOIRA_LIST_OWNER.MOIRA_LIST_OWNER_KEY"
      ],
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY",
        "MOIRA_LIST.MOIRA_LIST_KEY"
      ],
      [
        "EMPLOYEE_DIRECTORY.MIT_ID",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER_MIT_ID"
      ]
    ]
  },
  {
    "question": "For each IAP category, list its name, number of unique sessions, total number of attendees, active period (in the format of 'beginning term code-end term code'), the most common sponsor name, and the most common session start time. Include a grand total row showing the total number of sessions and attendees across all categories in the format of ('TOTAL', number of sessions, number of attendees, null, null, null).",
    "db_id": "dw",
    "sql": "WITH SponsorAndStartTime AS (SELECT isc.IAP_CATEGORY_NAME, isp.SPONSOR_NAME, iss.SESSION_START_TIME, COUNT(isp.SPONSOR_NAME) AS sponsor_count, COUNT(iss.SESSION_START_TIME) AS start_time_count FROM IAP_SUBJECT_CATEGORY isc JOIN IAP_SUBJECT_DETAIL isd ON isd.IAP_SUBJECT_CATEGORY_KEY = isc.IAP_SUBJECT_CATEGORY_KEY LEFT JOIN IAP_SUBJECT_SESSION iss ON isd.IAP_SUBJECT_SESSION_KEY = iss.IAP_SUBJECT_SESSION_KEY LEFT JOIN IAP_SUBJECT_SPONSOR isp ON isd.IAP_SUBJECT_SPONSOR_KEY = isp.IAP_SUBJECT_SPONSOR_KEY GROUP BY isc.IAP_CATEGORY_NAME, isp.SPONSOR_NAME, iss.SESSION_START_TIME), MostCommonDetails AS (SELECT IAP_CATEGORY_NAME, (SELECT SPONSOR_NAME FROM SponsorAndStartTime WHERE IAP_CATEGORY_NAME = sast.IAP_CATEGORY_NAME GROUP BY SPONSOR_NAME ORDER BY COUNT(*) DESC LIMIT 1) AS most_common_sponsor, (SELECT SESSION_START_TIME FROM SponsorAndStartTime WHERE IAP_CATEGORY_NAME = sast.IAP_CATEGORY_NAME GROUP BY SESSION_START_TIME ORDER BY COUNT(*) DESC LIMIT 1) AS most_common_start_time FROM SponsorAndStartTime sast GROUP BY IAP_CATEGORY_NAME), CategorySummary AS (SELECT isc.IAP_CATEGORY_NAME AS TYPE, COUNT(DISTINCT isd.IAP_SUBJECT_SESSION_KEY) AS nr_sessions, FORMAT(SUM(isd.MAX_ENROLLMENT), 0) AS total_attend, MIN(isd.TERM_CODE) AS first_active_year, MAX(isd.TERM_CODE) AS last_active_year, mcd.most_common_sponsor, mcd.most_common_start_time FROM IAP_SUBJECT_CATEGORY isc JOIN IAP_SUBJECT_DETAIL isd ON isd.IAP_SUBJECT_CATEGORY_KEY = isc.IAP_SUBJECT_CATEGORY_KEY LEFT JOIN MostCommonDetails mcd ON isc.IAP_CATEGORY_NAME = mcd.IAP_CATEGORY_NAME GROUP BY isc.IAP_CATEGORY_NAME, mcd.most_common_sponsor, mcd.most_common_start_time) SELECT TYPE, nr_sessions, total_attend, CONCAT(first_active_year, '-', last_active_year) AS active_years, most_common_sponsor, most_common_start_time FROM CategorySummary UNION ALL SELECT 'TOTAL', COUNT(DISTINCT IAP_SUBJECT_SESSION_KEY), FORMAT(SUM(MAX_ENROLLMENT), 0), NULL, NULL, NULL FROM IAP_SUBJECT_DETAIL ORDER BY TYPE;",
    "oracle_sql": "WITH SponsorAndStartTime AS ( SELECT isc.IAP_CATEGORY_NAME, isp.SPONSOR_NAME, iss.SESSION_START_TIME, COUNT(isp.SPONSOR_NAME) AS sponsor_count, COUNT(iss.SESSION_START_TIME) AS start_time_count FROM IAP_SUBJECT_CATEGORY isc JOIN IAP_SUBJECT_DETAIL isd ON isd.IAP_SUBJECT_CATEGORY_KEY = isc.IAP_SUBJECT_CATEGORY_KEY LEFT JOIN IAP_SUBJECT_SESSION iss ON isd.IAP_SUBJECT_SESSION_KEY = iss.IAP_SUBJECT_SESSION_KEY LEFT JOIN IAP_SUBJECT_SPONSOR isp ON isd.IAP_SUBJECT_SPONSOR_KEY = isp.IAP_SUBJECT_SPONSOR_KEY GROUP BY isc.IAP_CATEGORY_NAME, isp.SPONSOR_NAME, iss.SESSION_START_TIME ), MostCommonDetails AS ( SELECT IAP_CATEGORY_NAME, MAX(SPONSOR_NAME) KEEP (DENSE_RANK FIRST ORDER BY sponsor_count DESC) AS most_common_sponsor, MAX(SESSION_START_TIME) KEEP (DENSE_RANK FIRST ORDER BY start_time_count DESC) AS most_common_start_time FROM SponsorAndStartTime GROUP BY IAP_CATEGORY_NAME ), CategorySummary AS ( SELECT isc.IAP_CATEGORY_NAME AS TYPE, COUNT(DISTINCT isd.IAP_SUBJECT_SESSION_KEY) AS nr_sessions, TO_CHAR(SUM(isd.MAX_ENROLLMENT), '999,999,999,999') AS total_attend, MIN(isd.TERM_CODE) AS first_active_year, MAX(isd.TERM_CODE) AS last_active_year, mcd.most_common_sponsor, mcd.most_common_start_time FROM IAP_SUBJECT_CATEGORY isc JOIN IAP_SUBJECT_DETAIL isd ON isd.IAP_SUBJECT_CATEGORY_KEY = isc.IAP_SUBJECT_CATEGORY_KEY LEFT JOIN MostCommonDetails mcd ON isc.IAP_CATEGORY_NAME = mcd.IAP_CATEGORY_NAME GROUP BY isc.IAP_CATEGORY_NAME, mcd.most_common_sponsor, mcd.most_common_start_time ) SELECT TYPE, nr_sessions, total_attend, first_active_year || '-' || last_active_year AS active_years, most_common_sponsor, most_common_start_time FROM CategorySummary UNION ALL SELECT 'TOTAL', COUNT(DISTINCT IAP_SUBJECT_SESSION_KEY), TO_CHAR(SUM(MAX_ENROLLMENT), '999,999,999,999'), NULL, NULL, NULL FROM IAP_SUBJECT_DETAIL ORDER BY TYPE;",
    "gold_tables": [
      "dw#sep#IAP_SUBJECT_CATEGORY",
      "dw#sep#IAP_SUBJECT_DETAIL",
      "dw#sep#IAP_SUBJECT_SESSION",
      "dw#sep#IAP_SUBJECT_SPONSOR"
    ],
    "mapping": {
      "name": [
        "IAP_SUBJECT_CATEGORY.IAP_CATEGORY_NAME"
      ],
      "sessions": [
        "IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY"
      ],
      "attendees": [
        "IAP_SUBJECT_DETAIL.MAX_ENROLLMENT"
      ],
      "active period": [
        "IAP_SUBJECT_DETAIL.TERM_CODE"
      ],
      "sponsor name": [
        "IAP_SUBJECT_SPONSOR.SPONSOR_NAME"
      ],
      "session start time": [
        "IAP_SUBJECT_SESSION.SESSION_START_TIME"
      ]
    },
    "join_keys": [
      [
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_CATEGORY_KEY",
        "IAP_SUBJECT_CATEGORY.IAP_SUBJECT_CATEGORY_KEY"
      ],
      [
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_SESSION_KEY",
        "IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY"
      ],
      [
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_SPONSOR_KEY",
        "IAP_SUBJECT_SPONSOR.IAP_SUBJECT_SPONSOR_KEY"
      ],
      [
        "IAP_SUBJECT_CATEGORY.IAP_SUBJECT_CATEGORY_KEY",
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_CATEGORY_KEY"
      ]
    ]
  },
  {
    "question": "For each building type, list the name of the building type, the number of buildings that are not subdivisions, number of employees, number of unique building street address, number of unique city, number of unique state, number of unique postal code, and average gross square footage per employee. For building type of 'resident', display it as 'RESIDENTIAL'. Include a grand total across all building types (the corresponding type field is 'TOTAL').",
    "db_id": "dw",
    "sql": "SELECT * FROM (SELECT CASE WHEN BUILDING_TYPE = 'RESIDENT' THEN 'RESIDENTIAL' ELSE BUILDING_TYPE END AS TYPE, COUNT(DISTINCT COALESCE(PARENT_BUILDING_NUMBER, FCLT_BUILDING_KEY)) AS BUILDINGS, COUNT(DISTINCT MIT_ID) AS MIT_ID_COUNT, COUNT(DISTINCT BUILDINGS.BUILDING_STREET_ADDRESS) AS ADDRESS_COUNT, COUNT(DISTINCT fac_building_address.CITY) AS CITY_COUNT, COUNT(DISTINCT fac_building_address.STATE) AS STATE_COUNT, COUNT(DISTINCT fac_building_address.POSTAL_CODE) AS POSTAL_CODE_COUNT, SUM(FLOOR.EXT_GROSS_AREA)/NULLIF(COUNT(DISTINCT MIT_ID), 0) AS AVG_AREA FROM FCLT_BUILDING_HIST FLOOR JOIN fac_building_address ON FLOOR.fclt_building_key = fac_building_address.BUILDING_KEY JOIN BUILDINGS ON BUILDINGS.BUILDING_KEY = fac_building_address.BUILDING_KEY JOIN FAC_ROOMS fr ON fr.BUILDING_KEY = BUILDINGS.BUILDING_KEY JOIN EMPLOYEE_DIRECTORY e ON e.OFFICE_LOCATION = fr.FAC_ROOM_KEY WHERE fac_building_address.ADDRESS_PURPOSE = 'STREET' GROUP BY BUILDING_TYPE ORDER BY BUILDING_TYPE ASC) AS subquery1 UNION ALL SELECT 'TOTAL', COUNT(DISTINCT COALESCE(PARENT_BUILDING_NUMBER, FCLT_BUILDING_KEY)), COUNT(DISTINCT MIT_ID), COUNT(DISTINCT BUILDINGS.BUILDING_STREET_ADDRESS), COUNT(DISTINCT fac_building_address.CITY), COUNT(DISTINCT fac_building_address.STATE), COUNT(DISTINCT fac_building_address.POSTAL_CODE), SUM(FLOOR.EXT_GROSS_AREA)/NULLIF(COUNT(DISTINCT MIT_ID), 0) FROM FCLT_BUILDING_HIST FLOOR JOIN fac_building_address ON FLOOR.fclt_building_key = fac_building_address.BUILDING_KEY JOIN BUILDINGS ON BUILDINGS.BUILDING_KEY = fac_building_address.BUILDING_KEY JOIN FAC_ROOMS fr ON fr.BUILDING_KEY = BUILDINGS.BUILDING_KEY JOIN EMPLOYEE_DIRECTORY e ON e.OFFICE_LOCATION = fr.FAC_ROOM_KEY WHERE fac_building_address.ADDRESS_PURPOSE = 'STREET';",
    "oracle_sql": "SELECT * FROM (SELECT CASE WHEN BUILDING_TYPE = 'RESIDENT' THEN 'RESIDENTIAL' ELSE BUILDING_TYPE END AS TYPE, COUNT(DISTINCT NVL(PARENT_BUILDING_NUMBER, FCLT_BUILDING_KEY)) AS BUILDINGS,count(distinct MIT_ID),count(distinct BUILDINGS.BUILDING_STREET_ADDRESS), count(distinct fac_building_address.CITY), count(distinct fac_building_address.STATE), count(distinct fac_building_address.POSTAL_CODE),SUM(FLOOR.EXT_GROSS_AREA)/count(distinct MIT_ID) FROM FCLT_BUILDING_HIST FLOOR JOIN fac_building_address ON FLOOR.fclt_building_key = fac_building_address.BUILDING_KEY JOIN BUILDINGS ON BUILDINGS.BUILDING_KEY = fac_building_address.BUILDING_KEY JOIN FAC_ROOMS fr ON fr.BUILDING_KEY = BUILDINGS.BUILDING_KEY JOIN EMPLOYEE_DIRECTORY e ON e.OFFICE_LOCATION = fr.FAC_ROOM_KEY WHERE fac_building_address.ADDRESS_PURPOSE = 'STREET' GROUP BY BUILDING_TYPE ORDER BY BUILDING_TYPE ASC) UNION ALL SELECT 'TOTAL', COUNT(DISTINCT NVL(PARENT_BUILDING_NUMBER, FCLT_BUILDING_KEY)), count(distinct MIT_ID), count(distinct BUILDINGS.BUILDING_STREET_ADDRESS), count(distinct fac_building_address.CITY), count(distinct fac_building_address.STATE), count(distinct fac_building_address.POSTAL_CODE),SUM(FLOOR.EXT_GROSS_AREA)/count(distinct MIT_ID) FROM FCLT_BUILDING_HIST FLOOR JOIN fac_building_address ON FLOOR.fclt_building_key = fac_building_address.BUILDING_KEY JOIN BUILDINGS ON BUILDINGS.BUILDING_KEY = fac_building_address.BUILDING_KEY JOIN FAC_ROOMS fr ON fr.BUILDING_KEY = BUILDINGS.BUILDING_KEY JOIN EMPLOYEE_DIRECTORY e ON e.OFFICE_LOCATION = fr.FAC_ROOM_KEY WHERE fac_building_address.ADDRESS_PURPOSE = 'STREET'",
    "gold_tables": [
      "dw#sep#FCLT_BUILDING_HIST",
      "dw#sep#FAC_BUILDING_ADDRESS",
      "dw#sep#BUILDINGS",
      "dw#sep#FAC_ROOMS",
      "dw#sep#EMPLOYEE_DIRECTORY"
    ],
    "mapping": {
      "name of the building type": [
        "FCLT_BUILDING_HIST.BUILDING_TYPE"
      ],
      "buildings that are not subdivisions": [
        "FCLT_BUILDING_HIST.FCLT_BUILDING_KEY",
        "FCLT_BUILDING_HIST.PARENT_BUILDING_NUMBER"
      ],
      "employees": [
        "EMPLOYEE_DIRECTORY.MIT_ID"
      ],
      "street address": [
        "BUILDINGS.BUILDING_STREET_ADDRESS",
        "FAC_BUILDING_ADDRESS.ADDRESS_PURPOSE"
      ],
      "city": [
        "FAC_BUILDING_ADDRESS.CITY"
      ],
      "state": [
        "FAC_BUILDING_ADDRESS.STATE"
      ],
      "postal code": [
        "FAC_BUILDING_ADDRESS.POSTAL_CODE"
      ],
      "gross square footage": [
        "FCLT_BUILDING_HIST.EXT_GROSS_AREA"
      ]
    },
    "join_keys": [
      [
        "FAC_BUILDING_ADDRESS.BUILDING_KEY",
        "FCLT_BUILDING_HIST.FCLT_BUILDING_KEY"
      ],
      [
        "FAC_BUILDING_ADDRESS.BUILDING_KEY",
        "BUILDINGS.BUILDING_KEY"
      ],
      [
        "BUILDINGS.BUILDING_KEY",
        "FAC_ROOMS.BUILDING_KEY"
      ],
      [
        "EMPLOYEE_DIRECTORY.OFFICE_LOCATION",
        "FAC_ROOMS.FAC_ROOM_KEY"
      ],
      [
        "FCLT_BUILDING_HIST.FCLT_BUILDING_KEY",
        "FAC_BUILDING_ADDRESS.BUILDING_KEY"
      ],
      [
        "FAC_BUILDING_ADDRESS.BUILDING_KEY",
        "BUILDINGS.BUILDING_KEY"
      ],
      [
        "BUILDINGS.BUILDING_KEY",
        "FAC_ROOMS.BUILDING_KEY"
      ],
      [
        "FAC_ROOMS.FAC_ROOM_KEY",
        "EMPLOYEE_DIRECTORY.OFFICE_LOCATION"
      ]
    ]
  },
  {
    "question": "Group spaces in the Stata building by the access level and usage type. For each group, state the access level, usage type, name of the space, the number of spaces, total area across all rooms in the space, and average area across all rooms in the space. Display the access level only if it differs from the previous entry. Include subtotals for each access level, usage type, and space name, subtotals for each access level, and a grand total across all access levels. Exclude usage type that includes \"STORAGE\". All numerical values should be rounded to integers and formatted using commas as thousands separators.",
    "db_id": "dw",
    "sql": "SELECT CASE WHEN LAG(assign) OVER (ORDER BY assign) = assign THEN NULL ELSE assign END AS assign, CASE WHEN LAG(muse) OVER (ORDER BY assign, muse_sort) = muse THEN NULL ELSE muse END AS muse, rmuse, rmcnt, area, area_avg FROM (SELECT CASE WHEN ACCESS_LEVEL IS NULL THEN 'TOTAL' ELSE ACCESS_LEVEL END AS assign, CASE WHEN su2.SPACE_USAGE IS NULL AND ACCESS_LEVEL IS NOT NULL THEN 'SUBTOTAL' ELSE su2.SPACE_USAGE END AS muse, CASE WHEN su2.SPACE_USAGE IS NULL AND ACCESS_LEVEL IS NOT NULL THEN 'zzz' ELSE su2.SPACE_USAGE END AS muse_sort, CASE WHEN DLC_NAME IS NULL AND su2.SPACE_USAGE IS NOT NULL THEN 'SUBTOTAL' ELSE DLC_NAME END AS rmuse, CASE WHEN DLC_NAME IS NULL AND su2.SPACE_USAGE IS NOT NULL THEN 'zzz' ELSE DLC_NAME END AS rmuse_sort, FORMAT(COUNT(DISTINCT SPACE_UNIT), 0) AS rmcnt, FORMAT(SUM(ROOM_SQUARE_FOOTAGE), 0) AS area, FORMAT(AVG(ROOM_SQUARE_FOOTAGE), 0) AS area_avg FROM SPACE_UNIT su JOIN (SELECT * FROM SPACE_DETAIL WHERE BUILDING_KEY = '32') sd ON sd.SPACE_UNIT_KEY = su.SPACE_UNIT_KEY JOIN SPACE_USAGE su2 ON su2.SPACE_USAGE_KEY = sd.SPACE_USAGE_KEY JOIN (SELECT * FROM ZPM_ROOMS_LOAD WHERE BUILDING_COMPONENT = '32') zrl ON zrl.SPACE_UNIT_CODE = su.SPACE_UNIT_CODE JOIN FCLT_ORGANIZATION fo ON fo.FCLT_ORGANIZATION_KEY = su.FCLT_ORGANIZATION_KEY WHERE su2.SPACE_USAGE NOT LIKE '%STORAGE%' GROUP BY ACCESS_LEVEL, su2.SPACE_USAGE, DLC_NAME WITH ROLLUP ORDER BY assign, muse_sort, rmuse_sort) tbltmp;",
    "oracle_sql": "SELECT CASE WHEN LAG(assign) OVER (ORDER BY assign) = assign THEN NULL ELSE assign END AS assign, CASE WHEN LAG(muse) OVER (ORDER BY assign, muse_sort) = muse THEN NULL ELSE muse END AS muse, rmuse, rmcnt, area, area_avg FROM (SELECT CASE WHEN GROUPING(ACCESS_LEVEL) = 1 THEN 'TOTAL' ELSE ACCESS_LEVEL END AS assign, CASE WHEN GROUPING(su2.SPACE_USAGE) = 1 AND GROUPING(ACCESS_LEVEL) = 0 THEN 'SUBTOTAL' ELSE su2.SPACE_USAGE END AS muse, CASE WHEN GROUPING(su2.SPACE_USAGE) = 1 AND GROUPING(ACCESS_LEVEL) = 0 THEN 'zzz' ELSE su2.SPACE_USAGE END AS muse_sort, CASE WHEN GROUPING(DLC_NAME) = 1 AND GROUPING(su2.SPACE_USAGE) = 0 THEN 'SUBTOTAL' ELSE DLC_NAME END AS rmuse, CASE WHEN GROUPING(DLC_NAME) = 1 AND GROUPING(su2.SPACE_USAGE) = 0 THEN 'zzz' ELSE DLC_NAME END AS rmuse_sort, TO_CHAR(COUNT(DISTINCT SPACE_UNIT), '999,999,999') AS rmcnt,TO_CHAR(SUM(ROOM_SQUARE_FOOTAGE), '999,999,999') AS area, TO_CHAR(AVG(ROOM_SQUARE_FOOTAGE), '999,999,999') AS area_avg FROM SPACE_UNIT su JOIN (SELECT * FROM SPACE_DETAIL WHERE BUILDING_KEY = '32') sd ON sd.SPACE_UNIT_KEY=su.SPACE_UNIT_KEY JOIN SPACE_USAGE su2 ON su2.SPACE_USAGE_KEY=sd.SPACE_USAGE_KEY JOIN (SELECT * FROM ZPM_ROOMS_LOAD where BUILDING_COMPONENT='32') zrl ON zrl.SPACE_UNIT_CODE = su.SPACE_UNIT_CODE JOIN FCLT_ORGANIZATION fo ON fo.FCLT_ORGANIZATION_KEY = su.FCLT_ORGANIZATION_KEY WHERE su2.SPACE_USAGE NOT LIKE '%STORAGE%' GROUP BY ROLLUP(ACCESS_LEVEL, su2.SPACE_USAGE, DLC_NAME) ORDER BY assign, muse_sort, rmuse_sort) tbltmp",
    "gold_tables": [
      "dw#sep#SPACE_UNIT",
      "dw#sep#SPACE_DETAIL",
      "dw#sep#SPACE_USAGE",
      "dw#sep#ZPM_ROOMS_LOAD",
      "dw#sep#FCLT_ORGANIZATION"
    ],
    "mapping": {
      "Stata building": [
        "SPACE_DETAIL.BUILDING_KEY"
      ],
      "access level": [
        "ZPM_ROOMS_LOAD.ACCESS_LEVEL"
      ],
      "usage type": [
        "SPACE_USAGE.SPACE_USAGE"
      ],
      "name of the space": [
        "FCLT_ORGANIZATION.DLC_NAME"
      ],
      "spaces": [
        "SPACE_UNIT.SPACE_UNIT"
      ],
      "area": [
        "SPACE_DETAIL.ROOM_SQUARE_FOOTAGE"
      ]
    },
    "join_keys": [
      [
        "FCLT_ORGANIZATION.FCLT_ORGANIZATION_KEY",
        "SPACE_UNIT.FCLT_ORGANIZATION_KEY"
      ]
    ]
  },
  {
    "question": "List each organization's break group, ID, name, and formatted name according to its level, along with whether its members are emeritus or non-emeritus. Also, include the organization number, level, employer count, and hierarchy type for each organization. Exclude organizations '139' and '250'. Sort the results by hierarchy type and ensure totals for employer counts are displayed.",
    "db_id": "dw",
    "sql": "SELECT SUBSTR(organization_sort, 5, 2) AS breakgrp, organization_id, organization_name, CASE WHEN organization_level = 4 THEN ' ' || organization_name WHEN organization_level = 5 THEN ' ' || organization_name WHEN organization_level = 6 THEN ' ' || organization_name ELSE organization_name END AS formatted_name, CASE WHEN EMERITUS_STATUS = 'Emeritus' THEN 'EMERITUS' ELSE 'NON-EMERITUS' END AS assign, organization_number, organization_level, (SELECT COUNT(DISTINCT hfr2.MIT_ID) AS employer_count FROM HR_FACULTY_ROSTER hfr2 WHERE hfr2.HR_ORG_UNIT_TITLE=hou.HR_ORG_UNIT_TITLE) , HIERARCHY_TYPE, organization_sort FROM FCLT_ORGANIZATION JOIN MASTER_DEPT_HIERARCHY ON FCLT_ORGANIZATION.DLC_KEY = MASTER_DEPT_HIERARCHY.DLC_KEY JOIN HR_ORG_UNIT hou on hou.DLC_KEY=FCLT_ORGANIZATION.DLC_KEY JOIN HR_FACULTY_ROSTER hfr ON hfr.HR_ORG_UNIT_TITLE=hou.HR_ORG_UNIT_TITLE WHERE organization_level IN ('3', '4', '5', '6') AND organization_id NOT IN ('139', '250') ORDER BY HIERARCHY_TYPE",
    "oracle_sql": "SELECT SUBSTR(organization_sort, 5, 2) AS breakgrp, organization_id, organization_name, CASE WHEN organization_level = 4 THEN ' ' || organization_name WHEN organization_level = 5 THEN ' ' || organization_name WHEN organization_level = 6 THEN ' ' || organization_name ELSE organization_name END AS formatted_name, CASE WHEN EMERITUS_STATUS = 'Emeritus' THEN 'EMERITUS' ELSE 'NON-EMERITUS' END AS assign, organization_number, organization_level, (SELECT COUNT(DISTINCT hfr2.MIT_ID) AS employer_count FROM HR_FACULTY_ROSTER hfr2 WHERE hfr2.HR_ORG_UNIT_TITLE=hou.HR_ORG_UNIT_TITLE) , HIERARCHY_TYPE, organization_sort FROM FCLT_ORGANIZATION JOIN MASTER_DEPT_HIERARCHY ON FCLT_ORGANIZATION.DLC_KEY = MASTER_DEPT_HIERARCHY.DLC_KEY JOIN HR_ORG_UNIT hou on hou.DLC_KEY=FCLT_ORGANIZATION.DLC_KEY JOIN HR_FACULTY_ROSTER hfr ON hfr.HR_ORG_UNIT_TITLE=hou.HR_ORG_UNIT_TITLE WHERE organization_level IN ('3', '4', '5', '6') AND organization_id NOT IN ('139', '250') ORDER BY HIERARCHY_TYPE",
    "gold_tables": [
      "dw#sep#HR_FACULTY_ROSTER",
      "dw#sep#FCLT_ORGANIZATION",
      "dw#sep#MASTER_DEPT_HIERARCHY",
      "dw#sep#HR_ORG_UNIT"
    ],
    "mapping": {
      "break group": [
        "FCLT_ORGANIZATION.ORGANIZATION_SORT"
      ],
      "ID": [
        "FCLT_ORGANIZATION.ORGANIZATION_ID"
      ],
      "name": [
        "FCLT_ORGANIZATION.ORGANIZATION_NAME"
      ],
      "level": [
        "FCLT_ORGANIZATION.ORGANIZATION_LEVEL"
      ],
      "number": [
        "FCLT_ORGANIZATION.ORGANIZATION_NUMBER"
      ],
      "employer": [
        "HR_FACULTY_ROSTER.MIT_ID"
      ],
      "hierarchy type": [
        "MASTER_DEPT_HIERARCHY.HIERARCHY_TYPE"
      ]
    },
    "join_keys": [
      [
        "FCLT_ORGANIZATION.DLC_KEY",
        "MASTER_DEPT_HIERARCHY.DLC_KEY"
      ],
      [
        "FCLT_ORGANIZATION.DLC_KEY",
        "HR_ORG_UNIT.DLC_KEY"
      ],
      [
        "HR_ORG_UNIT.HR_ORG_UNIT_TITLE",
        "HR_FACULTY_ROSTER.HR_ORG_UNIT_TITLE"
      ]
    ]
  },
  {
    "question": "For each course, list its title, name of the building of the course location, duration (in terms of days), and a running average of the duration (in terms of days) using a window of two preceding and two following courses (partitioned by academic year and sorted by course start date).",
    "db_id": "dw",
    "sql": "select distinct ccso.subject_title, building_name, ccso.duration, avg(duration) over (partition by ccso.academic_year order by ccso.term_start_date rows between 2 preceding and 2 following) from (select distinct subject_title, term_start_date, term_end_date-term_start_date as duration, cis.academic_year, meet_place from academic_terms join COURSE_CATALOG_SUBJECT_OFFERED cis on cis.effective_term_code=academic_terms.term_code) ccso JOIN FCLT_ROOMS fr ON ccso.MEET_PLACE = fr.FCLT_ROOM_KEY JOIN FCLT_BUILDING fb ON fb.FCLT_BUILDING_KEY = fr.FCLT_BUILDING_KEY;",
    "oracle_sql": "select distinct ccso.subject_title, building_name, ccso.duration, avg(duration) over (partition by ccso.academic_year order by ccso.term_start_date rows between 2 preceding and 2 following) from (select distinct subject_title, term_start_date, term_end_date-term_start_date as duration, cis.academic_year, meet_place from academic_terms join COURSE_CATALOG_SUBJECT_OFFERED cis on cis.effective_term_code=academic_terms.term_code) ccso JOIN FCLT_ROOMS fr ON ccso.MEET_PLACE = fr.FCLT_ROOM_KEY JOIN FCLT_BUILDING fb ON fb.FCLT_BUILDING_KEY = fr.FCLT_BUILDING_KEY;",
    "gold_tables": [
      "dw#sep#ACADEMIC_TERMS",
      "dw#sep#COURSE_CATALOG_SUBJECT_OFFERED",
      "dw#sep#FCLT_ROOMS",
      "dw#sep#FCLT_BUILDING"
    ],
    "mapping": {
      "title": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_TITLE"
      ],
      "name of the building": [
        "FCLT_BUILDING.BUILDING_NAME"
      ],
      "duration": [
        "ACADEMIC_TERMS.TERM_END_DATE",
        "ACADEMIC_TERMS.TERM_START_DATE"
      ]
    },
    "join_keys": [
      [
        "COURSE_CATALOG_SUBJECT_OFFERED.EFFECTIVE_TERM_CODE",
        "ACADEMIC_TERMS.TERM_CODE"
      ],
      [
        "FCLT_ROOMS.FCLT_BUILDING_KEY",
        "FCLT_BUILDING.FCLT_BUILDING_KEY"
      ]
    ]
  },
  {
    "question": "For each course, list its name, name of the building of the course location, the start date, the name of the course before it, and the name of the course after it, access level of the building, and the assignable area of the room used for the course, sorted by the ascending order start date and course name.",
    "db_id": "dw",
    "sql": "SELECT ccso.subject_title, fb.BUILDING_NAME_LONG AS building_name, at.TERM_START_DATE AS term_start_date, lag(ccso.subject_title) OVER ( ORDER BY at.TERM_START_DATE ASC, ccso.subject_title ASC ) AS previous_subject_title, lead(ccso.subject_title) OVER ( ORDER BY at.TERM_START_DATE ASC, ccso.subject_title ASC ) AS next_subject_title, fb.ACCESS_LEVEL_NAME AS access_level, fr.AREA AS room_assignable_area FROM ( SELECT DISTINCT subject_id, subject_title, effective_term_code, meet_place FROM COURSE_CATALOG_SUBJECT_OFFERED ) ccso JOIN ACADEMIC_TERMS at ON at.TERM_CODE = ccso.effective_term_code JOIN FCLT_ROOMS fr ON ccso.MEET_PLACE = fr.FCLT_ROOM_KEY JOIN FCLT_BUILDING fb ON fb.FCLT_BUILDING_KEY = fr.FCLT_BUILDING_KEY ORDER BY at.TERM_START_DATE ASC, ccso.subject_title ASC;",
    "oracle_sql": "SELECT ccso.subject_title, fb.BUILDING_NAME_LONG AS building_name, at.TERM_START_DATE AS term_start_date, lag(ccso.subject_title) OVER ( ORDER BY at.TERM_START_DATE ASC, ccso.subject_title ASC ) AS previous_subject_title, lead(ccso.subject_title) OVER ( ORDER BY at.TERM_START_DATE ASC, ccso.subject_title ASC ) AS next_subject_title, fb.ACCESS_LEVEL_NAME AS access_level, fr.AREA AS room_assignable_area FROM ( SELECT DISTINCT subject_id, subject_title, effective_term_code, meet_place FROM COURSE_CATALOG_SUBJECT_OFFERED ) ccso JOIN ACADEMIC_TERMS at ON at.TERM_CODE = ccso.effective_term_code JOIN FCLT_ROOMS fr ON ccso.MEET_PLACE = fr.FCLT_ROOM_KEY JOIN FCLT_BUILDING fb ON fb.FCLT_BUILDING_KEY = fr.FCLT_BUILDING_KEY ORDER BY at.TERM_START_DATE ASC, ccso.subject_title ASC;",
    "gold_tables": [
      "dw#sep#COURSE_CATALOG_SUBJECT_OFFERED",
      "dw#sep#ACADEMIC_TERMS",
      "dw#sep#FCLT_ROOMS",
      "dw#sep#FCLT_BUILDING"
    ],
    "mapping": {
      "name": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_TITLE"
      ],
      "name of the building": [
        "FCLT_BUILDING.BUILDING_NAME_LONG"
      ],
      "start date": [
        "ACADEMIC_TERMS.TERM_START_DATE"
      ],
      "name of the course": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_TITLE"
      ],
      "access level": [
        "FCLT_BUILDING.ACCESS_LEVEL_NAME"
      ],
      "area": [
        "FCLT_ROOMS.AREA"
      ]
    },
    "join_keys": [
      [
        "FCLT_BUILDING.FCLT_BUILDING_KEY",
        "FCLT_ROOMS.FCLT_BUILDING_KEY"
      ]
    ]
  },
  {
    "question": "For each course, list its name, name of the building of the course location, and the cumulative number of courses, including the course itself, held in the same year or preceding years (partitioned by academic year and sorted in the ascending order of course start date).",
    "db_id": "dw",
    "sql": "select distinct subject_title, building_name, count(ccso.subject_id) over (partition by ccso.academic_year order by term_start_date asc range between unbounded preceding and current row) from COURSE_CATALOG_SUBJECT_OFFERED ccso join academic_terms on ccso.effective_term_code =academic_terms.term_code JOIN FCLT_ROOMS fr ON ccso.MEET_PLACE = fr.FCLT_ROOM_KEY JOIN FCLT_BUILDING fb ON fb.FCLT_BUILDING_KEY = fr.FCLT_BUILDING_KEY",
    "oracle_sql": "select distinct subject_title, building_name, count(ccso.subject_id) over (partition by ccso.academic_year order by term_start_date asc range between unbounded preceding and current row) from COURSE_CATALOG_SUBJECT_OFFERED ccso join academic_terms on ccso.effective_term_code =academic_terms.term_code JOIN FCLT_ROOMS fr ON ccso.MEET_PLACE = fr.FCLT_ROOM_KEY JOIN FCLT_BUILDING fb ON fb.FCLT_BUILDING_KEY = fr.FCLT_BUILDING_KEY",
    "gold_tables": [
      "dw#sep#COURSE_CATALOG_SUBJECT_OFFERED",
      "dw#sep#ACADEMIC_TERMS",
      "dw#sep#FCLT_ROOMS",
      "dw#sep#FCLT_BUILDING"
    ],
    "mapping": {
      "name": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_TITLE"
      ],
      "name of the building": [
        "FCLT_BUILDING.BUILDING_NAME"
      ],
      "courses": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID"
      ],
      "academic year": [
        "COURSE_CATALOG_SUBJECT_OFFERED.ACADEMIC_YEAR"
      ],
      "course start date": [
        "ACADEMIC_TERMS.TERM_START_DATE"
      ]
    },
    "join_keys": [
      [
        "COURSE_CATALOG_SUBJECT_OFFERED.EFFECTIVE_TERM_CODE",
        "ACADEMIC_TERMS.TERM_CODE"
      ],
      [
        "COURSE_CATALOG_SUBJECT_OFFERED.MEET_PLACE",
        "FCLT_ROOMS.FCLT_ROOM_KEY"
      ]
    ]
  },
  {
    "question": "Group courses in the biology and chemistry department by whether they are current or not and the cluster type. For each group, list the current status ('CURRENT' if yes and 'NON-CURRENT' otherwise), cluster type, the maximum duration of courses (in terms of days), the maximum units, average duration (in terms of days), and average units. Include subtotals for each current status (the corresponding current status field is 'SUBTOTAL') and a grand total across all current status (the corresponding current status field is 'TOTAL'). Do not repeat the current status if it is the same as the previous row. Sort the table by current status and cluster type.",
    "db_id": "dw",
    "sql": "SELECT CASE WHEN LAG(assign) OVER (ORDER BY IS_CURRENT_TERM DESC, assign, CLUSTER_TYPE ASC) = assign THEN NULL ELSE assign END AS assign, CLUSTER_TYPE, max_duration, max_units, avg_dur, avg_unit FROM ( SELECT CASE WHEN GROUPING(CLUSTER_TYPE) = 1 AND GROUPING(IS_CURRENT_TERM) = 0 THEN 'SUBTOTAL' WHEN GROUPING(CLUSTER_TYPE) = 1 AND GROUPING(IS_CURRENT_TERM) = 1 THEN 'TOTAL' ELSE CASE WHEN IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NON-CURRENT' END END AS assign, IS_CURRENT_TERM, CLUSTER_TYPE, MAX(DATEDIFF(STR_TO_DATE(term_end_date, '%d-%b-%y'), STR_TO_DATE(term_start_date, '%d-%b-%y'))) AS max_duration, MAX(TOTAL_UNITS) AS max_units, AVG(DATEDIFF(STR_TO_DATE(term_end_date, '%d-%b-%y'), STR_TO_DATE(term_start_date, '%d-%b-%y'))) AS avg_dur, AVG(TOTAL_UNITS) AS avg_unit FROM SUBJECT_SUMMARY ss JOIN ACADEMIC_TERMS_ALL ata ON ata.TERM_CODE = ss.TERM_CODE WHERE CLUSTER_TYPE IS NOT NULL AND ss.department_name IN ('Chemistry', 'Biology') GROUP BY IS_CURRENT_TERM, CLUSTER_TYPE WITH ROLLUP ORDER BY IS_CURRENT_TERM DESC, assign, CLUSTER_TYPE ASC ) tbltmp;",
    "oracle_sql": "SELECT CASE WHEN LAG(assign) OVER (ORDER BY IS_CURRENT_TERM DESC, assign, CLUSTER_TYPE ASC) = assign THEN NULL ELSE assign END AS assign, CLUSTER_TYPE, max_duration, max_units, avg_dur, avg_unit FROM (SELECT CASE WHEN GROUPING(CLUSTER_TYPE) = 1 AND GROUPING(IS_CURRENT_TERM) = 0 THEN 'SUBTOTAL' WHEN GROUPING(CLUSTER_TYPE) = 1 AND GROUPING(IS_CURRENT_TERM) = 1 THEN 'TOTAL' ELSE CASE WHEN IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NON-CURRENT' END END AS assign, IS_CURRENT_TERM, CLUSTER_TYPE, max(term_end_date-term_start_date) AS max_duration, MAX(TOTAL_UNITS) AS max_units, AVG(term_end_date-term_start_date) AS avg_dur, AVG(TOTAL_UNITS) AS avg_unit FROM SUBJECT_SUMMARY ss JOIN ACADEMIC_TERMS_ALL ata ON ata.TERM_CODE = ss.TERM_CODE WHERE CLUSTER_TYPE IS NOT NULL and ss.department_name in ('Chemistry', 'Biology') GROUP BY ROLLUP(IS_CURRENT_TERM, CLUSTER_TYPE) ORDER BY IS_CURRENT_TERM DESC, assign, CLUSTER_TYPE ASC) tbltmp",
    "gold_tables": [
      "dw#sep#SUBJECT_SUMMARY",
      "dw#sep#ACADEMIC_TERMS_ALL"
    ],
    "mapping": {
      "biology and chemistry department": [
        "SUBJECT_SUMMARY.DEPARTMENT_NAME"
      ],
      "current status": [
        "ACADEMIC_TERMS_ALL.IS_CURRENT_TERM"
      ],
      "cluster type": [
        "SUBJECT_SUMMARY.CLUSTER_TYPE"
      ],
      "duration": [
        "ACADEMIC_TERMS_ALL.TERM_END_DATE",
        "ACADEMIC_TERMS_ALL.TERM_START_DATE"
      ],
      "units": [
        "SUBJECT_SUMMARY.TOTAL_UNITS"
      ]
    },
    "join_keys": [
      [
        "ACADEMIC_TERMS_ALL.TERM_CODE",
        "SUBJECT_SUMMARY.TERM_CODE"
      ]
    ]
  },
  {
    "question": "Group courses in the biology and chemistry department by whether they are current or not and the department name. For each group, list the current status ('CURRENT' if yes and 'NON-CURRENT' otherwise), department name, the maximum duration of courses (in terms of days), the maximum units, average duration (in terms of days), and average units. Include subtotals for each current status (the corresponding current status field is 'SUBTOTAL') and a grand total across all current status (the corresponding current status field is 'TOTAL'). Do not repeat the current status if it is the same as the previous row. Sort the table by current status and department.",
    "db_id": "dw",
    "sql": "SELECT CASE WHEN LAG(assign) OVER (ORDER BY IS_CURRENT_TERM DESC, assign, OFFER_DEPT_NAME ASC) = assign THEN NULL ELSE assign END AS assign, OFFER_DEPT_NAME, max_duration, max_units, avg_dur, avg_unit FROM (SELECT CASE WHEN GROUPING(OFFER_DEPT_NAME) = 1 AND GROUPING(IS_CURRENT_TERM) = 0 THEN 'SUBTOTAL' WHEN GROUPING(OFFER_DEPT_NAME) = 1 AND GROUPING(IS_CURRENT_TERM) = 1 THEN 'TOTAL' ELSE CASE WHEN IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NON-CURRENT' END END AS assign, IS_CURRENT_TERM, OFFER_DEPT_NAME, MAX(DATEDIFF(STR_TO_DATE(term_end_date, '%d-%b-%y'), STR_TO_DATE(term_start_date, '%d-%b-%y'))) AS max_duration, MAX(TOTAL_UNITS) AS max_units, AVG(DATEDIFF(STR_TO_DATE(term_end_date, '%d-%b-%y'), STR_TO_DATE(term_start_date, '%d-%b-%y'))) AS avg_dur, AVG(TOTAL_UNITS) AS avg_unit FROM SUBJECT_SUMMARY ss JOIN ACADEMIC_TERMS_ALL ata ON ata.TERM_CODE = ss.TERM_CODE JOIN SUBJECT_OFFERED so ON so.SUBJECT_ID = ss.SUBJECT_ID WHERE so.offer_dept_name IN ('Chemistry', 'Biology') GROUP BY IS_CURRENT_TERM, OFFER_DEPT_NAME WITH ROLLUP ORDER BY IS_CURRENT_TERM DESC, assign, OFFER_DEPT_NAME ASC) tbltmp;",
    "oracle_sql": "SELECT CASE WHEN LAG(assign) OVER (ORDER BY IS_CURRENT_TERM DESC, assign, OFFER_DEPT_NAME ASC) = assign THEN NULL ELSE assign END AS assign, OFFER_DEPT_NAME, max_duration, max_units, avg_dur, avg_unit FROM (SELECT CASE WHEN GROUPING(OFFER_DEPT_NAME) = 1 AND GROUPING(IS_CURRENT_TERM) = 0 THEN 'SUBTOTAL' WHEN GROUPING(OFFER_DEPT_NAME) = 1 AND GROUPING(IS_CURRENT_TERM) = 1 THEN 'TOTAL' ELSE CASE WHEN IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NON-CURRENT' END END AS assign, IS_CURRENT_TERM, OFFER_DEPT_NAME, max(term_end_date-term_start_date) AS max_duration, MAX(TOTAL_UNITS) AS max_units, AVG(term_end_date-term_start_date) AS avg_dur, AVG(TOTAL_UNITS) AS avg_unit FROM SUBJECT_SUMMARY ss JOIN ACADEMIC_TERMS_ALL ata ON ata.TERM_CODE = ss.TERM_CODE JOIN SUBJECT_OFFERED so ON so.SUBJECT_ID = ss.SUBJECT_ID where so.offer_dept_name in ('Chemistry', 'Biology') GROUP BY ROLLUP(IS_CURRENT_TERM, OFFER_DEPT_NAME) ORDER BY IS_CURRENT_TERM DESC, assign, OFFER_DEPT_NAME ASC) tbltmp",
    "gold_tables": [
      "dw#sep#SUBJECT_SUMMARY",
      "dw#sep#ACADEMIC_TERMS_ALL",
      "dw#sep#SUBJECT_OFFERED"
    ],
    "mapping": {
      "biology and chemistry department": [
        "SUBJECT_OFFERED.OFFER_DEPT_NAME"
      ],
      "current status": [
        "ACADEMIC_TERMS_ALL.IS_CURRENT_TERM"
      ],
      "duration": [
        "ACADEMIC_TERMS_ALL.TERM_END_DATE",
        "ACADEMIC_TERMS_ALL.TERM_START_DATE"
      ],
      "units": [
        "SUBJECT_SUMMARY.TOTAL_UNITS"
      ]
    },
    "join_keys": [
      [
        "ACADEMIC_TERMS_ALL.TERM_CODE",
        "SUBJECT_SUMMARY.TERM_CODE"
      ],
      [
        "SUBJECT_SUMMARY.SUBJECT_ID",
        "SUBJECT_OFFERED.SUBJECT_ID"
      ]
    ]
  },
  {
    "question": "Group master courses by department. For each group, state the name of the department, the master course code, the number of subjects, the total new shelf price of associated TIP materials, and the number of unique TIP materials. Display the department and master course only if it differs from the previous entry. Include subtotals for each department and a grand total across all departments. All numerical values should be rounded to integers and formatted using commas as thousands separators.",
    "db_id": "dw",
    "sql": "SELECT CASE WHEN LAG(dept) OVER (ORDER BY dept, dept_sort, master) = dept THEN NULL ELSE dept END AS dept, CASE WHEN master = 'zzz' THEN NULL ELSE master END AS master, subcnt, totalprice, matcnt FROM (SELECT CASE WHEN GROUPING(OFFER_DEPT_NAME) = 1 AND GROUPING(MASTER_COURSE_NUMBER) = 1 THEN 'zzz' ELSE OFFER_DEPT_NAME END AS dept_sort, CASE WHEN GROUPING(OFFER_DEPT_NAME) = 0 AND GROUPING(MASTER_COURSE_NUMBER) = 1 THEN 'SUBTOTAL' WHEN GROUPING(OFFER_DEPT_NAME) = 1 AND GROUPING(MASTER_COURSE_NUMBER) = 1 THEN 'TOTAL' ELSE OFFER_DEPT_NAME END AS dept, CASE WHEN GROUPING(OFFER_DEPT_NAME) = 0 AND GROUPING(MASTER_COURSE_NUMBER) = 1 THEN 'zzz' ELSE MASTER_COURSE_NUMBER END AS master, FORMAT(COUNT(DISTINCT tso.SUBJECT_ID), 0) AS subcnt, FORMAT(SUM(NEW_SHELF_PRICE), 0) AS totalprice, FORMAT(COUNT(DISTINCT tm.ISBN), 0) AS matcnt FROM TIP_DETAIL td JOIN TIP_SUBJECT_OFFERED tso ON tso.TIP_SUBJECT_OFFERED_KEY = td.TIP_SUBJECT_OFFERED_KEY JOIN TIP_MATERIAL tm ON tm.TIP_MATERIAL_KEY = td.TIP_MATERIAL_KEY GROUP BY OFFER_DEPT_NAME, MASTER_COURSE_NUMBER WITH ROLLUP ORDER BY dept_sort, master) tbltmp;",
    "oracle_sql": "SELECT CASE WHEN LAG(dept) OVER (ORDER BY dept, dept_sort, master) = dept THEN NULL ELSE dept END AS dept, CASE WHEN master = 'zzz' THEN NULL ELSE master END AS master, subcnt, totalprice, matcnt FROM ( SELECT CASE WHEN GROUPING(OFFER_DEPT_NAME) = 1 AND GROUPING(MASTER_COURSE_NUMBER) = 1 THEN 'zzz' ELSE OFFER_DEPT_NAME END AS dept_sort, CASE WHEN GROUPING(OFFER_DEPT_NAME) = 0 AND GROUPING(MASTER_COURSE_NUMBER) = 1 THEN 'SUBTOTAL' WHEN GROUPING(OFFER_DEPT_NAME) = 1 AND GROUPING(MASTER_COURSE_NUMBER) = 1 THEN 'TOTAL' ELSE OFFER_DEPT_NAME END AS dept, CASE WHEN GROUPING(OFFER_DEPT_NAME) = 0 AND GROUPING(MASTER_COURSE_NUMBER) = 1 THEN 'zzz' ELSE MASTER_COURSE_NUMBER END AS master, TO_CHAR(COUNT(distinct tso.SUBJECT_ID), '999,999,999') AS subcnt, TO_CHAR(SUM(NEW_SHELF_PRICE), '999,999,999') AS totalprice, TO_CHAR(COUNT(DISTINCT tm.ISBN), '999,999,999') AS matcnt FROM TIP_DETAIL td JOIN TIP_SUBJECT_OFFERED tso ON tso.TIP_SUBJECT_OFFERED_KEY = td. TIP_SUBJECT_OFFERED_KEY JOIN TIP_MATERIAL tm ON tm.TIP_MATERIAL_KEY = td.TIP_MATERIAL_KEY GROUP BY ROLLUP(OFFER_DEPT_NAME, MASTER_COURSE_NUMBER) ORDER BY dept_sort, master ) tbltmp",
    "gold_tables": [
      "dw#sep#TIP_DETAIL",
      "dw#sep#TIP_SUBJECT_OFFERED",
      "dw#sep#TIP_MATERIAL"
    ],
    "mapping": {
      "name of the department": [
        "TIP_SUBJECT_OFFERED.OFFER_DEPT_NAME"
      ],
      "master course code": [
        "TIP_SUBJECT_OFFERED.MASTER_COURSE_NUMBER"
      ],
      "subjects": [
        "TIP_SUBJECT_OFFERED.SUBJECT_ID"
      ],
      "new shelf price": [
        "TIP_MATERIAL.NEW_SHELF_PRICE"
      ],
      "TIP materials": [
        "TIP_MATERIAL.ISBN"
      ]
    },
    "join_keys": [
      [
        "TIP_DETAIL.TIP_MATERIAL_KEY",
        "TIP_MATERIAL.TIP_MATERIAL_KEY"
      ]
    ]
  },
  {
    "question": "For each term and department, list the term, department, the number of courses, average number of equivalent subjects, the school name, and department phone number. Include subtotals for each term (the corresponding term field is 'SUBTOTAL') and a grand total across all terms (the corresponding term field is 'TOTAL'). Do not repeat the term if it is the same as the previous row. Sort the table by term and department.",
    "db_id": "dw",
    "sql": "SELECT CASE WHEN LAG(term) OVER (ORDER BY term_sort, term, dept_sort) = term THEN NULL ELSE term END AS term, dept, subcnt, avgeqisub, sd.SCHOOL_NAME AS school_name, ad.DEPARTMENT_PHONE_NUMBER AS department_phone FROM (SELECT CASE WHEN GROUPING(TERM_CODE) = 1 AND GROUPING(DEPARTMENT_NAME) = 1 THEN 'zzz' ELSE TERM_CODE END AS term_sort, CASE WHEN GROUPING(TERM_CODE) = 0 AND GROUPING(DEPARTMENT_NAME) = 1 THEN 'SUBTOTAL' WHEN GROUPING(TERM_CODE) = 1 AND GROUPING(DEPARTMENT_NAME) = 1 THEN 'TOTAL' ELSE TERM_CODE END AS term, CASE WHEN GROUPING(TERM_CODE) = 0 AND GROUPING(DEPARTMENT_NAME) = 1 THEN 'zzz' ELSE DEPARTMENT_NAME END AS dept_sort, DEPARTMENT_NAME AS dept, COUNT(DISTINCT SUBJECT_ID) AS subcnt, MIN(MEET_TIME) AS mintime, AVG(CASE WHEN equivalent_subjects IS NULL THEN 0 ELSE 1 + LENGTH(equivalent_subjects) - LENGTH(REPLACE(equivalent_subjects, ',', '')) END) AS avgeqisub FROM COURSE_CATALOG_SUBJECT_OFFERED GROUP BY TERM_CODE, DEPARTMENT_NAME WITH ROLLUP) tbltmp LEFT JOIN SIS_DEPARTMENT sd ON tbltmp.dept = sd.DEPARTMENT_NAME LEFT JOIN SIS_ADMIN_DEPARTMENT ad ON sd.DEPARTMENT_CODE = ad.SIS_ADMIN_DEPARTMENT_CODE ORDER BY term_sort, dept_sort;",
    "oracle_sql": "SELECT CASE WHEN LAG(term) OVER (ORDER BY term_sort, term, dept_sort) = term THEN NULL ELSE term END AS term, dept, subcnt, avgeqisub, sd.SCHOOL_NAME AS school_name, ad.DEPARTMENT_PHONE_NUMBER AS department_phone FROM ( SELECT CASE WHEN GROUPING(TERM_CODE) = 1 AND GROUPING(DEPARTMENT_NAME) = 1 THEN 'zzz' ELSE TERM_CODE END AS term_sort, CASE WHEN GROUPING(TERM_CODE) = 0 AND GROUPING(DEPARTMENT_NAME) = 1 THEN 'SUBTOTAL' WHEN GROUPING(TERM_CODE) = 1 AND GROUPING(DEPARTMENT_NAME) = 1 THEN 'TOTAL' ELSE TERM_CODE END AS term, CASE WHEN GROUPING(TERM_CODE) = 0 AND GROUPING(DEPARTMENT_NAME) = 1 THEN 'zzz' ELSE DEPARTMENT_NAME END AS dept_sort, DEPARTMENT_NAME AS dept, COUNT(DISTINCT SUBJECT_ID) AS subcnt, MIN(MEET_TIME) AS mintime, AVG(CASE WHEN equivalent_subjects IS NULL THEN 0 ELSE 1 + LENGTH(equivalent_subjects) - LENGTH(REPLACE(equivalent_subjects, ',', '')) END) AS avgeqisub FROM COURSE_CATALOG_SUBJECT_OFFERED GROUP BY ROLLUP(TERM_CODE, DEPARTMENT_NAME) ) tbltmp LEFT JOIN SIS_DEPARTMENT sd ON tbltmp.dept = sd.DEPARTMENT_NAME LEFT JOIN SIS_ADMIN_DEPARTMENT ad ON sd.DEPARTMENT_CODE = ad.SIS_ADMIN_DEPARTMENT_CODE ORDER BY term_sort, dept_sort;",
    "gold_tables": [
      "dw#sep#COURSE_CATALOG_SUBJECT_OFFERED",
      "dw#sep#SIS_DEPARTMENT",
      "dw#sep#SIS_ADMIN_DEPARTMENT"
    ],
    "mapping": {
      "term": [
        "COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE"
      ],
      "department": [
        "COURSE_CATALOG_SUBJECT_OFFERED.DEPARTMENT_NAME"
      ],
      "courses": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID"
      ],
      "equivalent subjects": [
        "COURSE_CATALOG_SUBJECT_OFFERED.EQUIVALENT_SUBJECTS"
      ],
      "school name": [
        "SIS_DEPARTMENT.SCHOOL_NAME"
      ],
      "department phone number": [
        "SIS_ADMIN_DEPARTMENT.DEPARTMENT_PHONE_NUMBER"
      ]
    },
    "join_keys": [
      [
        "SIS_ADMIN_DEPARTMENT.SIS_ADMIN_DEPARTMENT_CODE",
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ]
    ]
  },
  {
    "question": "Group sessions by their current term status. For each group, state the status ('CURRENT' if is current term and 'NOT CURRENT' otherwise), name of the session, number of IAP sessions, total IAP session time in days, and average IAP session time in days. Show a subtotal for each current status and a grand total row across all status. Order the results by current status and cluster type. Display the the current status only if it differs from the previous entry.",
    "db_id": "dw",
    "sql": "SELECT CASE WHEN LAG(assign) OVER (ORDER BY assign) = assign THEN NULL ELSE assign END AS assign, muse, session_count, total_time, avg_time FROM (SELECT CASE WHEN IS_CURRENT_TERM IS NULL AND IAP_CATEGORY_NAME IS NOT NULL THEN 'SUBTOTAL' WHEN IS_CURRENT_TERM IS NULL AND IAP_CATEGORY_NAME IS NULL THEN 'TOTAL' ELSE CASE WHEN IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NOT CURRENT' END END AS assign, IAP_CATEGORY_NAME AS muse, COUNT(SESSION_DATE) AS session_count, SUM(COALESCE(TIMESTAMPDIFF(HOUR, STR_TO_DATE(CONCAT(LEFT(SESSION_START_TIME, 2), ':', SUBSTRING(SESSION_START_TIME, 3, 2), ' ', RIGHT(SESSION_START_TIME, 2)), '%h:%i %p'), STR_TO_DATE(CONCAT(LEFT(SESSION_END_TIME, 2), ':', SUBSTRING(SESSION_END_TIME, 3, 2), ' ', RIGHT(SESSION_END_TIME, 2)), '%h:%i %p')) / 24.0, 0)) AS total_time, AVG(COALESCE(TIMESTAMPDIFF(HOUR, STR_TO_DATE(CONCAT(LEFT(SESSION_START_TIME, 2), ':', SUBSTRING(SESSION_START_TIME, 3, 2), ' ', RIGHT(SESSION_START_TIME, 2)), '%h:%i %p'), STR_TO_DATE(CONCAT(LEFT(SESSION_END_TIME, 2), ':', SUBSTRING(SESSION_END_TIME, 3, 2), ' ', RIGHT(SESSION_END_TIME, 2)), '%h:%i %p')) / 24.0, 0)) AS avg_time FROM IAP_SUBJECT_DETAIL ss JOIN ACADEMIC_TERMS at ON at.TERM_CODE = ss.TERM_CODE JOIN IAP_SUBJECT_SESSION iss ON iss.IAP_SUBJECT_SESSION_KEY = ss.IAP_SUBJECT_SESSION_KEY JOIN IAP_SUBJECT_CATEGORY isc ON isc.IAP_SUBJECT_CATEGORY_KEY = ss.IAP_SUBJECT_CATEGORY_KEY GROUP BY IS_CURRENT_TERM, IAP_CATEGORY_NAME WITH ROLLUP HAVING IS_CURRENT_TERM IS NOT NULL OR IAP_CATEGORY_NAME IS NOT NULL) AS tbltmp ORDER BY assign, muse;",
    "oracle_sql": "SELECT CASE WHEN LAG(assign) OVER (ORDER BY assign) = assign THEN NULL ELSE assign END AS assign, muse, session_count, total_time, avg_time FROM (SELECT CASE WHEN GROUPING(IAP_CATEGORY_NAME) = 1 AND GROUPING(IS_CURRENT_TERM) = 0 THEN 'SUBTOTAL' WHEN GROUPING(IAP_CATEGORY_NAME) = 1 AND GROUPING(IAP_CATEGORY_NAME) = 1 THEN 'TOTAL' ELSE CASE WHEN IS_CURRENT_TERM = 'Y' THEN 'CURRENT' ELSE 'NOT CURRENT' END END AS assign, IAP_CATEGORY_NAME AS muse, COUNT(SESSION_DATE) AS session_count, SUM(COALESCE(TO_DATE(SESSION_END_TIME, 'HHMIPM') - TO_DATE(SESSION_START_TIME, 'HHMIPM'), 0)) AS total_time, AVG(COALESCE(TO_DATE(SESSION_END_TIME, 'HHMIPM') - TO_DATE(SESSION_START_TIME, 'HHMIPM'), 0)) AS avg_time FROM IAP_SUBJECT_DETAIL ss JOIN ACADEMIC_TERMS at ON at.TERM_CODE = ss.TERM_CODE JOIN IAP_SUBJECT_SESSION iss ON iss.IAP_SUBJECT_SESSION_KEY =ss.IAP_SUBJECT_SESSION_KEY JOIN IAP_SUBJECT_CATEGORY isc ON isc.IAP_SUBJECT_CATEGORY_KEY=ss.IAP_SUBJECT_CATEGORY_KEY GROUP BY ROLLUP(IS_CURRENT_TERM, IAP_CATEGORY_NAME) ORDER BY assign, muse) tbltmp",
    "gold_tables": [
      "dw#sep#IAP_SUBJECT_DETAIL",
      "dw#sep#ACADEMIC_TERMS",
      "dw#sep#IAP_SUBJECT_SESSION",
      "dw#sep#IAP_SUBJECT_CATEGORY"
    ],
    "mapping": {
      "current term status": [
        "ACADEMIC_TERMS.IS_CURRENT_TERM"
      ],
      "name of the session": [
        "IAP_SUBJECT_CATEGORY.IAP_CATEGORY_NAME"
      ],
      "IAP sessions": [
        "IAP_SUBJECT_SESSION.SESSION_DATE"
      ],
      "session time": [
        "IAP_SUBJECT_SESSION.SESSION_START_TIME",
        "IAP_SUBJECT_SESSION.SESSION_END_TIME"
      ]
    },
    "join_keys": [
      [
        "IAP_SUBJECT_DETAIL.TERM_CODE",
        "ACADEMIC_TERMS.TERM_CODE"
      ],
      [
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_SESSION_KEY",
        "IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY"
      ],
      [
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_CATEGORY_KEY",
        "IAP_SUBJECT_CATEGORY.IAP_SUBJECT_CATEGORY_KEY"
      ]
    ]
  },
  {
    "question": "List each academic year, the term code, and the number of newly introduced subjects in this term. Display the academic year only if it differs from the previous entry. Include a grand total (the corresponding year field should be 'TOTAL') stating the total number of subjects across all academic years.",
    "db_id": "dw",
    "sql": "SELECT CASE WHEN LAG(ACADEMIC_YEAR) OVER (ORDER BY ata.TERM_CODE) = ACADEMIC_YEAR THEN NULL ELSE ACADEMIC_YEAR END AS ACADEMIC_YEAR, ata.TERM_CODE, COUNT(DISTINCT si) AS distinct_subject_count FROM ACADEMIC_TERMS_ALL ata LEFT OUTER JOIN (SELECT CASE WHEN LAG(subject_id) OVER (ORDER BY SUBJECT_ID, TERM_CODE ASC, ACADEMIC_YEAR ASC) = subject_id THEN NULL ELSE subject_id END AS si, CASE WHEN LAG(TERM_CODE) OVER (ORDER BY SUBJECT_ID, TERM_CODE ASC, ACADEMIC_YEAR ASC) = TERM_CODE THEN NULL ELSE term_code END AS term_code FROM course_catalog_subject_offered) AS a ON ata.TERM_CODE = a.TERM_CODE GROUP BY ata.TERM_CODE, ACADEMIC_YEAR UNION ALL SELECT 'TOTAL', NULL, COUNT(DISTINCT SUBJECT_ID) AS total_distinct_subject_count FROM course_catalog_subject_offered;",
    "oracle_sql": "select CASE WHEN Lag(ACADEMIC_YEAR)over (order by ata.TERM_CODE) =ACADEMIC_YEAR THEN NULL ELSE ACADEMIC_YEAR end AS ACADEMIC_YEAR,ata.TERM_CODE, COUNT(distinct si) from ACADEMIC_TERMS_ALL ata LEFT OUTER JOIN (select * from (select CASE WHEN LAG(subject_id) over(ORDER BY SUBJECT_ID, TERM_CODE ASC, ACADEMIC_YEAR ASC) = subject_id then NULL else subject_id end as si, case when LAG(TERM_CODE) over (ORDER BY SUBJECT_ID, TERM_CODE ASC, ACADEMIC_YEAR ASC) =TERM_CODE then null else term_code end as term_code from course_catalog_subject_offered) where si is not null) a ON ata.TERM_CODE=a.TERM_CODE GROUP BY ata.TERM_CODE, ACADEMIC_YEAR UNION ALL SELECT 'TOTAL', NULL, COUNT(DISTINCT SUBJECT_ID) FROM COURSE_CATALOG_SUBJECT_OFFERED",
    "gold_tables": [
      "dw#sep#ACADEMIC_TERMS_ALL",
      "dw#sep#COURSE_CATALOG_SUBJECT_OFFERED"
    ],
    "mapping": {
      "academic year": [
        "ACADEMIC_TERMS_ALL.ACADEMIC_YEAR"
      ],
      "term code": [
        "ACADEMIC_TERMS_ALL.TERM_CODE"
      ],
      "subjects": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_ID"
      ]
    },
    "join_keys": []
  },
  {
    "question": "For email lists with names starting with e (case insensitive), containing 10 to 20 members inclusive, and where over 75% are computer science students, provide the list name, owner, and member count.",
    "db_id": "dw",
    "sql": "WITH FilteredLists AS ( SELECT ml.MOIRA_LIST_NAME, mlo.OWNER, COUNT(mld.MOIRA_LIST_MEMBER) AS TOTAL_MEMBER_COUNT FROM MOIRA_LIST ml JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY JOIN MOIRA_LIST_OWNER mlo ON mld.MOIRA_LIST_OWNER_KEY = mlo.MOIRA_LIST_OWNER_KEY WHERE UPPER(ml.MOIRA_LIST_NAME) LIKE 'E%' GROUP BY ml.MOIRA_LIST_NAME, mlo.OWNER HAVING COUNT(mld.MOIRA_LIST_MEMBER) BETWEEN 10 AND 20 ), CSStudentCounts AS ( SELECT ml.MOIRA_LIST_NAME, COUNT(CASE WHEN msd.DEPARTMENT = '6' THEN 1 ELSE NULL END) AS CS_STUDENT_COUNT FROM FilteredLists fl JOIN MOIRA_LIST ml ON fl.MOIRA_LIST_NAME = ml.MOIRA_LIST_NAME JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY JOIN SE_PERSON se ON UPPER(mld.MOIRA_LIST_MEMBER) = UPPER(se.KRB_NAME) JOIN MIT_STUDENT_DIRECTORY msd ON se.FULL_NAME = msd.FULL_NAME GROUP BY ml.MOIRA_LIST_NAME ) SELECT fl.MOIRA_LIST_NAME, fl.OWNER, fl.TOTAL_MEMBER_COUNT FROM FilteredLists fl JOIN CSStudentCounts cs ON fl.MOIRA_LIST_NAME = cs.MOIRA_LIST_NAME WHERE cs.CS_STUDENT_COUNT > 0.75 * fl.TOTAL_MEMBER_COUNT;",
    "oracle_sql": "WITH FilteredLists AS (SELECT ml.MOIRA_LIST_NAME, mlo.OWNER, COUNT(mld.MOIRA_LIST_MEMBER) AS TOTAL_MEMBER_COUNT FROM MOIRA_LIST ml JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY JOIN MOIRA_LIST_OWNER mlo ON mld.MOIRA_LIST_OWNER_KEY = mlo.MOIRA_LIST_OWNER_KEY WHERE UPPER(ml.MOIRA_LIST_NAME) LIKE 'E%' GROUP BY ml.MOIRA_LIST_NAME, mlo.OWNER HAVING COUNT(mld.MOIRA_LIST_MEMBER) BETWEEN 10 AND 20), CSStudentCounts AS (SELECT ml.MOIRA_LIST_NAME, COUNT(CASE WHEN msd.DEPARTMENT = '6' THEN 1 ELSE NULL END) AS CS_STUDENT_COUNT FROM FilteredLists fl JOIN MOIRA_LIST ml ON fl.MOIRA_LIST_NAME = ml.MOIRA_LIST_NAME JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY JOIN SE_PERSON se ON UPPER(mld.MOIRA_LIST_MEMBER) = UPPER(se.KRB_NAME) JOIN MIT_STUDENT_DIRECTORY msd ON se.FULL_NAME = msd.FULL_NAME GROUP BY ml.MOIRA_LIST_NAME) SELECT fl.MOIRA_LIST_NAME, fl.OWNER, fl.TOTAL_MEMBER_COUNT FROM FilteredLists fl JOIN CSStudentCounts cs ON fl.MOIRA_LIST_NAME = cs.MOIRA_LIST_NAME WHERE cs.CS_STUDENT_COUNT > 0.75 * fl.TOTAL_MEMBER_COUNT;",
    "gold_tables": [
      "dw#sep#MOIRA_LIST",
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#MOIRA_LIST_OWNER",
      "dw#sep#SE_PERSON",
      "dw#sep#MIT_STUDENT_DIRECTORY"
    ],
    "mapping": {
      "names": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "members": [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ],
      "computer science": [
        "MIT_STUDENT_DIRECTORY.DEPARTMENT"
      ],
      "owner": [
        "MOIRA_LIST_OWNER.OWNER"
      ]
    },
    "join_keys": [
      [
        "SE_PERSON.FULL_NAME",
        "MIT_STUDENT_DIRECTORY.FULL_NAME"
      ],
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER",
        "SE_PERSON.KRB_NAME"
      ],
      [
        "MOIRA_LIST.MOIRA_LIST_KEY",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY"
      ],
      [
        "MOIRA_LIST_OWNER.MOIRA_LIST_OWNER_KEY",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_OWNER_KEY"
      ]
    ]
  },
  {
    "question": "For students with last names starting with K, list their names, the phone numbers of departments they belong to, total number of mailing lists each student is in, and the average size of the mailing lists each student is in.",
    "db_id": "dw",
    "sql": "WITH MailingListSizes AS (SELECT ml.MOIRA_LIST_KEY, ml.MOIRA_LIST_NAME, COUNT(mld.MOIRA_LIST_MEMBER) AS List_Size FROM MOIRA_LIST ml JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY GROUP BY ml.MOIRA_LIST_KEY, ml.MOIRA_LIST_NAME) SELECT msd.FULL_NAME AS Student_Name, sad.DEPARTMENT_PHONE_NUMBER, COUNT(ml.MOIRA_LIST_KEY) AS Total_Lists, AVG(MLS.List_Size) AS Avg_List_Size FROM MIT_STUDENT_DIRECTORY msd JOIN SIS_DEPARTMENT sd ON msd.DEPARTMENT = sd.DEPARTMENT_CODE JOIN SIS_ADMIN_DEPARTMENT sad ON sd.DEPARTMENT_CODE = sad.SIS_ADMIN_DEPARTMENT_CODE JOIN SE_PERSON se ON msd.FULL_NAME = se.FULL_NAME JOIN MOIRA_LIST_DETAIL mld ON upper(se.KRB_NAME) = UPPER(mld.MOIRA_LIST_MEMBER) JOIN MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY JOIN MailingListSizes MLS ON ml.MOIRA_LIST_KEY = MLS.MOIRA_LIST_KEY WHERE msd.LAST_NAME LIKE 'K%' GROUP BY msd.FULL_NAME, sad.DEPARTMENT_PHONE_NUMBER;",
    "oracle_sql": "WITH MailingListSizes AS (SELECT ml.MOIRA_LIST_KEY, ml.MOIRA_LIST_NAME, COUNT(mld.MOIRA_LIST_MEMBER) AS List_Size FROM MOIRA_LIST ml JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY GROUP BY ml.MOIRA_LIST_KEY, ml.MOIRA_LIST_NAME) SELECT msd.FULL_NAME AS Student_Name, sad.DEPARTMENT_PHONE_NUMBER, COUNT(ml.MOIRA_LIST_KEY) AS Total_Lists, AVG(MLS.List_Size) AS Avg_List_Size FROM MIT_STUDENT_DIRECTORY msd JOIN SIS_DEPARTMENT sd ON msd.DEPARTMENT = sd.DEPARTMENT_CODE JOIN SIS_ADMIN_DEPARTMENT sad ON sd.DEPARTMENT_CODE = sad.SIS_ADMIN_DEPARTMENT_CODE JOIN SE_PERSON se ON msd.FULL_NAME = se.FULL_NAME JOIN MOIRA_LIST_DETAIL mld ON upper(se.KRB_NAME) = UPPER(mld.MOIRA_LIST_MEMBER) JOIN MOIRA_LIST ml ON mld.MOIRA_LIST_KEY = ml.MOIRA_LIST_KEY JOIN MailingListSizes MLS ON ml.MOIRA_LIST_KEY = MLS.MOIRA_LIST_KEY WHERE msd.LAST_NAME LIKE 'K%' GROUP BY msd.FULL_NAME, sad.DEPARTMENT_PHONE_NUMBER;",
    "gold_tables": [
      "dw#sep#MOIRA_LIST",
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#MIT_STUDENT_DIRECTORY",
      "dw#sep#SIS_DEPARTMENT",
      "dw#sep#SIS_ADMIN_DEPARTMENT",
      "dw#sep#SE_PERSON"
    ],
    "mapping": {
      "last names": [
        "MIT_STUDENT_DIRECTORY.LAST_NAME"
      ],
      "names": [
        "MIT_STUDENT_DIRECTORY.FULL_NAME"
      ],
      "phone numbers": [
        "SIS_ADMIN_DEPARTMENT.DEPARTMENT_PHONE_NUMBER"
      ],
      "mailing lists": [
        "MOIRA_LIST.MOIRA_LIST_KEY"
      ]
    },
    "join_keys": [
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY",
        "MOIRA_LIST.MOIRA_LIST_KEY"
      ],
      [
        "MIT_STUDENT_DIRECTORY.DEPARTMENT",
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ],
      [
        "SIS_DEPARTMENT.DEPARTMENT_CODE",
        "SIS_ADMIN_DEPARTMENT.SIS_ADMIN_DEPARTMENT_CODE"
      ],
      [
        "MIT_STUDENT_DIRECTORY.FULL_NAME",
        "SE_PERSON.FULL_NAME"
      ],
      [
        "MOIRA_LIST.MOIRA_LIST_KEY",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY"
      ]
    ]
  },
  {
    "question": "From the 100 email lists with the most number of subscribers, list their names, their total number of subscribers, their public status, the name of the department with the most presence in the list, and the number of students from this department in the list.",
    "db_id": "dw",
    "sql": "SELECT lmc.MOIRA_LIST_NAME, lmc.Member_Count, lmc.IS_PUBLIC, dc.DEPARTMENT_NAME AS Most_Prominent_Department, dc.Student_Count FROM (SELECT ml.MOIRA_LIST_NAME, ml.IS_PUBLIC, COUNT(mld.MOIRA_LIST_MEMBER) AS Member_Count FROM MOIRA_LIST ml JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY GROUP BY ml.MOIRA_LIST_NAME, ml.IS_PUBLIC) lmc LEFT JOIN (SELECT lmc.MOIRA_LIST_NAME, lmc.DEPARTMENT_NAME, lmc.Student_Count, @rank := IF(@current_list = lmc.MOIRA_LIST_NAME, @rank + 1, 1) AS `Rank`, @current_list := lmc.MOIRA_LIST_NAME FROM (SELECT ml.MOIRA_LIST_NAME, sd.DEPARTMENT_NAME, COUNT(msd.FULL_NAME) AS Student_Count FROM MOIRA_LIST ml JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY JOIN SE_PERSON se ON UPPER(mld.MOIRA_LIST_MEMBER) = UPPER(se.KRB_NAME) JOIN MIT_STUDENT_DIRECTORY msd ON msd.FULL_NAME = se.FULL_NAME JOIN SIS_DEPARTMENT sd ON msd.DEPARTMENT = sd.DEPARTMENT_CODE GROUP BY ml.MOIRA_LIST_NAME, sd.DEPARTMENT_NAME) lmc CROSS JOIN (SELECT @rank := 0, @current_list := '') vars ORDER BY lmc.MOIRA_LIST_NAME, Student_Count DESC) dc ON lmc.MOIRA_LIST_NAME = dc.MOIRA_LIST_NAME AND dc.`Rank` = 1 ORDER BY lmc.Member_Count DESC LIMIT 100;",
    "oracle_sql": "SELECT* FROM (WITH ListMemberCount AS ( SELECT ml.MOIRA_LIST_NAME, ml.IS_PUBLIC, COUNT(mld.MOIRA_LIST_MEMBER) AS Member_Count FROM MOIRA_LIST ml JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY GROUP BY ml.MOIRA_LIST_NAME, ml.IS_PUBLIC ), DepartmentCounts AS ( SELECT lmc.MOIRA_LIST_NAME, sd.DEPARTMENT_NAME, COUNT(msd.FULL_NAME) AS Student_Count, ROW_NUMBER() OVER ( PARTITION BY lmc.MOIRA_LIST_NAME ORDER BY COUNT(msd.FULL_NAME) DESC ) AS Rank FROM ListMemberCount lmc JOIN MOIRA_LIST ml ON lmc.MOIRA_LIST_NAME = ml.MOIRA_LIST_NAME JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY JOIN SE_PERSON se ON UPPER(mld.MOIRA_LIST_MEMBER) = upper(se.KRB_NAME) JOIN MIT_STUDENT_DIRECTORY msd ON msd.FULL_NAME = se.FULL_NAME JOIN SIS_DEPARTMENT sd ON msd.DEPARTMENT = sd.DEPARTMENT_CODE GROUP BY lmc.MOIRA_LIST_NAME, sd.DEPARTMENT_NAME ) SELECT lmc.MOIRA_LIST_NAME, lmc.Member_Count, lmc.IS_PUBLIC, dc.DEPARTMENT_NAME AS Most_Prominent_Department, dc.Student_Count FROM ListMemberCount lmc LEFT JOIN DepartmentCounts dc ON lmc.MOIRA_LIST_NAME = dc.MOIRA_LIST_NAME AND dc.Rank = 1 ORDER BY lmc.Member_Count DESC ) WHERE ROWNUM <= 100;",
    "gold_tables": [
      "dw#sep#MOIRA_LIST",
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#SE_PERSON",
      "dw#sep#MIT_STUDENT_DIRECTORY",
      "dw#sep#SIS_DEPARTMENT"
    ],
    "mapping": {
      "names": [
        "MOIRA_LIST.MOIRA_LIST_NAME"
      ],
      "subscribers": [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ],
      "public status": [
        "MOIRA_LIST.IS_PUBLIC"
      ],
      "department": [
        "SIS_DEPARTMENT.DEPARTMENT_NAME"
      ],
      "students": [
        "MIT_STUDENT_DIRECTORY.FULL_NAME"
      ]
    },
    "join_keys": [
      [
        "MOIRA_LIST.MOIRA_LIST_KEY",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY"
      ],
      [
        "MOIRA_LIST.MOIRA_LIST_KEY",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY"
      ],
      [
        "SIS_DEPARTMENT.DEPARTMENT_CODE",
        "MIT_STUDENT_DIRECTORY.DEPARTMENT"
      ]
    ]
  },
  {
    "question": "Calculate the total assignable and non-assignable area for each building by summing up the respective areas of all its floors. For each building, list the building name, building number, total assignable area, total non-assignable area, and total room count, sorted in descending order of the total assignable area.",
    "db_id": "dw",
    "sql": "SELECT b.BUILDING_NAME, b.BUILDING_NUMBER, SUM(f.ASSIGNABLE_AREA) AS TOTAL_ASSIGNABLE_AREA, SUM(f.NON_ASSIGNABLE_AREA) AS TOTAL_NON_ASSIGNABLE_AREA, COUNT(r.FAC_ROOM_KEY) AS TOTAL_ROOMS FROM FAC_BUILDING b JOIN FAC_FLOOR f ON b.FAC_BUILDING_KEY = f.BUILDING_KEY JOIN FAC_ROOMS r ON f.BUILDING_KEY = r.BUILDING_KEY AND f.FLOOR = r.FLOOR GROUP BY b.BUILDING_NAME, b.BUILDING_NUMBER ORDER BY TOTAL_ASSIGNABLE_AREA DESC;",
    "oracle_sql": "SELECT b.BUILDING_NAME, b.BUILDING_NUMBER, SUM(f.ASSIGNABLE_AREA) AS TOTAL_ASSIGNABLE_AREA, SUM(f.NON_ASSIGNABLE_AREA) AS TOTAL_NON_ASSIGNABLE_AREA, COUNT(r.FAC_ROOM_KEY) AS TOTAL_ROOMS FROM FAC_BUILDING b JOIN FAC_FLOOR f ON b.FAC_BUILDING_KEY = f.BUILDING_KEY JOIN FAC_ROOMS r ON f.BUILDING_KEY = r.BUILDING_KEY AND f.FLOOR = r.FLOOR GROUP BY b.BUILDING_NAME, b.BUILDING_NUMBER ORDER BY TOTAL_ASSIGNABLE_AREA DESC;",
    "gold_tables": [
      "dw#sep#FAC_BUILDING",
      "dw#sep#FAC_FLOOR",
      "dw#sep#FAC_ROOMS"
    ],
    "mapping": {
      "building name": [
        "FAC_BUILDING.BUILDING_NAME"
      ],
      "building number": [
        "FAC_BUILDING.BUILDING_NUMBER"
      ],
      "assignable area": [
        "FAC_FLOOR.ASSIGNABLE_AREA"
      ],
      "non-assignable area": [
        "FAC_FLOOR.NON_ASSIGNABLE_AREA"
      ],
      "room": [
        "FAC_ROOMS.FAC_ROOM_KEY"
      ]
    },
    "join_keys": [
      [
        "FAC_BUILDING.FAC_BUILDING_KEY",
        "FAC_FLOOR.BUILDING_KEY"
      ],
      [
        "FAC_FLOOR.BUILDING_KEY",
        "FAC_ROOMS.BUILDING_KEY"
      ],
      [
        "FAC_FLOOR.FLOOR",
        "FAC_ROOMS.FLOOR"
      ]
    ]
  },
  {
    "question": "List all rooms in building 45, including their full name, area, major use, the organization that occupies them, the count of rooms per major use, and the total area occupied by rooms for each organization.",
    "db_id": "dw",
    "sql": "SELECT r.ROOM_FULL_NAME, MAX(r.AREA), mu.MAJOR_USE, MAX(o.ORGANIZATION_NAME), COUNT(r.FAC_ROOM_KEY) AS ROOM_COUNT, SUM(r.AREA) AS TOTAL_ROOM_AREA FROM FAC_ROOMS r JOIN FAC_MAJOR_USE mu ON r.MAJOR_USE_KEY = mu.MAJOR_USE_KEY JOIN FAC_ORGANIZATION o ON r.ORGANIZATION_KEY = o.ORGANIZATION_KEY WHERE r.BUILDING_KEY = 45 GROUP BY r.ROOM_FULL_NAME, mu.MAJOR_USE ORDER BY r.ROOM_FULL_NAME;",
    "oracle_sql": "SELECT r.ROOM_FULL_NAME, MAX(r.AREA), mu.MAJOR_USE, MAX(o.ORGANIZATION_NAME), COUNT(r.FAC_ROOM_KEY) AS ROOM_COUNT, SUM(r.AREA) AS TOTAL_ROOM_AREA FROM FAC_ROOMS r JOIN FAC_MAJOR_USE mu ON r.MAJOR_USE_KEY = mu.MAJOR_USE_KEY JOIN FAC_ORGANIZATION o ON r.ORGANIZATION_KEY = o.ORGANIZATION_KEY WHERE r.BUILDING_KEY = 45 GROUP BY r.ROOM_FULL_NAME, mu.MAJOR_USE ORDER BY r.ROOM_FULL_NAME;",
    "gold_tables": [
      "dw#sep#FAC_ROOMS",
      "dw#sep#FAC_MAJOR_USE",
      "dw#sep#FAC_ORGANIZATION"
    ],
    "mapping": {
      "building 45": [
        "FAC_ROOMS.BUILDING_KEY"
      ],
      "full name": [
        "FAC_ROOMS.ROOM_FULL_NAME"
      ],
      "area": [
        "FAC_ROOMS.AREA"
      ],
      "major use": [
        "FAC_MAJOR_USE.MAJOR_USE"
      ],
      "organization": [
        "FAC_ORGANIZATION.ORGANIZATION_NAME"
      ],
      "rooms": [
        "FAC_ROOMS.FAC_ROOM_KEY"
      ]
    },
    "join_keys": [
      [
        "FAC_ROOMS.MAJOR_USE_KEY",
        "FAC_MAJOR_USE.MAJOR_USE_KEY"
      ],
      [
        "FAC_ROOMS.ORGANIZATION_KEY",
        "FAC_ORGANIZATION.ORGANIZATION_KEY"
      ]
    ]
  },
  {
    "question": "List the name, number, construction date, and type of all buildings, along with the count of addresses associated with each building, the average gross area of the buildings, and the total number of rooms in each building. Sort the results by building name.",
    "db_id": "dw",
    "sql": "SELECT b.BUILDING_NAME, b.BUILDING_NUMBER, b.DATE_BUILT, b.BUILDING_TYPE, COUNT(a.BUILDING_ADDRESS_KEY) AS ADDRESS_COUNT, AVG(b.EXT_GROSS_AREA) AS AVG_GROSS_AREA, COUNT(r.FAC_ROOM_KEY) AS TOTAL_ROOMS FROM FAC_BUILDING b JOIN FAC_BUILDING_ADDRESS a ON b.FAC_BUILDING_KEY = a.BUILDING_KEY JOIN FAC_ROOMS r ON b.FAC_BUILDING_KEY = r.BUILDING_KEY GROUP BY b.BUILDING_NAME, b.BUILDING_NUMBER, b.DATE_BUILT, b.BUILDING_TYPE ORDER BY b.BUILDING_NAME;",
    "oracle_sql": "SELECT b.BUILDING_NAME, b.BUILDING_NUMBER, b.DATE_BUILT, b.BUILDING_TYPE, COUNT(a.BUILDING_ADDRESS_KEY) AS ADDRESS_COUNT, AVG(b.EXT_GROSS_AREA) AS AVG_GROSS_AREA, COUNT(r.FAC_ROOM_KEY) AS TOTAL_ROOMS FROM FAC_BUILDING b JOIN FAC_BUILDING_ADDRESS a ON b.FAC_BUILDING_KEY = a.BUILDING_KEY JOIN FAC_ROOMS r ON b.FAC_BUILDING_KEY = r.BUILDING_KEY GROUP BY b.BUILDING_NAME, b.BUILDING_NUMBER, b.DATE_BUILT, b.BUILDING_TYPE ORDER BY b.BUILDING_NAME;",
    "gold_tables": [
      "dw#sep#FAC_BUILDING",
      "dw#sep#FAC_BUILDING_ADDRESS",
      "dw#sep#FAC_ROOMS"
    ],
    "mapping": {
      "name": [
        "FAC_BUILDING.BUILDING_NAME"
      ],
      "number": [
        "FAC_BUILDING.BUILDING_NUMBER"
      ],
      "construction date": [
        "FAC_BUILDING.DATE_BUILT"
      ],
      "type": [
        "FAC_BUILDING.BUILDING_TYPE"
      ],
      "addresses": [
        "FAC_BUILDING_ADDRESS.BUILDING_ADDRESS_KEY"
      ],
      "gross area": [
        "FAC_BUILDING.EXT_GROSS_AREA"
      ],
      "rooms": [
        "FAC_ROOMS.FAC_ROOM_KEY"
      ]
    },
    "join_keys": [
      [
        "FAC_BUILDING.FAC_BUILDING_KEY",
        "FAC_BUILDING_ADDRESS.BUILDING_KEY"
      ],
      [
        "FAC_ROOMS.BUILDING_KEY",
        "FAC_BUILDING.FAC_BUILDING_KEY"
      ]
    ]
  },
  {
    "question": "For each department, list its name, number of unique courses offered, the number of unique reserved materials, and the number of unique instructors associated with those courses, sorted by the number of unique courses offered in descending order.",
    "db_id": "dw",
    "sql": "SELECT lso.OFFER_DEPT_NAME AS DEPARTMENT, COUNT(DISTINCT lso.MASTER_COURSE_NUMBER) AS COURSE_COUNT, COUNT(DISTINCT lrc.CATALOG_TITLE) AS UNIQUE_MATERIALS, COUNT(DISTINCT lci.INSTRUCTOR_NAME) AS UNIQUE_INSTRUCTORS FROM LIBRARY_SUBJECT_OFFERED lso JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lso.LIBRARY_SUBJECT_OFFERED_KEY = lrmd.LIBRARY_SUBJECT_OFFERED_KEY JOIN LIBRARY_RESERVE_CATALOG lrc ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY JOIN LIBRARY_COURSE_INSTRUCTOR lci ON lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY = lci.LIBRARY_COURSE_INSTRUCTOR_KEY GROUP BY lso.OFFER_DEPT_NAME ORDER BY COURSE_COUNT DESC;",
    "oracle_sql": "SELECT lso.OFFER_DEPT_NAME AS DEPARTMENT, COUNT(DISTINCT lso.MASTER_COURSE_NUMBER) AS COURSE_COUNT, COUNT(DISTINCT lrc.CATALOG_TITLE) AS UNIQUE_MATERIALS, COUNT(DISTINCT lci.INSTRUCTOR_NAME) AS UNIQUE_INSTRUCTORS FROM LIBRARY_SUBJECT_OFFERED lso JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lso.LIBRARY_SUBJECT_OFFERED_KEY = lrmd.LIBRARY_SUBJECT_OFFERED_KEY JOIN LIBRARY_RESERVE_CATALOG lrc ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY JOIN LIBRARY_COURSE_INSTRUCTOR lci ON lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY = lci.LIBRARY_COURSE_INSTRUCTOR_KEY GROUP BY lso.OFFER_DEPT_NAME ORDER BY COURSE_COUNT DESC;",
    "gold_tables": [
      "dw#sep#LIBRARY_SUBJECT_OFFERED",
      "dw#sep#LIBRARY_RESERVE_MATRL_DETAIL",
      "dw#sep#LIBRARY_RESERVE_CATALOG",
      "dw#sep#LIBRARY_COURSE_INSTRUCTOR"
    ],
    "mapping": {
      "name": [
        "LIBRARY_SUBJECT_OFFERED.OFFER_DEPT_NAME"
      ],
      "course": [
        "LIBRARY_SUBJECT_OFFERED.MASTER_COURSE_NUMBER"
      ],
      "reserved materials": [
        "LIBRARY_RESERVE_CATALOG.CATALOG_TITLE"
      ],
      "instructors": [
        "LIBRARY_COURSE_INSTRUCTOR.INSTRUCTOR_NAME"
      ]
    },
    "join_keys": [
      [
        "LIBRARY_SUBJECT_OFFERED.LIBRARY_SUBJECT_OFFERED_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_SUBJECT_OFFERED_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_RESERVE_CATALOG_KEY",
        "LIBRARY_RESERVE_CATALOG.LIBRARY_RESERVE_CATALOG_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_COURSE_INSTRUCTOR_KEY",
        "LIBRARY_COURSE_INSTRUCTOR.LIBRARY_COURSE_INSTRUCTOR_KEY"
      ]
    ]
  },
  {
    "question": "For each course title, list the title, the total number of reserved materials, and the count of distinct material status associated with those materials, sorted by the total number of reserved materials in descending order.",
    "db_id": "dw",
    "sql": "SELECT lso.SUBJECT_TITLE AS COURSE_TITLE, COUNT(lrmd.LIBRARY_RESERVE_CATALOG_KEY) AS TOTAL_MATERIALS, COUNT(DISTINCT lms.LIBRARY_MATERIAL_STATUS) AS STATUS_COUNT FROM LIBRARY_RESERVE_MATRL_DETAIL lrmd JOIN LIBRARY_SUBJECT_OFFERED lso ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY JOIN LIBRARY_MATERIAL_STATUS lms ON lrmd.LIBRARY_MATERIAL_STATUS_KEY = lms.LIBRARY_MATERIAL_STATUS_KEY GROUP BY lso.SUBJECT_TITLE ORDER BY TOTAL_MATERIALS DESC;",
    "oracle_sql": "SELECT lso.SUBJECT_TITLE AS COURSE_TITLE, COUNT(lrmd.LIBRARY_RESERVE_CATALOG_KEY) AS TOTAL_MATERIALS, COUNT(DISTINCT lms.LIBRARY_MATERIAL_STATUS) AS STATUS_COUNT FROM LIBRARY_RESERVE_MATRL_DETAIL lrmd JOIN LIBRARY_SUBJECT_OFFERED lso ON lrmd.LIBRARY_SUBJECT_OFFERED_KEY = lso.LIBRARY_SUBJECT_OFFERED_KEY JOIN LIBRARY_MATERIAL_STATUS lms ON lrmd.LIBRARY_MATERIAL_STATUS_KEY = lms.LIBRARY_MATERIAL_STATUS_KEY GROUP BY lso.SUBJECT_TITLE ORDER BY TOTAL_MATERIALS DESC;",
    "gold_tables": [
      "dw#sep#LIBRARY_RESERVE_MATRL_DETAIL",
      "dw#sep#LIBRARY_SUBJECT_OFFERED",
      "dw#sep#LIBRARY_MATERIAL_STATUS"
    ],
    "mapping": {
      "title": [
        "LIBRARY_SUBJECT_OFFERED.SUBJECT_TITLE"
      ],
      "reserved materials": [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_RESERVE_CATALOG_KEY"
      ],
      "material status": [
        "LIBRARY_MATERIAL_STATUS.LIBRARY_MATERIAL_STATUS"
      ]
    },
    "join_keys": [
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_SUBJECT_OFFERED_KEY",
        "LIBRARY_SUBJECT_OFFERED.LIBRARY_SUBJECT_OFFERED_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_MATERIAL_STATUS_KEY",
        "LIBRARY_MATERIAL_STATUS.LIBRARY_MATERIAL_STATUS_KEY"
      ]
    ]
  },
  {
    "question": "For each instructor, list their name, the number of unique courses they teach, the total number of material assignments, average publication year, and number of distinct status, sorted by the number of unique courses in descending order.",
    "db_id": "dw",
    "sql": "SELECT lci.INSTRUCTOR_NAME, COUNT(DISTINCT lci.COURSE_NAME) AS COURSE_COUNT, COUNT(lci.LIBRARY_COURSE_INSTRUCTOR_KEY) AS MATERIAL_ASSIGNMENTS, AVG(lrc.CATALOG_YEAR) AS AVG_PUBLICATION_YEAR, COUNT(DISTINCT lms.LIBRARY_MATERIAL_STATUS) AS STATUS_COUNT FROM LIBRARY_COURSE_INSTRUCTOR lci JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lci.LIBRARY_COURSE_INSTRUCTOR_KEY = lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY JOIN LIBRARY_RESERVE_CATALOG lrc ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY JOIN LIBRARY_MATERIAL_STATUS lms ON lrmd.LIBRARY_MATERIAL_STATUS_KEY = lms.LIBRARY_MATERIAL_STATUS_KEY GROUP BY lci.INSTRUCTOR_NAME ORDER BY COURSE_COUNT DESC;",
    "oracle_sql": "SELECT lci.INSTRUCTOR_NAME, COUNT(DISTINCT lci.COURSE_NAME) AS COURSE_COUNT, COUNT(lci.LIBRARY_COURSE_INSTRUCTOR_KEY) AS MATERIAL_ASSIGNMENTS, AVG(lrc.CATALOG_YEAR) AS AVG_PUBLICATION_YEAR, COUNT(DISTINCT lms.LIBRARY_MATERIAL_STATUS) AS STATUS_COUNT FROM LIBRARY_COURSE_INSTRUCTOR lci JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lci.LIBRARY_COURSE_INSTRUCTOR_KEY = lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY JOIN LIBRARY_RESERVE_CATALOG lrc ON lrmd.LIBRARY_RESERVE_CATALOG_KEY = lrc.LIBRARY_RESERVE_CATALOG_KEY JOIN LIBRARY_MATERIAL_STATUS lms ON lrmd.LIBRARY_MATERIAL_STATUS_KEY = lms.LIBRARY_MATERIAL_STATUS_KEY GROUP BY lci.INSTRUCTOR_NAME ORDER BY COURSE_COUNT DESC;",
    "gold_tables": [
      "dw#sep#LIBRARY_COURSE_INSTRUCTOR",
      "dw#sep#LIBRARY_RESERVE_MATRL_DETAIL",
      "dw#sep#LIBRARY_RESERVE_CATALOG",
      "dw#sep#LIBRARY_MATERIAL_STATUS"
    ],
    "mapping": {
      "name": [
        "LIBRARY_COURSE_INSTRUCTOR.INSTRUCTOR_NAME"
      ],
      "course": [
        "LIBRARY_COURSE_INSTRUCTOR.COURSE_NAME"
      ],
      "material assignments": [
        "LIBRARY_COURSE_INSTRUCTOR.LIBRARY_COURSE_INSTRUCTOR_KEY"
      ],
      "publication year": [
        "LIBRARY_RESERVE_CATALOG.CATALOG_YEAR"
      ],
      "status": [
        "LIBRARY_MATERIAL_STATUS.LIBRARY_MATERIAL_STATUS"
      ]
    },
    "join_keys": [
      [
        "LIBRARY_COURSE_INSTRUCTOR.LIBRARY_COURSE_INSTRUCTOR_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_COURSE_INSTRUCTOR_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_RESERVE_CATALOG_KEY",
        "LIBRARY_RESERVE_CATALOG.LIBRARY_RESERVE_CATALOG_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_MATERIAL_STATUS_KEY",
        "LIBRARY_MATERIAL_STATUS.LIBRARY_MATERIAL_STATUS_KEY"
      ]
    ]
  },
  {
    "question": "For each publication year, list the year, the total number of reserved materials, the average length of their titles, distinct number of status, and number of courses, sorted by publication year in descending order.",
    "db_id": "dw",
    "sql": "SELECT lrc.CATALOG_YEAR AS PUBLICATION_YEAR, COUNT(distinct lrc.LIBRARY_RESERVE_CATALOG_KEY) AS TOTAL_MATERIALS, AVG(LENGTH(lrc.CATALOG_TITLE)) AS AVG_TITLE_LENGTH, COUNT(DISTINCT lms.LIBRARY_MATERIAL_STATUS) AS STATUS_COUNT, COUNT(DISTINCT lci.COURSE_NAME) AS COURSE_COUNT FROM LIBRARY_RESERVE_CATALOG lrc JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lrc.LIBRARY_RESERVE_CATALOG_KEY = lrmd.LIBRARY_RESERVE_CATALOG_KEY JOIN LIBRARY_MATERIAL_STATUS lms ON lrmd.LIBRARY_MATERIAL_STATUS_KEY = lms.LIBRARY_MATERIAL_STATUS_KEY JOIN LIBRARY_COURSE_INSTRUCTOR lci ON lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY = lci.LIBRARY_COURSE_INSTRUCTOR_KEY GROUP BY lrc.CATALOG_YEAR ORDER BY PUBLICATION_YEAR DESC;",
    "oracle_sql": "SELECT lrc.CATALOG_YEAR AS PUBLICATION_YEAR, COUNT(distinct lrc.LIBRARY_RESERVE_CATALOG_KEY) AS TOTAL_MATERIALS, AVG(LENGTH(lrc.CATALOG_TITLE)) AS AVG_TITLE_LENGTH, COUNT(DISTINCT lms.LIBRARY_MATERIAL_STATUS) AS STATUS_COUNT, COUNT(DISTINCT lci.COURSE_NAME) AS COURSE_COUNT FROM LIBRARY_RESERVE_CATALOG lrc JOIN LIBRARY_RESERVE_MATRL_DETAIL lrmd ON lrc.LIBRARY_RESERVE_CATALOG_KEY = lrmd.LIBRARY_RESERVE_CATALOG_KEY JOIN LIBRARY_MATERIAL_STATUS lms ON lrmd.LIBRARY_MATERIAL_STATUS_KEY = lms.LIBRARY_MATERIAL_STATUS_KEY JOIN LIBRARY_COURSE_INSTRUCTOR lci ON lrmd.LIBRARY_COURSE_INSTRUCTOR_KEY = lci.LIBRARY_COURSE_INSTRUCTOR_KEY GROUP BY lrc.CATALOG_YEAR ORDER BY PUBLICATION_YEAR DESC;",
    "gold_tables": [
      "dw#sep#LIBRARY_RESERVE_CATALOG",
      "dw#sep#LIBRARY_RESERVE_MATRL_DETAIL",
      "dw#sep#LIBRARY_MATERIAL_STATUS",
      "dw#sep#LIBRARY_COURSE_INSTRUCTOR"
    ],
    "mapping": {
      "publication year": [
        "LIBRARY_RESERVE_CATALOG.CATALOG_YEAR"
      ],
      "reserved materials": [
        "LIBRARY_RESERVE_CATALOG.LIBRARY_RESERVE_CATALOG_KEY"
      ],
      "title": [
        "LIBRARY_RESERVE_CATALOG.CATALOG_TITLE"
      ],
      "status": [
        "LIBRARY_MATERIAL_STATUS.LIBRARY_MATERIAL_STATUS"
      ],
      "courses": [
        "LIBRARY_COURSE_INSTRUCTOR.COURSE_NAME"
      ]
    },
    "join_keys": [
      [
        "LIBRARY_RESERVE_CATALOG.LIBRARY_RESERVE_CATALOG_KEY",
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_RESERVE_CATALOG_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_MATERIAL_STATUS_KEY",
        "LIBRARY_MATERIAL_STATUS.LIBRARY_MATERIAL_STATUS_KEY"
      ],
      [
        "LIBRARY_RESERVE_MATRL_DETAIL.LIBRARY_COURSE_INSTRUCTOR_KEY",
        "LIBRARY_COURSE_INSTRUCTOR.LIBRARY_COURSE_INSTRUCTOR_KEY"
      ]
    ]
  },
  {
    "question": "For each IAP category, list the category name, the sponsor name, the number of activities offered, and the average fee per activity, sorted by the number of activities in descending order.",
    "db_id": "dw",
    "sql": "SELECT isc.IAP_CATEGORY_NAME AS CATEGORY_NAME, iss.SPONSOR_NAME, COUNT(isd.IAP_SUBJECT_CATEGORY_KEY) AS ACTIVITY_COUNT, AVG(isd.FEE) AS AVG_FEE_PER_ACTIVITY FROM IAP_SUBJECT_DETAIL isd JOIN IAP_SUBJECT_CATEGORY isc ON isd.IAP_SUBJECT_CATEGORY_KEY = isc.IAP_SUBJECT_CATEGORY_KEY JOIN IAP_SUBJECT_SPONSOR iss ON isd.IAP_SUBJECT_SPONSOR_KEY = iss.IAP_SUBJECT_SPONSOR_KEY GROUP BY isc.IAP_CATEGORY_NAME, iss.SPONSOR_NAME ORDER BY ACTIVITY_COUNT DESC;",
    "oracle_sql": "SELECT isc.IAP_CATEGORY_NAME AS CATEGORY_NAME, iss.SPONSOR_NAME, COUNT(isd.IAP_SUBJECT_CATEGORY_KEY) AS ACTIVITY_COUNT, AVG(isd.FEE) AS AVG_FEE_PER_ACTIVITY FROM IAP_SUBJECT_DETAIL isd JOIN IAP_SUBJECT_CATEGORY isc ON isd.IAP_SUBJECT_CATEGORY_KEY = isc.IAP_SUBJECT_CATEGORY_KEY JOIN IAP_SUBJECT_SPONSOR iss ON isd.IAP_SUBJECT_SPONSOR_KEY = iss.IAP_SUBJECT_SPONSOR_KEY GROUP BY isc.IAP_CATEGORY_NAME, iss.SPONSOR_NAME ORDER BY ACTIVITY_COUNT DESC;",
    "gold_tables": [
      "dw#sep#IAP_SUBJECT_DETAIL",
      "dw#sep#IAP_SUBJECT_CATEGORY",
      "dw#sep#IAP_SUBJECT_SPONSOR"
    ],
    "mapping": {
      "category name": [
        "IAP_SUBJECT_CATEGORY.IAP_CATEGORY_NAME"
      ],
      "sponsor name": [
        "IAP_SUBJECT_SPONSOR.SPONSOR_NAME"
      ],
      "activities": [
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_CATEGORY_KEY"
      ],
      "fee": [
        "IAP_SUBJECT_DETAIL.FEE"
      ]
    },
    "join_keys": [
      [
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_CATEGORY_KEY",
        "IAP_SUBJECT_CATEGORY.IAP_SUBJECT_CATEGORY_KEY"
      ],
      [
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_SPONSOR_KEY",
        "IAP_SUBJECT_SPONSOR.IAP_SUBJECT_SPONSOR_KEY"
      ]
    ]
  },
  {
    "question": "For each sponsor, list the sponsor name, the number of IAP sessions hosted, and the number of unique subjects organized.",
    "db_id": "dw",
    "sql": "SELECT iss.SPONSOR_NAME, COUNT(issp.IAP_SUBJECT_SESSION_KEY) AS SESSION_COUNT, COUNT(DISTINCT isd.IAP_SUBJECT_SESSION_KEY) AS UNIQUE_SUBJECTS FROM IAP_SUBJECT_SESSION issp JOIN IAP_SUBJECT_DETAIL isd ON issp.IAP_SUBJECT_SESSION_KEY = isd.IAP_SUBJECT_SESSION_KEY JOIN IAP_SUBJECT_SPONSOR iss ON isd.IAP_SUBJECT_SPONSOR_KEY = iss.IAP_SUBJECT_SPONSOR_KEY GROUP BY iss.SPONSOR_NAME ORDER BY SESSION_COUNT DESC;",
    "oracle_sql": "SELECT iss.SPONSOR_NAME, COUNT(issp.IAP_SUBJECT_SESSION_KEY) AS SESSION_COUNT, COUNT(DISTINCT isd.IAP_SUBJECT_SESSION_KEY) AS UNIQUE_SUBJECTS FROM IAP_SUBJECT_SESSION issp JOIN IAP_SUBJECT_DETAIL isd ON issp.IAP_SUBJECT_SESSION_KEY = isd.IAP_SUBJECT_SESSION_KEY JOIN IAP_SUBJECT_SPONSOR iss ON isd.IAP_SUBJECT_SPONSOR_KEY = iss.IAP_SUBJECT_SPONSOR_KEY GROUP BY iss.SPONSOR_NAME ORDER BY SESSION_COUNT DESC;",
    "gold_tables": [
      "dw#sep#IAP_SUBJECT_SESSION",
      "dw#sep#IAP_SUBJECT_DETAIL",
      "dw#sep#IAP_SUBJECT_SPONSOR"
    ],
    "mapping": {
      "sponsor name": [
        "IAP_SUBJECT_SPONSOR.SPONSOR_NAME"
      ],
      "IAP sessions": [
        "IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY"
      ],
      "subjects": [
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_SESSION_KEY"
      ]
    },
    "join_keys": [
      [
        "IAP_SUBJECT_SESSION.IAP_SUBJECT_SESSION_KEY",
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_SESSION_KEY"
      ],
      [
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_SPONSOR_KEY",
        "IAP_SUBJECT_SPONSOR.IAP_SUBJECT_SPONSOR_KEY"
      ]
    ]
  },
  {
    "question": "For each person role and IAP category, list the role, the category name, the number of people in this role, and the average fee, sorted by the role count in descending order.",
    "db_id": "dw",
    "sql": "SELECT isp.PERSON_ROLE, isc.IAP_CATEGORY_NAME, COUNT(DISTINCT isp.IAP_SUBJECT_PERSON_KEY) AS ROLE_COUNT, AVG(isd.FEE) AS AVG_FEE FROM IAP_SUBJECT_PERSON isp JOIN IAP_SUBJECT_DETAIL isd ON isp.IAP_SUBJECT_PERSON_KEY = isd.IAP_SUBJECT_PERSON_KEY JOIN IAP_SUBJECT_CATEGORY isc ON isd.IAP_SUBJECT_CATEGORY_KEY = isc.IAP_SUBJECT_CATEGORY_KEY GROUP BY isp.PERSON_ROLE, isc.IAP_CATEGORY_NAME ORDER BY ROLE_COUNT DESC;",
    "oracle_sql": "SELECT isp.PERSON_ROLE, isc.IAP_CATEGORY_NAME, COUNT(DISTINCT isp.IAP_SUBJECT_PERSON_KEY) AS ROLE_COUNT, AVG(isd.FEE) AS AVG_FEE FROM IAP_SUBJECT_PERSON isp JOIN IAP_SUBJECT_DETAIL isd ON isp.IAP_SUBJECT_PERSON_KEY = isd.IAP_SUBJECT_PERSON_KEY JOIN IAP_SUBJECT_CATEGORY isc ON isd.IAP_SUBJECT_CATEGORY_KEY = isc.IAP_SUBJECT_CATEGORY_KEY GROUP BY isp.PERSON_ROLE, isc.IAP_CATEGORY_NAME ORDER BY ROLE_COUNT DESC;",
    "gold_tables": [
      "dw#sep#IAP_SUBJECT_PERSON",
      "dw#sep#IAP_SUBJECT_DETAIL",
      "dw#sep#IAP_SUBJECT_CATEGORY"
    ],
    "mapping": {
      "role": [
        "IAP_SUBJECT_PERSON.PERSON_ROLE"
      ],
      "category name": [
        "IAP_SUBJECT_CATEGORY.IAP_CATEGORY_NAME"
      ],
      "people": [
        "IAP_SUBJECT_PERSON.IAP_SUBJECT_PERSON_KEY"
      ],
      "fee": [
        "IAP_SUBJECT_DETAIL.FEE"
      ]
    },
    "join_keys": [
      [
        "IAP_SUBJECT_PERSON.IAP_SUBJECT_PERSON_KEY",
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_PERSON_KEY"
      ],
      [
        "IAP_SUBJECT_DETAIL.IAP_SUBJECT_CATEGORY_KEY",
        "IAP_SUBJECT_CATEGORY.IAP_SUBJECT_CATEGORY_KEY"
      ]
    ]
  },
  {
    "question": "List the names of the buildings with the most floors. If there are ties, list each one separately.",
    "db_id": "dw",
    "sql": "WITH FloorsPerBuilding AS ( SELECT fb.BUILDING_NAME, MAX(ff.LEVEL_ID) - MIN(ff.LEVEL_ID) AS NUM_FLOORS FROM FAC_BUILDING fb JOIN FAC_ROOMS fr ON fb.FAC_BUILDING_KEY = fr.BUILDING_KEY JOIN FAC_FLOOR ff ON fr.FLOOR_KEY = ff.FLOOR_KEY GROUP BY fb.BUILDING_NAME ), MaxFloors AS ( SELECT MAX(NUM_FLOORS) AS MAX_FLOORS FROM FloorsPerBuilding ) SELECT a.BUILDING_NAME FROM FloorsPerBuilding a JOIN MaxFloors b ON a.NUM_FLOORS = b.MAX_FLOORS;",
    "oracle_sql": "WITH FloorsPerBuilding AS ( SELECT fb.BUILDING_NAME, MAX(ff.LEVEL_ID) - MIN(ff.LEVEL_ID) AS NUM_FLOORS FROM FAC_BUILDING fb JOIN FAC_ROOMS fr ON fb.FAC_BUILDING_KEY = fr.BUILDING_KEY JOIN FAC_FLOOR ff ON fr.FLOOR_KEY = ff.FLOOR_KEY GROUP BY fb.BUILDING_NAME ), MaxFloors AS ( SELECT MAX(NUM_FLOORS) AS MAX_FLOORS FROM FloorsPerBuilding ) SELECT a.BUILDING_NAME FROM FloorsPerBuilding a JOIN MaxFloors b ON a.NUM_FLOORS = b.MAX_FLOORS;",
    "gold_tables": [
      "dw#sep#FAC_BUILDING",
      "dw#sep#FAC_ROOMS",
      "dw#sep#FAC_FLOOR"
    ],
    "mapping": {
      "name of the buildings": [
        "FAC_BUILDING.BUILDING_NAME"
      ],
      "floors": [
        "FAC_FLOOR.LEVEL_ID"
      ]
    },
    "join_keys": [
      [
        "FAC_ROOMS.BUILDING_KEY",
        "FAC_BUILDING.FAC_BUILDING_KEY"
      ],
      [
        "FAC_FLOOR.FLOOR_KEY",
        "FAC_ROOMS.FLOOR_KEY"
      ]
    ]
  },
  {
    "question": "For subjects offered in the summer term, list the subject titles, number of instructors, and the length of the longest instructor name.",
    "db_id": "dw",
    "sql": "SELECT ccso.SUBJECT_TITLE, COUNT(DISTINCT e.FULL_NAME) AS Num_Instructors, MAX(LENGTH(e.FULL_NAME)) AS Longest_Instructor_Name FROM EMPLOYEE_DIRECTORY e JOIN COURSE_CATALOG_SUBJECT_OFFERED ccso ON ccso.RESPONSIBLE_FACULTY_MIT_ID = e.MIT_ID JOIN ACADEMIC_TERMS_ALL at ON ccso.TERM_CODE = at.TERM_CODE WHERE at.TERM_CODE LIKE '%SU' GROUP BY ccso.SUBJECT_TITLE;",
    "oracle_sql": "SELECT ccso.SUBJECT_TITLE, COUNT(DISTINCT e.FULL_NAME) AS Num_Instructors, MAX(LENGTH(e.FULL_NAME)) AS Longest_Instructor_Name FROM EMPLOYEE_DIRECTORY e JOIN COURSE_CATALOG_SUBJECT_OFFERED ccso ON ccso.RESPONSIBLE_FACULTY_MIT_ID = e.MIT_ID JOIN ACADEMIC_TERMS_ALL at ON ccso.TERM_CODE = at.TERM_CODE WHERE at.TERM_CODE LIKE '%SU' GROUP BY ccso.SUBJECT_TITLE;",
    "gold_tables": [
      "dw#sep#EMPLOYEE_DIRECTORY",
      "dw#sep#COURSE_CATALOG_SUBJECT_OFFERED",
      "dw#sep#ACADEMIC_TERMS_ALL"
    ],
    "mapping": {
      "summer term": [
        "ACADEMIC_TERMS_ALL.TERM_CODE"
      ],
      "subject titles": [
        "COURSE_CATALOG_SUBJECT_OFFERED.SUBJECT_TITLE"
      ],
      "instructors": [
        "EMPLOYEE_DIRECTORY.FULL_NAME"
      ],
      "instructor name": [
        "EMPLOYEE_DIRECTORY.FULL_NAME"
      ]
    },
    "join_keys": [
      [
        "COURSE_CATALOG_SUBJECT_OFFERED.RESPONSIBLE_FACULTY_MIT_ID",
        "EMPLOYEE_DIRECTORY.MIT_ID"
      ],
      [
        "COURSE_CATALOG_SUBJECT_OFFERED.TERM_CODE",
        "ACADEMIC_TERMS_ALL.TERM_CODE"
      ]
    ]
  },
  {
    "question": "For the mailing list with owner key LIST69.377-keeper-xenon, list the owner, total number of mailing lists, and total number of members across all these mailing lists.",
    "db_id": "dw",
    "sql": "SELECT mlo.OWNER, COUNT(DISTINCT ml.MOIRA_LIST_KEY) AS Total_Lists, COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) AS Total_Members FROM MOIRA_LIST ml JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY JOIN MOIRA_LIST_OWNER mlo ON mld.MOIRA_LIST_OWNER_KEY = mlo.MOIRA_LIST_OWNER_KEY WHERE mlo.MOIRA_LIST_OWNER_KEY = 'LIST69.377-keeper-xenon' GROUP BY mlo.OWNER;",
    "oracle_sql": "SELECT mlo.OWNER, COUNT(DISTINCT ml.MOIRA_LIST_KEY) AS Total_Lists, COUNT(DISTINCT mld.MOIRA_LIST_MEMBER) AS Total_Members FROM MOIRA_LIST ml JOIN MOIRA_LIST_DETAIL mld ON ml.MOIRA_LIST_KEY = mld.MOIRA_LIST_KEY JOIN MOIRA_LIST_OWNER mlo ON mld.MOIRA_LIST_OWNER_KEY = mlo.MOIRA_LIST_OWNER_KEY WHERE mlo.MOIRA_LIST_OWNER_KEY = 'LIST69.377-keeper-xenon' GROUP BY mlo.OWNER;",
    "gold_tables": [
      "dw#sep#MOIRA_LIST",
      "dw#sep#MOIRA_LIST_DETAIL",
      "dw#sep#MOIRA_LIST_OWNER"
    ],
    "mapping": {
      "owner key": [
        "MOIRA_LIST_OWNER.MOIRA_LIST_OWNER_KEY"
      ],
      "owner": [
        "MOIRA_LIST_OWNER.OWNER"
      ],
      "mailing lists": [
        "MOIRA_LIST.MOIRA_LIST_KEY"
      ],
      "members": [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_MEMBER"
      ]
    },
    "join_keys": [
      [
        "MOIRA_LIST.MOIRA_LIST_KEY",
        "MOIRA_LIST_DETAIL.MOIRA_LIST_KEY"
      ],
      [
        "MOIRA_LIST_DETAIL.MOIRA_LIST_OWNER_KEY",
        "MOIRA_LIST_OWNER.MOIRA_LIST_OWNER_KEY"
      ]
    ]
  },
  {
    "question": "For each school, list the school name, total number of courses that appear in SIS subject code catalog, and the total number of degree-granting courses that appear in SIS subject code catalog.",
    "db_id": "dw",
    "sql": "SELECT sd.SCHOOL_NAME, COUNT(DISTINCT scd.COURSE) AS Total_Courses, COUNT(CASE WHEN scd.IS_DEGREE_GRANTING = 'Y' THEN 1 END) AS Num_Degree_Granting_Y FROM SIS_COURSE_DESCRIPTION scd JOIN SIS_DEPARTMENT sd ON scd.DEPARTMENT = sd.DEPARTMENT_CODE JOIN SIS_SUBJECT_CODE ssc ON scd.COURSE = ssc.COURSE_NUMBER GROUP BY sd.SCHOOL_NAME;",
    "oracle_sql": "SELECT sd.SCHOOL_NAME, COUNT(DISTINCT scd.COURSE) AS Total_Courses, COUNT(CASE WHEN scd.IS_DEGREE_GRANTING = 'Y' THEN 1 END) AS Num_Degree_Granting_Y FROM SIS_COURSE_DESCRIPTION scd JOIN SIS_DEPARTMENT sd ON scd.DEPARTMENT = sd.DEPARTMENT_CODE JOIN SIS_SUBJECT_CODE ssc ON scd.COURSE = ssc.COURSE_NUMBER GROUP BY sd.SCHOOL_NAME;",
    "gold_tables": [
      "dw#sep#SIS_COURSE_DESCRIPTION",
      "dw#sep#SIS_DEPARTMENT",
      "dw#sep#SIS_SUBJECT_CODE"
    ],
    "mapping": {
      "school name": [
        "SIS_DEPARTMENT.SCHOOL_NAME"
      ],
      "courses": [
        "SIS_COURSE_DESCRIPTION.COURSE"
      ],
      "degree-granting courses": [
        "SIS_COURSE_DESCRIPTION.IS_DEGREE_GRANTING"
      ]
    },
    "join_keys": [
      [
        "SIS_COURSE_DESCRIPTION.DEPARTMENT",
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ],
      [
        "SIS_COURSE_DESCRIPTION.COURSE",
        "SIS_SUBJECT_CODE.COURSE_NUMBER"
      ]
    ]
  },
  {
    "question": "For each department, list the department name, department phone number, number of students, and the length of the longest student full name in that department.",
    "db_id": "dw",
    "sql": "SELECT sd.DEPARTMENT_NAME, sad.DEPARTMENT_PHONE_NUMBER, COUNT(DISTINCT msd.EMAIL_ADDRESS) AS Num_Students, MAX(LENGTH(msd.FULL_NAME)) AS Longest_Student_Name_Length FROM MIT_STUDENT_DIRECTORY msd JOIN SIS_DEPARTMENT sd ON msd.DEPARTMENT = sd.DEPARTMENT_CODE JOIN SIS_ADMIN_DEPARTMENT sad ON sd.DEPARTMENT_CODE = sad.SIS_ADMIN_DEPARTMENT_CODE GROUP BY sd.DEPARTMENT_NAME, sad.DEPARTMENT_PHONE_NUMBER;",
    "oracle_sql": "SELECT sd.DEPARTMENT_NAME, sad.DEPARTMENT_PHONE_NUMBER, COUNT(DISTINCT msd.EMAIL_ADDRESS) AS Num_Students, MAX(LENGTH(msd.FULL_NAME)) AS Longest_Student_Name_Length FROM MIT_STUDENT_DIRECTORY msd JOIN SIS_DEPARTMENT sd ON msd.DEPARTMENT = sd.DEPARTMENT_CODE JOIN SIS_ADMIN_DEPARTMENT sad ON sd.DEPARTMENT_CODE = sad.SIS_ADMIN_DEPARTMENT_CODE GROUP BY sd.DEPARTMENT_NAME, sad.DEPARTMENT_PHONE_NUMBER;",
    "gold_tables": [
      "dw#sep#MIT_STUDENT_DIRECTORY",
      "dw#sep#SIS_DEPARTMENT",
      "dw#sep#SIS_ADMIN_DEPARTMENT"
    ],
    "mapping": {
      "department name": [
        "SIS_DEPARTMENT.DEPARTMENT_NAME"
      ],
      "department phone number": [
        "SIS_ADMIN_DEPARTMENT.DEPARTMENT_PHONE_NUMBER"
      ],
      "students": [
        "MIT_STUDENT_DIRECTORY.EMAIL_ADDRESS"
      ],
      "student full name": [
        "MIT_STUDENT_DIRECTORY.FULL_NAME"
      ]
    },
    "join_keys": [
      [
        "MIT_STUDENT_DIRECTORY.DEPARTMENT",
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ],
      [
        "SIS_ADMIN_DEPARTMENT.SIS_ADMIN_DEPARTMENT_CODE",
        "SIS_DEPARTMENT.DEPARTMENT_CODE"
      ]
    ]
  }
]